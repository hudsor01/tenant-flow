[{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/scripts/audit-rls-security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/scripts/check-rls-completeness.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/scripts/security-audit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/scripts/stripe-backfill.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: /Users/richard/Developer/tenant-flow/apps/backend/scripts/stripe-backfill.ts was not found by the project service. Consider either including it in the tsconfig.json or including it in allowDefaultProject."}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NestFactory } from '@nestjs/core'\nimport { AppModule } from '../src/app.module'\nimport { StripeSyncService } from '../src/billing/stripe-sync.service'\n\nasync function backfillStripeData() {\n  console.log('üöÄ Starting Stripe data backfill...')\n  \n  const app = await NestFactory.createApplicationContext(AppModule, {\n    logger: ['error', 'warn', 'log']\n  })\n\n  try {\n    const stripeSyncService = app.get(StripeSyncService)\n    await stripeSyncService.backfillData()\n    console.log('‚úÖ Stripe data backfill completed successfully')\n  } catch (error) {\n    console.error('‚ùå Stripe data backfill failed:', error)\n    process.exit(1)\n  } finally {\n    await app.close()\n  }\n}\n\nbackfillStripeData()","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/scripts/validate-stripe-schema.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: /Users/richard/Developer/tenant-flow/apps/backend/scripts/validate-stripe-schema.ts was not found by the project service. Consider either including it in the tsconfig.json or including it in allowDefaultProject."}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'dotenv/config'\nimport pg from 'pg'\n\n/**\n * Validate Stripe Schema Creation\n * \n * Checks that the Stripe Sync Engine properly created the database schema\n */\nasync function validateStripeSchema() {\n  console.log('üîç Validating Stripe schema creation...')\n  \n  const databaseUrl = process.env.DATABASE_URL\n  if (!databaseUrl) {\n    console.error('‚ùå DATABASE_URL not found')\n    process.exit(1)\n  }\n\n  const client = new pg.Client({ connectionString: databaseUrl })\n  \n  try {\n    await client.connect()\n    console.log('‚úÖ Connected to database')\n\n    // Check if stripe schema exists\n    const schemaResult = await client.query(\n      \"SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'stripe'\"\n    )\n    \n    if (schemaResult.rows.length === 0) {\n      console.error('‚ùå Stripe schema not found')\n      return\n    }\n    console.log('‚úÖ Stripe schema exists')\n\n    // Count stripe tables\n    const tablesResult = await client.query(`\n      SELECT COUNT(*) as table_count \n      FROM information_schema.tables \n      WHERE table_schema = 'stripe'\n    `)\n    \n    const tableCount = parseInt(tablesResult.rows[0].table_count)\n    console.log(`üìä Found ${tableCount} stripe tables`)\n    \n    if (tableCount < 50) {\n      console.warn(`‚ö†Ô∏è  Expected 90+ tables, found ${tableCount}`)\n    } else {\n      console.log('‚úÖ Good number of tables created')\n    }\n\n    // List key tables\n    const keyTablesResult = await client.query(`\n      SELECT table_name \n      FROM information_schema.tables \n      WHERE table_schema = 'stripe' \n      AND table_name IN ('customers', 'subscriptions', 'invoices', 'prices', 'products', 'charges', 'payment_intents')\n      ORDER BY table_name\n    `)\n\n    console.log('üîë Key tables found:')\n    const foundTables = keyTablesResult.rows.map(row => row.table_name)\n    const expectedTables = ['customers', 'subscriptions', 'invoices', 'prices', 'products', 'charges', 'payment_intents']\n    \n    expectedTables.forEach(table => {\n      if (foundTables.includes(table)) {\n        console.log(`  ‚úÖ ${table}`)\n      } else {\n        console.log(`  ‚ùå ${table} (missing)`)\n      }\n    })\n\n    // Check if tables are empty (expected with 0 users)\n    const customerCount = await client.query('SELECT COUNT(*) FROM stripe.customers')\n    console.log(`üë• Customers in database: ${customerCount.rows[0].count}`)\n    \n    if (customerCount.rows[0].count === '0') {\n      console.log('‚úÖ Database is empty as expected (0 users)')\n    }\n\n    console.log('\\nüéâ Stripe schema validation completed successfully!')\n    \n  } catch (error) {\n    console.error('‚ùå Validation failed:', error)\n  } finally {\n    await client.end()\n  }\n}\n\nvalidateStripeSchema()","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/analytics/analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/app.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/app.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/app.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/auth/auth-webhook.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/auth/auth.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/auth/auth.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/auth/auth.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-data-validation.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'configService' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":27,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":236,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":236,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":256,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":256,"endColumn":19}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing'\nimport { ConfigService } from '@nestjs/config'\nimport { PinoLogger } from 'nestjs-pino'\nimport { StripeSyncService } from './stripe-sync.service'\nimport { SupabaseService } from '../database/supabase.service'\n\n/**\n * Stripe Data Validation Tests\n * \n * These tests run actual backfill operations and validate data integrity\n * against Stripe API to ensure sync is working correctly.\n * \n * ‚ö†Ô∏è  WARNING: These tests make real API calls and database modifications\n * Only run in dedicated test environments with test Stripe keys\n * \n * Prerequisites:\n * - Test Stripe account with sample data\n * - STRIPE_SECRET_KEY must be test key (sk_test_*)\n * - DATABASE_URL pointing to test database\n * \n * Run with: npm run test:data-validation\n */\ndescribe('Stripe Data Validation Tests', () => {\n  let service: StripeSyncService\n  let supabaseService: SupabaseService\n  let configService: ConfigService\n  \n  // Only run if explicitly configured for data validation testing\n  const isDataValidationEnabled = () => {\n    return process.env.ENABLE_DATA_VALIDATION_TESTS === 'true' &&\n           process.env.STRIPE_SECRET_KEY?.startsWith('sk_test_') &&\n           process.env.DATABASE_URL?.includes('test')\n  }\n\n  beforeAll(async () => {\n    if (!isDataValidationEnabled()) {\n      console.log('‚è≠Ô∏è  Skipping data validation tests - not enabled or using production keys')\n      return\n    }\n\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        SupabaseService,\n        ConfigService,\n        {\n          provide: PinoLogger,\n          useValue: {\n            info: jest.fn(),\n            error: jest.fn(),\n            warn: jest.fn(),\n            setContext: jest.fn()\n          }\n        }\n      ]\n    }).compile()\n\n    service = module.get<StripeSyncService>(StripeSyncService)\n    supabaseService = module.get<SupabaseService>(SupabaseService)\n    configService = module.get<ConfigService>(ConfigService)\n  })\n\n  describe('Backfill Operation', () => {\n    it('should complete backfill operation without errors', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const startTime = Date.now()\n      \n      // Run the actual backfill\n      const result = await service.backfillData()\n      \n      const duration = Date.now() - startTime\n      \n      expect(result).toEqual({ success: true })\n      expect(duration).toBeLessThan(30 * 60 * 1000) // Should complete in under 30 minutes\n    }, 30 * 60 * 1000) // 30 minute timeout\n\n    it('should have synced customer data correctly', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Get customer count from database\n      const { data: dbData, error } = await client\n        .from('stripe.customers')\n        .select('id', { count: 'exact' })\n      \n      expect(error).toBeNull()\n      expect(dbData).toBeDefined()\n      \n      // Should have at least some customers if test account has data\n      if (dbData && dbData.length > 0) {\n        expect(dbData.length).toBeGreaterThan(0)\n      }\n    })\n\n    it('should have synced subscription data correctly', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Get subscription data\n      const { data: subscriptions, error } = await client\n        .from('stripe.subscriptions')\n        .select('id, status, current_period_start, current_period_end')\n        .limit(5)\n      \n      expect(error).toBeNull()\n      \n      if (subscriptions && subscriptions.length > 0) {\n        subscriptions.forEach(sub => {\n          expect(sub.id).toMatch(/^sub_/) // Stripe subscription ID format\n          expect(['active', 'canceled', 'past_due', 'trialing', 'incomplete', 'paused']).toContain(sub.status)\n          expect(sub.current_period_start).toBeDefined()\n          expect(sub.current_period_end).toBeDefined()\n        })\n      }\n    })\n\n    it('should have synced product and price data correctly', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Get products with their prices\n      const { data: products, error: productsError } = await client\n        .from('stripe.products')\n        .select('id, name, active')\n        .eq('active', true)\n        .limit(5)\n      \n      expect(productsError).toBeNull()\n      \n      if (products && products.length > 0) {\n        // Get prices for these products\n        const { data: prices, error: pricesError } = await client\n          .from('stripe.prices')\n          .select('id, product, unit_amount, currency, active')\n          .in('product', products.map(p => p.id))\n        \n        expect(pricesError).toBeNull()\n        \n        if (prices && prices.length > 0) {\n          prices.forEach(price => {\n            expect(price.id).toMatch(/^price_/) // Stripe price ID format\n            expect(price.unit_amount).toBeGreaterThanOrEqual(0)\n            expect(price.currency).toMatch(/^[a-z]{3}$/) // 3-letter currency code\n          })\n        }\n      }\n    })\n  })\n\n  describe('Data Integrity Validation', () => {\n    it('should maintain referential integrity between customers and subscriptions', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Find subscriptions with invalid customer references\n      const { data: invalidRefs, error } = await client\n        .rpc('exec_sql', { \n          query: `\n            SELECT s.id as subscription_id, s.customer \n            FROM stripe.subscriptions s \n            LEFT JOIN stripe.customers c ON s.customer = c.id \n            WHERE c.id IS NULL \n            LIMIT 5\n          `\n        })\n      \n      expect(error).toBeNull()\n      expect(invalidRefs).toEqual([]) // Should be empty - no orphaned subscriptions\n    })\n\n    it('should have proper timestamp consistency', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Check that created timestamps are reasonable\n      const { data: recentData, error } = await client\n        .from('stripe.customers')\n        .select('id, created')\n        .order('created', { ascending: false })\n        .limit(5)\n      \n      expect(error).toBeNull()\n      \n      if (recentData && recentData.length > 0) {\n        recentData.forEach(customer => {\n          const createdDate = new Date(customer.created * 1000) // Stripe uses Unix timestamps\n          expect(createdDate.getTime()).toBeLessThanOrEqual(Date.now())\n          expect(createdDate.getTime()).toBeGreaterThan(Date.now() - (365 * 24 * 60 * 60 * 1000)) // Within last year\n        })\n      }\n    })\n\n    it('should have consistent data types and formats', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Test various data type consistency\n      const { data: invoices, error } = await client\n        .from('stripe.invoices')\n        .select('id, amount_due, amount_paid, currency, status')\n        .limit(10)\n      \n      expect(error).toBeNull()\n      \n      if (invoices && invoices.length > 0) {\n        invoices.forEach(invoice => {\n          expect(invoice.id).toMatch(/^in_/) // Stripe invoice ID format\n          expect(typeof invoice.amount_due).toBe('number')\n          expect(typeof invoice.amount_paid).toBe('number')\n          expect(invoice.amount_due).toBeGreaterThanOrEqual(0)\n          expect(invoice.amount_paid).toBeGreaterThanOrEqual(0)\n          expect(typeof invoice.currency).toBe('string')\n          expect(invoice.currency.length).toBe(3)\n        })\n      }\n    })\n  })\n\n  describe('Performance Validation', () => {\n    it('should query large datasets efficiently', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      const startTime = Date.now()\n      \n      // Test query performance on potentially large table\n      const { data, error } = await client\n        .from('stripe.customers')\n        .select('id, email, created')\n        .order('created', { ascending: false })\n        .limit(100)\n      \n      const queryTime = Date.now() - startTime\n      \n      expect(error).toBeNull()\n      expect(queryTime).toBeLessThan(5000) // Should complete in under 5 seconds\n    })\n\n    it('should handle complex JOIN queries efficiently', async () => {\n      if (!isDataValidationEnabled()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      const startTime = Date.now()\n      \n      // Complex query joining customers and subscriptions\n      const { data, error } = await client\n        .rpc('exec_sql', { \n          query: `\n            SELECT \n              c.id as customer_id,\n              c.email,\n              COUNT(s.id) as subscription_count,\n              MAX(s.created) as latest_subscription\n            FROM stripe.customers c\n            LEFT JOIN stripe.subscriptions s ON c.id = s.customer\n            GROUP BY c.id, c.email\n            ORDER BY subscription_count DESC\n            LIMIT 20\n          `\n        })\n      \n      const queryTime = Date.now() - startTime\n      \n      expect(error).toBeNull()\n      expect(queryTime).toBeLessThan(10000) // Should complete in under 10 seconds\n    })\n  })\n\n  describe('Webhook Processing Validation', () => {\n    it('should handle webhook processing after backfill', async () => {\n      if (!isDataValidationEnabled()) return\n\n      // Mock a customer.updated webhook\n      const mockWebhook = Buffer.from(JSON.stringify({\n        id: 'evt_test_validation',\n        type: 'customer.updated',\n        data: {\n          object: {\n            id: 'cus_test_validation',\n            email: 'validation@test.com',\n            name: 'Validation Test Customer'\n          }\n        }\n      }))\n      \n      const mockSignature = 'test_signature_validation'\n      \n      // Should not throw errors\n      await expect(service.processWebhook(mockWebhook, mockSignature))\n        .resolves.not.toThrow()\n    })\n  })\n})\n\n/**\n * Usage Instructions:\n * \n * To run these tests in your environment:\n * \n * 1. Set up test environment variables:\n *    export ENABLE_DATA_VALIDATION_TESTS=true\n *    export STRIPE_SECRET_KEY=sk_test_your_test_key\n *    export DATABASE_URL=postgresql://user:pass@localhost:5432/test_db\n * \n * 2. Run the tests:\n *    npm run test -- --testPathPatterns=\"stripe-data-validation.spec.ts\"\n * \n * 3. Monitor output for data validation results\n */","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-edge-cases.spec.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":140,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":140,"endColumn":68,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4831,4890],"text":"// @ts-expect-error - Testing runtime behavior with invalid input"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":143,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":143,"endColumn":68,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5003,5062],"text":"// @ts-expect-error - Testing runtime behavior with invalid input"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing';\nimport { ConfigService } from '@nestjs/config';\nimport { PinoLogger } from 'nestjs-pino';\nimport { InternalServerErrorException } from '@nestjs/common';\nimport { StripeSyncService } from './stripe-sync.service';\n\n// Mock Supabase client for edge case testing\nconst mockSupabaseClient = {\n  rpc: jest.fn(),\n};\n\njest.mock('@supabase/supabase-js', () => ({\n  createClient: jest.fn(() => mockSupabaseClient),\n}));\n\n/**\n * Edge Cases and Error Handling Tests for StripeSyncService\n * \n * These tests focus on boundary conditions, error scenarios,\n * and unusual inputs that could cause issues in production.\n */\ndescribe('StripeSyncService Edge Cases & Error Handling', () => {\n  let service: StripeSyncService;\n  let logger: PinoLogger;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => {\n              switch (key) {\n                case 'SUPABASE_URL':\n                  return 'https://test.supabase.co';\n                case 'SUPABASE_SERVICE_ROLE_KEY':\n                  return 'test-service-role-key';\n                default:\n                  return null;\n              }\n            }),\n          },\n        },\n        {\n          provide: PinoLogger,\n          useValue: {\n            setContext: jest.fn(),\n            info: jest.fn(),\n            error: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<StripeSyncService>(StripeSyncService);\n    logger = module.get<PinoLogger>(PinoLogger);\n\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Input Validation & Sanitization', () => {\n    describe('SQL Injection Prevention', () => {\n      it('should handle SQL injection attempts in customer ID', async () => {\n        const maliciousId = \"'; DROP TABLE customers; --\";\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getCustomer(maliciousId);\n\n        // Verify the query is properly escaped/sanitized\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.customers WHERE id = ''; DROP TABLE customers; --' LIMIT 1\",\n        });\n      });\n\n      it('should handle SQL injection attempts in product ID for prices', async () => {\n        const maliciousProductId = \"prod_123' UNION SELECT * FROM secret_table --\";\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getPrices(maliciousProductId);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.prices WHERE product = 'prod_123' UNION SELECT * FROM secret_table --' AND active = true ORDER BY created DESC\",\n        });\n      });\n    });\n\n    describe('Special Characters Handling', () => {\n      it('should handle customer IDs with special characters', async () => {\n        const specialId = \"cus_test@#$%^&*()\";\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getCustomer(specialId);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.customers WHERE id = 'cus_test@#$%^&*()' LIMIT 1\",\n        });\n      });\n\n      it('should handle Unicode characters in IDs', async () => {\n        const unicodeId = \"cus_ÊµãËØïÁî®Êà∑123\";\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getCustomer(unicodeId);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.customers WHERE id = 'cus_ÊµãËØïÁî®Êà∑123' LIMIT 1\",\n        });\n      });\n\n      it('should handle very long IDs', async () => {\n        const longId = 'cus_' + 'a'.repeat(1000);\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getCustomer(longId);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalled();\n      });\n\n      it('should handle empty strings gracefully', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'Invalid query' },\n        });\n\n        await expect(service.getCustomer('')).rejects.toThrow(InternalServerErrorException);\n      });\n\n      it('should handle null and undefined inputs', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'Invalid query' },\n        });\n\n        // @ts-ignore - Testing runtime behavior with invalid input\n        await expect(service.getCustomer(null)).rejects.toThrow(InternalServerErrorException);\n        \n        // @ts-ignore - Testing runtime behavior with invalid input\n        await expect(service.getCustomer(undefined)).rejects.toThrow(InternalServerErrorException);\n      });\n    });\n\n    describe('Boundary Value Testing', () => {\n      it('should handle limit of 0 for recent payments', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        const result = await service.getRecentPayments(0);\n\n        expect(result).toEqual([]);\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.payment_intents WHERE status = 'succeeded' ORDER BY created DESC LIMIT 0\",\n        });\n      });\n\n      it('should handle extremely large limits', async () => {\n        const hugeLimit = 1000000;\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getRecentPayments(hugeLimit);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: `SELECT * FROM stripe_fdw.payment_intents WHERE status = 'succeeded' ORDER BY created DESC LIMIT ${hugeLimit}`,\n        });\n      });\n\n      it('should handle negative limits', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n\n        await service.getRecentPayments(-1);\n\n        expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('execute_stripe_fdw_query', {\n          sql_query: \"SELECT * FROM stripe_fdw.payment_intents WHERE status = 'succeeded' ORDER BY created DESC LIMIT -1\",\n        });\n      });\n    });\n  });\n\n  describe('Network & Database Error Scenarios', () => {\n    describe('Timeout Handling', () => {\n      it('should handle connection timeouts', async () => {\n        const timeoutError = new Error('Connection timeout');\n        mockSupabaseClient.rpc.mockRejectedValueOnce(timeoutError);\n\n        await expect(service.getCustomer('cus_test123')).rejects.toThrow(InternalServerErrorException);\n        expect(logger.error).toHaveBeenCalledWith(\n          'Failed to fetch customer',\n          timeoutError\n        );\n      });\n\n      it('should handle query timeouts', async () => {\n        mockSupabaseClient.rpc.mockRejectedValueOnce(new Error('Query timeout'));\n\n        await expect(service.getProducts()).rejects.toThrow(InternalServerErrorException);\n      });\n    });\n\n    describe('Network Errors', () => {\n      it('should handle network connectivity issues', async () => {\n        const networkError = new Error('ENOTFOUND');\n        mockSupabaseClient.rpc.mockRejectedValueOnce(networkError);\n\n        const result = await service.testConnection();\n        expect(result).toBe(false);\n      });\n\n      it('should handle SSL/TLS errors', async () => {\n        const sslError = new Error('DEPTH_ZERO_SELF_SIGNED_CERT');\n        mockSupabaseClient.rpc.mockRejectedValueOnce(sslError);\n\n        await expect(service.getCharges()).rejects.toThrow(InternalServerErrorException);\n      });\n\n      it('should handle DNS resolution failures', async () => {\n        const dnsError = new Error('ENOTFOUND api.stripe.com');\n        mockSupabaseClient.rpc.mockRejectedValueOnce(dnsError);\n\n        const isHealthy = await service.isHealthy();\n        expect(isHealthy).toBe(false);\n      });\n    });\n\n    describe('Database Errors', () => {\n      it('should handle database connection pool exhaustion', async () => {\n        const poolError = new Error('remaining connection slots are reserved');\n        mockSupabaseClient.rpc.mockRejectedValueOnce(poolError);\n\n        await expect(service.getPrices()).rejects.toThrow(InternalServerErrorException);\n        expect(logger.error).toHaveBeenCalledWith('Failed to fetch prices', poolError);\n      });\n\n      it('should handle database query errors', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'syntax error at or near \"SELECT\"' },\n        });\n\n        await expect(service.getInvoice('in_test123')).rejects.toThrow(InternalServerErrorException);\n      });\n\n      it('should handle foreign table access denied', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'permission denied for foreign table stripe_fdw.customers' },\n        });\n\n        await expect(service.getCustomer('cus_test123')).rejects.toThrow(InternalServerErrorException);\n      });\n    });\n\n    describe('Stripe API Errors', () => {\n      it('should handle Stripe API rate limiting', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'Rate limit exceeded' },\n        });\n\n        await expect(service.getSubscription('sub_test123')).rejects.toThrow(InternalServerErrorException);\n      });\n\n      it('should handle Stripe API key errors', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'Invalid API key provided' },\n        });\n\n        const result = await service.testConnection();\n        expect(result).toBe(false);\n      });\n\n      it('should handle Stripe API maintenance', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: { message: 'The Stripe API is currently unavailable' },\n        });\n\n        await expect(service.getRecentPayments()).rejects.toThrow(InternalServerErrorException);\n      });\n    });\n  });\n\n  describe('Data Integrity & Edge Cases', () => {\n    describe('Malformed Response Handling', () => {\n      it('should handle null data responses', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: null,\n          error: null,\n        });\n\n        const result = await service.getCustomer('cus_test123');\n        expect(result).toBeNull();\n      });\n\n      it('should handle undefined data responses', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: undefined,\n          error: null,\n        });\n\n        const result = await service.getPrices();\n        expect(result).toEqual([]);\n      });\n\n      it('should handle non-array responses for list operations', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: { not: 'an array' },\n          error: null,\n        });\n\n        const result = await service.getProducts();\n        expect(result).toEqual({ not: 'an array' });\n      });\n\n      it('should handle empty array responses', async () => {\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: [],\n          error: null,\n        });\n\n        const result = await service.getCustomerSubscriptions('cus_test123');\n        expect(result).toEqual([]);\n      });\n    });\n\n    describe('Large Dataset Handling', () => {\n      it('should handle large result sets without memory issues', async () => {\n        const largeFakeDataset = Array(10000).fill({\n          id: 'prod_test',\n          name: 'Test Product',\n          active: true,\n        });\n\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: largeFakeDataset,\n          error: null,\n        });\n\n        const result = await service.getProducts();\n        expect(result).toHaveLength(10000);\n      });\n\n      it('should handle deeply nested objects in responses', async () => {\n        const deepObject = {\n          id: 'cus_test123',\n          metadata: {\n            level1: {\n              level2: {\n                level3: {\n                  level4: {\n                    level5: 'deep value',\n                  },\n                },\n              },\n            },\n          },\n        };\n\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: [deepObject],\n          error: null,\n        });\n\n        const result = await service.getCustomer('cus_test123');\n        expect(result).toEqual(deepObject);\n      });\n    });\n\n    describe('Concurrent Request Handling', () => {\n      it('should handle concurrent requests without race conditions', async () => {\n        // Mock different responses for concurrent calls\n        mockSupabaseClient.rpc\n          .mockResolvedValueOnce({ data: [{ id: 'prod_1' }], error: null })\n          .mockResolvedValueOnce({ data: [{ id: 'price_1' }], error: null })\n          .mockResolvedValueOnce({ data: [{ id: 'cus_1' }], error: null });\n\n        const promises = [\n          service.getProducts(),\n          service.getPrices(),\n          service.getCustomer('cus_test123'),\n        ];\n\n        const results = await Promise.all(promises);\n\n        expect(results[0]).toEqual([{ id: 'prod_1' }]);\n        expect(results[1]).toEqual([{ id: 'price_1' }]);\n        expect(results[2]).toEqual({ id: 'cus_1' });\n      });\n\n      it('should handle mixed success and failure in concurrent requests', async () => {\n        mockSupabaseClient.rpc\n          .mockResolvedValueOnce({ data: [{ id: 'prod_1' }], error: null })\n          .mockResolvedValueOnce({ data: null, error: { message: 'Error' } })\n          .mockResolvedValueOnce({ data: [{ id: 'cus_1' }], error: null });\n\n        const promises = [\n          service.getProducts(),\n          service.getPrices().catch(e => e),\n          service.getCustomer('cus_test123'),\n        ];\n\n        const results = await Promise.all(promises);\n\n        expect(results[0]).toEqual([{ id: 'prod_1' }]);\n        expect(results[1]).toBeInstanceOf(InternalServerErrorException);\n        expect(results[2]).toEqual({ id: 'cus_1' });\n      });\n    });\n  });\n\n  describe('Resource Management', () => {\n    describe('Memory Management', () => {\n      it('should not leak memory with repeated calls', async () => {\n        mockSupabaseClient.rpc.mockResolvedValue({ data: [], error: null });\n\n        // Simulate many repeated calls\n        const promises = Array(100).fill(null).map(() => service.testConnection());\n        await Promise.all(promises);\n\n        // If we get here without running out of memory, the test passes\n        expect(true).toBe(true);\n      });\n\n      it('should handle garbage collection friendly operations', async () => {\n        const largeObject = { data: Array(1000).fill('x'.repeat(1000)) };\n        mockSupabaseClient.rpc.mockResolvedValueOnce({\n          data: [largeObject],\n          error: null,\n        });\n\n        await service.getCustomer('cus_test123');\n\n        // Force garbage collection if available\n        if (global.gc) {\n          global.gc();\n        }\n\n        // Verify service still works after potential GC\n        mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n        const isHealthy = await service.isHealthy();\n        expect(isHealthy).toBe(true);\n      });\n    });\n\n    describe('Connection Management', () => {\n      it('should handle connection pool exhaustion gracefully', async () => {\n        // Simulate many concurrent connections\n        const manyPromises = Array(50).fill(null).map(() => {\n          mockSupabaseClient.rpc.mockResolvedValueOnce({ data: [], error: null });\n          return service.testConnection();\n        });\n\n        const results = await Promise.all(manyPromises);\n        expect(results.every(r => typeof r === 'boolean')).toBe(true);\n      });\n    });\n  });\n\n  describe('Service Lifecycle', () => {\n    describe('Initialization Edge Cases', () => {\n      it('should handle initialization with invalid config', async () => {\n        const moduleWithBadConfig: TestingModule = await Test.createTestingModule({\n          providers: [\n            StripeSyncService,\n            {\n              provide: ConfigService,\n              useValue: {\n                get: jest.fn(() => null), // All config returns null\n              },\n            },\n            {\n              provide: PinoLogger,\n              useValue: {\n                setContext: jest.fn(),\n                info: jest.fn(),\n                error: jest.fn(),\n              },\n            },\n          ],\n        }).compile();\n\n        // Service should still instantiate but may not function correctly\n        const badService = moduleWithBadConfig.get<StripeSyncService>(StripeSyncService);\n        expect(badService).toBeDefined();\n      });\n    });\n\n    describe('Graceful Degradation', () => {\n      it('should continue operating when non-critical operations fail', async () => {\n        // Health check fails but other operations might still work\n        mockSupabaseClient.rpc\n          .mockRejectedValueOnce(new Error('Health check failed'))\n          .mockResolvedValueOnce({ data: [{ id: 'prod_1' }], error: null });\n\n        const healthResult = await service.testConnection();\n        expect(healthResult).toBe(false);\n\n        // But other operations should still work\n        const products = await service.getProducts();\n        expect(products).toEqual([{ id: 'prod_1' }]);\n      });\n    });\n  });\n\n  // Webhook Edge Cases removed - processWebhook() method eliminated in simplification\n  // FDW provides real-time access, no webhook processing needed\n});","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-fdw.integration.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'configService' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":20,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing';\nimport { ConfigService } from '@nestjs/config';\nimport { PinoLogger } from 'nestjs-pino';\nimport { StripeSyncService } from './stripe-sync.service';\n\n/**\n * Integration tests for Stripe FDW functionality\n * \n * These tests verify the actual connection to Stripe via FDW\n * and require a valid Stripe account with test data.\n * \n * To run these tests, ensure you have:\n * 1. A working Supabase project with Stripe FDW configured\n * 2. Valid environment variables set\n * 3. At least some test data in your Stripe account\n */\ndescribe('StripeSyncService Integration Tests', () => {\n  let service: StripeSyncService;\n  let configService: ConfigService;\n\n  beforeAll(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => {\n              // Use actual environment variables for integration tests\n              return process.env[key];\n            }),\n          },\n        },\n        {\n          provide: PinoLogger,\n          useValue: {\n            setContext: jest.fn(),\n            info: jest.fn(),\n            error: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<StripeSyncService>(StripeSyncService);\n    configService = module.get<ConfigService>(ConfigService);\n  });\n\n  describe('Environment Setup', () => {\n    it('should have required environment variables', () => {\n      const requiredEnvVars = [\n        'SUPABASE_URL',\n        'SUPABASE_SERVICE_ROLE_KEY',\n        'STRIPE_SECRET_KEY',\n        'STRIPE_WEBHOOK_SECRET',\n      ];\n\n      requiredEnvVars.forEach(envVar => {\n        expect(process.env[envVar]).toBeDefined();\n        expect(process.env[envVar]).not.toBe('');\n      });\n    });\n\n    it('should initialize service successfully', () => {\n      expect(service).toBeDefined();\n      expect(service).toBeInstanceOf(StripeSyncService);\n    });\n  });\n\n  describe('Connection Tests', () => {\n    it('should successfully connect to Stripe FDW', async () => {\n      const isConnected = await service.testConnection();\n      expect(isConnected).toBe(true);\n    }, 30000); // 30 second timeout for network calls\n\n    it('should report healthy status', async () => {\n      const healthStatus = await service.getHealthStatus();\n      expect(healthStatus.status).toBe('healthy');\n      expect(healthStatus.realTime).toBe(true);\n    }, 30000);\n\n    it('should pass isHealthy check', async () => {\n      const isHealthy = await service.isHealthy();\n      expect(isHealthy).toBe(true);\n    }, 30000);\n  });\n\n  describe('Stripe Data Access', () => {\n    describe('Products', () => {\n      it('should fetch products from Stripe FDW', async () => {\n        const products = await service.getProducts();\n        expect(Array.isArray(products)).toBe(true);\n        \n        if (products.length > 0) {\n          const product = products[0];\n          expect(product).toHaveProperty('id');\n          expect(product).toHaveProperty('name');\n          expect(product).toHaveProperty('active');\n          expect(typeof product.id).toBe('string');\n          expect(product.id).toMatch(/^prod_/);\n        }\n      }, 30000);\n    });\n\n    describe('Prices', () => {\n      it('should fetch prices from Stripe FDW', async () => {\n        const prices = await service.getPrices();\n        expect(Array.isArray(prices)).toBe(true);\n        \n        if (prices.length > 0) {\n          const price = prices[0];\n          expect(price).toHaveProperty('id');\n          expect(price).toHaveProperty('product');\n          expect(price).toHaveProperty('active');\n          expect(typeof price.id).toBe('string');\n          expect(price.id).toMatch(/^price_/);\n        }\n      }, 30000);\n\n      it('should fetch prices for specific product', async () => {\n        const allPrices = await service.getPrices();\n        \n        if (allPrices.length > 0) {\n          const productId = allPrices[0].product;\n          const productPrices = await service.getPrices(productId);\n          \n          expect(Array.isArray(productPrices)).toBe(true);\n          productPrices.forEach(price => {\n            expect(price.product).toBe(productId);\n          });\n        }\n      }, 30000);\n    });\n\n    describe('Customers', () => {\n      it('should handle customer lookup', async () => {\n        // Test with a non-existent customer ID\n        const nonExistentCustomer = await service.getCustomer('cus_nonexistent123');\n        expect(nonExistentCustomer).toBeNull();\n      }, 30000);\n\n      it('should fetch real customer if exists', async () => {\n        // This test will pass if there are customers, otherwise skip\n        try {\n          const products = await service.getProducts();\n          if (products.length > 0) {\n            // Try to find a real customer by checking if any exist\n            // We can't predict customer IDs, so this test is more of a smoke test\n            expect(true).toBe(true); // Passes if no error thrown\n          }\n        } catch (error) {\n          // If there's an error, it should be a specific type we expect\n          expect(error.message).toContain('Failed to fetch');\n        }\n      }, 30000);\n    });\n\n    describe('Payment Intents', () => {\n      it('should handle payment intent lookup', async () => {\n        // Test with a non-existent payment intent ID\n        const nonExistentPI = await service.getPaymentIntent('pi_nonexistent123');\n        expect(nonExistentPI).toBeNull();\n      }, 30000);\n\n      it('should fetch recent payments', async () => {\n        const recentPayments = await service.getRecentPayments(5);\n        expect(Array.isArray(recentPayments)).toBe(true);\n        \n        if (recentPayments.length > 0) {\n          const payment = recentPayments[0];\n          expect(payment).toHaveProperty('id');\n          expect(payment).toHaveProperty('status');\n          expect(typeof payment.id).toBe('string');\n          expect(payment.id).toMatch(/^pi_/);\n          expect(payment.status).toBe('succeeded');\n        }\n      }, 30000);\n    });\n\n    describe('Subscriptions', () => {\n      it('should handle subscription lookup', async () => {\n        // Test with a non-existent subscription ID\n        const nonExistentSub = await service.getSubscription('sub_nonexistent123');\n        expect(nonExistentSub).toBeNull();\n      }, 30000);\n\n      it('should handle customer subscriptions lookup', async () => {\n        // Test with a non-existent customer ID\n        const customerSubs = await service.getCustomerSubscriptions('cus_nonexistent123');\n        expect(Array.isArray(customerSubs)).toBe(true);\n        expect(customerSubs).toHaveLength(0);\n      }, 30000);\n    });\n\n    describe('Invoices', () => {\n      it('should handle invoice lookup', async () => {\n        // Test with a non-existent invoice ID\n        const nonExistentInvoice = await service.getInvoice('in_nonexistent123');\n        expect(nonExistentInvoice).toBeNull();\n      }, 30000);\n    });\n\n    describe('Charges', () => {\n      it('should fetch charges', async () => {\n        const charges = await service.getCharges(undefined, 5);\n        expect(Array.isArray(charges)).toBe(true);\n        \n        if (charges.length > 0) {\n          const charge = charges[0];\n          expect(charge).toHaveProperty('id');\n          expect(typeof charge.id).toBe('string');\n          expect(charge.id).toMatch(/^ch_/);\n        }\n      }, 30000);\n\n      it('should fetch charges for specific customer', async () => {\n        // Test with a non-existent customer ID\n        const customerCharges = await service.getCharges('cus_nonexistent123', 5);\n        expect(Array.isArray(customerCharges)).toBe(true);\n        expect(customerCharges).toHaveLength(0);\n      }, 30000);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle invalid queries gracefully', async () => {\n      // These tests verify that our error handling works correctly\n      await expect(service.getCustomer('')).rejects.toThrow('Failed to fetch customer data');\n      await expect(service.getSubscription('')).rejects.toThrow('Failed to fetch subscription data');\n      await expect(service.getPaymentIntent('')).rejects.toThrow('Failed to fetch payment intent data');\n      await expect(service.getInvoice('')).rejects.toThrow('Failed to fetch invoice data');\n    }, 30000);\n  });\n\n  describe('Performance Tests', () => {\n    it('should respond to health checks quickly', async () => {\n      const startTime = Date.now();\n      await service.testConnection();\n      const endTime = Date.now();\n      \n      const responseTime = endTime - startTime;\n      expect(responseTime).toBeLessThan(5000); // Should respond within 5 seconds\n    }, 30000);\n\n    it('should handle concurrent requests', async () => {\n      const promises = [\n        service.getProducts(),\n        service.getPrices(),\n        service.getCharges(undefined, 1),\n        service.testConnection(),\n      ];\n\n      const startTime = Date.now();\n      const results = await Promise.all(promises);\n      const endTime = Date.now();\n\n      expect(results).toHaveLength(4);\n      const totalTime = endTime - startTime;\n      expect(totalTime).toBeLessThan(10000); // Should complete within 10 seconds\n    }, 45000);\n\n    it('should limit query results appropriately', async () => {\n      const smallLimit = await service.getRecentPayments(2);\n      const largeLimit = await service.getRecentPayments(10);\n      \n      expect(smallLimit.length).toBeLessThanOrEqual(2);\n      expect(largeLimit.length).toBeLessThanOrEqual(10);\n      \n      if (smallLimit.length > 0 && largeLimit.length > smallLimit.length) {\n        expect(largeLimit.length).toBeGreaterThan(smallLimit.length);\n      }\n    }, 30000);\n  });\n\n  describe('Data Consistency', () => {\n    it('should return consistent data across multiple calls', async () => {\n      const [products1, products2] = await Promise.all([\n        service.getProducts(),\n        service.getProducts(),\n      ]);\n\n      // Results should be identical (assuming no changes in Stripe between calls)\n      expect(products1).toEqual(products2);\n    }, 30000);\n\n    it('should maintain data relationships', async () => {\n      const prices = await service.getPrices();\n      \n      if (prices.length > 0) {\n        const priceWithProduct = prices.find(p => p.product);\n        if (priceWithProduct) {\n          const products = await service.getProducts();\n          const relatedProduct = products.find(p => p.id === priceWithProduct.product);\n          \n          // If we found a price with a product reference, that product should exist\n          expect(relatedProduct).toBeDefined();\n        }\n      }\n    }, 45000);\n  });\n\n  describe('Webhook Compatibility', () => {\n    it('should handle webhook processing gracefully', async () => {\n      const webhookBody = JSON.stringify({\n        id: 'evt_test_webhook',\n        object: 'event',\n        type: 'customer.created',\n        data: {\n          object: {\n            id: 'cus_test123',\n            object: 'customer',\n          },\n        },\n      });\n\n      // Should not throw any errors\n      await expect(\n        service.processWebhook(webhookBody, 'test_signature')\n      ).resolves.not.toThrow();\n    });\n\n    it('should handle full sync requests gracefully', async () => {\n      // Should not throw any errors\n      await expect(service.performFullSync()).resolves.not.toThrow();\n    });\n  });\n});\n\n/**\n * Smoke Tests - Quick validation that basic functionality works\n * These run faster and can be used for CI/CD pipelines\n */\ndescribe('Stripe FDW Smoke Tests', () => {\n  let service: StripeSyncService;\n\n  beforeAll(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => process.env[key]),\n          },\n        },\n        {\n          provide: PinoLogger,\n          useValue: {\n            setContext: jest.fn(),\n            info: jest.fn(),\n            error: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<StripeSyncService>(StripeSyncService);\n  });\n\n  it('should instantiate service', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should have environment variables set', () => {\n    expect(process.env.SUPABASE_URL).toBeDefined();\n    expect(process.env.SUPABASE_SERVICE_ROLE_KEY).toBeDefined();\n  });\n\n  it('should connect to FDW', async () => {\n    const canConnect = await service.testConnection();\n    expect(typeof canConnect).toBe('boolean');\n  }, 15000);\n\n  it('should get health status', async () => {\n    const health = await service.getHealthStatus();\n    expect(health).toHaveProperty('status');\n    expect(health).toHaveProperty('realTime');\n  }, 15000);\n});","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-sync.integration.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'configService' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3856,3859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3856,3859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createExecSqlFunction' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":254,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":254,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createStripeSchemaCheckFunction' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":266,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":266,"endColumn":38}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing'\nimport { ConfigService } from '@nestjs/config'\nimport { PinoLogger } from 'nestjs-pino'\nimport { StripeSyncService } from './stripe-sync.service'\nimport { SupabaseService } from '../database/supabase.service'\n\n/**\n * Production-Ready Stripe Sync Integration Tests\n * \n * These tests verify that the Stripe Sync Engine functions correctly\n * in a production environment with real database connections.\n * \n * Prerequisites:\n * - DATABASE_URL configured and accessible\n * - STRIPE_SECRET_KEY configured with test keys\n * - Supabase database permissions for stripe schema\n * \n * Run with: npm run test:integration\n */\ndescribe('StripeSyncService Integration Tests', () => {\n  let service: StripeSyncService\n  let supabaseService: SupabaseService\n  let configService: ConfigService\n  \n  // Skip integration tests if environment not configured\n  const isConfigured = () => {\n    const required = ['DATABASE_URL', 'STRIPE_SECRET_KEY']\n    return required.every(key => process.env[key])\n  }\n\n  beforeAll(async () => {\n    if (!isConfigured()) {\n      console.log('‚è≠Ô∏è  Skipping Stripe Sync integration tests - environment not configured')\n      return\n    }\n\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        SupabaseService,\n        ConfigService,\n        {\n          provide: PinoLogger,\n          useValue: {\n            info: jest.fn(),\n            error: jest.fn(),\n            warn: jest.fn(),\n            setContext: jest.fn()\n          }\n        }\n      ]\n    }).compile()\n\n    service = module.get<StripeSyncService>(StripeSyncService)\n    supabaseService = module.get<SupabaseService>(SupabaseService)\n    configService = module.get<ConfigService>(ConfigService)\n  })\n\n  describe('Environment Setup', () => {\n    it('should have required environment variables', () => {\n      if (!isConfigured()) return\n\n      expect(process.env.DATABASE_URL).toBeDefined()\n      expect(process.env.STRIPE_SECRET_KEY).toBeDefined()\n    })\n\n    it('should initialize service successfully', () => {\n      if (!isConfigured()) return\n\n      expect(service).toBeDefined()\n      expect(service.getHealthStatus()).toEqual({\n        initialized: true,\n        migrationsRun: true\n      })\n    })\n  })\n\n  describe('Database Schema Validation', () => {\n    it('should have created stripe schema', async () => {\n      if (!isConfigured()) return\n\n      const client = supabaseService.getAdminClient()\n      const { data, error } = await client.rpc('check_stripe_schema_exists')\n      \n      if (error) {\n        // Fallback: query information_schema directly\n        const { data: schemaData, error: schemaError } = await client\n          .rpc('exec_sql', { \n            query: \"SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'stripe'\" \n          })\n        \n        expect(schemaError).toBeNull()\n        expect(schemaData).toBeTruthy()\n      } else {\n        expect(data).toBe(true)\n      }\n    })\n\n    it('should have core stripe tables created', async () => {\n      if (!isConfigured()) return\n\n      const client = supabaseService.getAdminClient()\n      const coreTableQuery = `\n        SELECT table_name \n        FROM information_schema.tables \n        WHERE table_schema = 'stripe' \n        AND table_name IN ('customers', 'subscriptions', 'invoices', 'prices', 'products')\n        ORDER BY table_name\n      `\n      \n      const { data, error } = await client.rpc('exec_sql', { query: coreTableQuery })\n      \n      expect(error).toBeNull()\n      expect(data).toBeTruthy()\n      // Should have at least the core tables\n      const expectedTables = ['customers', 'invoices', 'prices', 'products', 'subscriptions']\n      expectedTables.forEach(table => {\n        expect(data.some((row: any) => row.table_name === table)).toBe(true)\n      })\n    })\n\n    it('should have significant number of stripe tables', async () => {\n      if (!isConfigured()) return\n\n      const client = supabaseService.getAdminClient()\n      const tableCountQuery = `\n        SELECT COUNT(*) as table_count \n        FROM information_schema.tables \n        WHERE table_schema = 'stripe'\n      `\n      \n      const { data, error } = await client.rpc('exec_sql', { query: tableCountQuery })\n      \n      expect(error).toBeNull()\n      expect(data).toBeTruthy()\n      expect(data[0]?.table_count).toBeGreaterThan(50) // Should have 90+ tables\n    })\n  })\n\n  describe('Sync Engine Functionality', () => {\n    it('should process webhook without errors', async () => {\n      if (!isConfigured()) return\n\n      // Mock webhook payload - customer.created event\n      const mockPayload = Buffer.from(JSON.stringify({\n        id: 'evt_test_123',\n        object: 'event',\n        type: 'customer.created',\n        data: {\n          object: {\n            id: 'cus_test_123',\n            email: 'test@example.com',\n            name: 'Test Customer'\n          }\n        }\n      }))\n      \n      // Mock signature (in real test this would be properly signed)\n      const mockSignature = 'test_signature'\n\n      // This should not throw an error (signature verification might fail but sync engine should handle it)\n      await expect(service.processWebhook(mockPayload, mockSignature))\n        .resolves.not.toThrow()\n    })\n\n    it('should return health status correctly', () => {\n      if (!isConfigured()) return\n\n      const health = service.getHealthStatus()\n      expect(health).toEqual({\n        initialized: true,\n        migrationsRun: true\n      })\n      expect(service.testConnection()).toBe(true)\n    })\n\n    it('should have backfill functionality available', async () => {\n      if (!isConfigured()) return\n\n      // Test that backfill method exists and doesn't immediately throw\n      expect(service.backfillData).toBeDefined()\n      expect(typeof service.backfillData).toBe('function')\n    })\n  })\n\n  describe('Data Integrity Checks', () => {\n    it('should be able to query stripe tables directly', async () => {\n      if (!isConfigured()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Test querying customers table (should exist even if empty)\n      const { error } = await client\n        .from('stripe.customers')\n        .select('id')\n        .limit(1)\n      \n      // Should not error even if no data\n      expect(error).toBeNull()\n    })\n\n    it('should have proper table permissions', async () => {\n      if (!isConfigured()) return\n\n      const client = supabaseService.getAdminClient()\n      \n      // Test that we can read from key tables\n      const tables = ['customers', 'subscriptions', 'invoices', 'products', 'prices']\n      \n      for (const table of tables) {\n        const { error } = await client\n          .from(`stripe.${table}`)\n          .select('*')\n          .limit(1)\n        \n        expect(error).toBeNull()\n      }\n    })\n  })\n\n  describe('Production Readiness', () => {\n    it('should handle connection failures gracefully', () => {\n      if (!isConfigured()) return\n\n      // Service should be initialized even without testing actual connection\n      expect(service.getHealthStatus().initialized).toBe(true)\n    })\n\n    it('should have proper logging context', () => {\n      if (!isConfigured()) return\n\n      expect(service).toBeDefined()\n      // Service should initialize without throwing\n    })\n\n    it('should validate environment configuration', () => {\n      if (!isConfigured()) return\n\n      const requiredVars = ['DATABASE_URL', 'STRIPE_SECRET_KEY']\n      requiredVars.forEach(varName => {\n        expect(process.env[varName]).toBeDefined()\n        expect(typeof process.env[varName]).toBe('string')\n        expect(process.env[varName]!.length).toBeGreaterThan(0)\n      })\n    })\n  })\n})\n\n/**\n * Helper function to create Supabase RPC for SQL execution\n * This would typically be added to your database setup\n */\nconst createExecSqlFunction = `\nCREATE OR REPLACE FUNCTION exec_sql(query text)\nRETURNS TABLE(result json)\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nBEGIN\n  RETURN QUERY EXECUTE 'SELECT to_jsonb(t) FROM (' || query || ') t';\nEND;\n$$;\n`\n\nconst createStripeSchemaCheckFunction = `\nCREATE OR REPLACE FUNCTION check_stripe_schema_exists()\nRETURNS boolean\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM information_schema.schemata \n    WHERE schema_name = 'stripe'\n  );\nEND;\n$$;\n`","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-sync.service.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1021,1024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1021,1024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing'\nimport { ConfigService } from '@nestjs/config'\nimport { PinoLogger } from 'nestjs-pino'\n\n// Mock the entire module\njest.mock('@supabase/stripe-sync-engine')\n\nimport { StripeSyncService } from './stripe-sync.service'\nimport { StripeSync, runMigrations } from '@supabase/stripe-sync-engine'\n\n// Cast the mocked functions\nconst mockStripeSync = StripeSync as jest.MockedClass<typeof StripeSync>\nconst mockRunMigrations = runMigrations as jest.MockedFunction<typeof runMigrations>\n\ndescribe('StripeSyncService', () => {\n  let service: StripeSyncService\n  let configService: ConfigService\n  let logger: PinoLogger\n\n  const mockStripeSyncInstance = {\n    processWebhook: jest.fn(),\n    syncSingleEntity: jest.fn(),\n    syncBackfill: jest.fn(),\n  }\n\n  beforeEach(async () => {\n    jest.clearAllMocks()\n\n    // Setup the mock constructor to return our mock instance\n    mockStripeSync.mockImplementation(() => mockStripeSyncInstance as any)\n\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeSyncService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: jest.fn((key: string) => {\n              switch (key) {\n                case 'DATABASE_URL':\n                  return 'postgresql://test:test@localhost:5432/test'\n                case 'STRIPE_SECRET_KEY':\n                  return 'sk_test_123'\n                case 'STRIPE_WEBHOOK_SECRET':\n                  return 'whsec_123'\n                case 'STRIPE_SYNC_DATABASE_SCHEMA':\n                  return 'stripe'\n                case 'STRIPE_SYNC_AUTO_EXPAND_LISTS':\n                  return true\n                default:\n                  return undefined\n              }\n            }),\n          },\n        },\n        {\n          provide: PinoLogger,\n          useValue: {\n            setContext: jest.fn(),\n            info: jest.fn(),\n            error: jest.fn(),\n            warn: jest.fn(),\n          },\n        },\n      ],\n    }).compile()\n\n    service = module.get<StripeSyncService>(StripeSyncService)\n    configService = module.get<ConfigService>(ConfigService)\n    logger = module.get<PinoLogger>(PinoLogger)\n  })\n\n  describe('Initialization', () => {\n    it('should be defined', () => {\n      expect(service).toBeDefined()\n    })\n\n    it('should set logger context', () => {\n      expect(logger.setContext).toHaveBeenCalledWith('StripeSyncService')\n    })\n\n    it('should create StripeSync instance', () => {\n      expect(mockStripeSync).toHaveBeenCalledWith({\n        databaseUrl: 'postgresql://test:test@localhost:5432/test',\n        stripeSecretKey: 'sk_test_123',\n        stripeWebhookSecret: 'whsec_123',\n        schema: 'stripe',\n        autoExpandLists: true,\n      })\n    })\n\n    it('should log initialization', () => {\n      expect(logger.info).toHaveBeenCalledWith('Stripe Sync Engine initialized', {\n        schema: 'stripe',\n        autoExpandLists: true,\n      })\n    })\n  })\n\n  describe('onModuleInit', () => {\n    it('should run migrations successfully', async () => {\n      mockRunMigrations.mockResolvedValue(undefined)\n\n      await service.onModuleInit()\n\n      expect(mockRunMigrations).toHaveBeenCalledWith({\n        databaseUrl: 'postgresql://test:test@localhost:5432/test',\n        schema: 'stripe'\n      })\n      expect(logger.info).toHaveBeenCalledWith('Running Stripe Sync Engine migrations...')\n      expect(logger.info).toHaveBeenCalledWith('Stripe Sync Engine migrations completed successfully')\n    })\n\n    it('should handle migration errors', async () => {\n      const error = new Error('Migration failed')\n      mockRunMigrations.mockRejectedValue(error)\n\n      await expect(service.onModuleInit()).rejects.toThrow('Migration failed')\n      expect(logger.error).toHaveBeenCalledWith('Stripe Sync Engine migration failed:', error)\n    })\n  })\n\n  describe('processWebhook', () => {\n    it('should process webhook successfully', async () => {\n      const rawBody = Buffer.from('test-payload')\n      const signature = 'test-signature'\n      \n      mockStripeSyncInstance.processWebhook.mockResolvedValue(undefined)\n\n      await service.processWebhook(rawBody, signature)\n\n      expect(mockStripeSyncInstance.processWebhook).toHaveBeenCalledWith(rawBody, signature)\n    })\n\n    it('should handle webhook processing errors', async () => {\n      const error = new Error('Webhook processing failed')\n      mockStripeSyncInstance.processWebhook.mockRejectedValue(error)\n\n      await expect(service.processWebhook(Buffer.from('test'), 'sig')).rejects.toThrow('Webhook processing failed')\n    })\n  })\n\n  describe('syncSingleEntity', () => {\n    it('should sync single entity successfully', async () => {\n      const entityId = 'cus_test123'\n      const mockResult = [{ id: entityId }]\n      mockStripeSyncInstance.syncSingleEntity.mockResolvedValue(mockResult)\n\n      const result = await service.syncSingleEntity(entityId)\n\n      expect(mockStripeSyncInstance.syncSingleEntity).toHaveBeenCalledWith(entityId)\n      expect(logger.info).toHaveBeenCalledWith('Syncing single Stripe entity:', { entityId })\n      expect(result).toEqual(mockResult)\n    })\n  })\n\n  describe('backfillData', () => {\n    it('should backfill data successfully', async () => {\n      const mockResult = { success: true }\n      mockStripeSyncInstance.syncBackfill.mockResolvedValue(mockResult)\n\n      const result = await service.backfillData()\n\n      expect(mockStripeSyncInstance.syncBackfill).toHaveBeenCalledTimes(1)\n      expect(logger.info).toHaveBeenCalledWith('Starting Stripe data backfill...')\n      expect(logger.info).toHaveBeenCalledWith(\n        'Stripe data backfill completed successfully',\n        expect.objectContaining({ duration: expect.stringMatching(/\\d+\\.\\d+s/) })\n      )\n      expect(result).toEqual(mockResult)\n    })\n\n    it('should handle backfill errors', async () => {\n      const error = new Error('Backfill failed')\n      mockStripeSyncInstance.syncBackfill.mockRejectedValue(error)\n\n      await expect(service.backfillData()).rejects.toThrow('Backfill failed')\n      expect(logger.error).toHaveBeenCalledWith('Stripe data backfill failed:', error)\n    })\n  })\n\n  describe('getHealthStatus', () => {\n    it('should return health status', () => {\n      const health = service.getHealthStatus()\n      expect(health).toEqual({\n        initialized: true,\n        migrationsRun: false, // Before onModuleInit is called\n      })\n    })\n\n    it('should return correct status after migrations', async () => {\n      mockRunMigrations.mockResolvedValue(undefined)\n      await service.onModuleInit()\n\n      const health = service.getHealthStatus()\n      expect(health).toEqual({\n        initialized: true,\n        migrationsRun: true,\n      })\n    })\n  })\n\n  describe('testConnection', () => {\n    it('should return true when healthy', async () => {\n      mockRunMigrations.mockResolvedValue(undefined)\n      await service.onModuleInit()\n\n      const result = await service.testConnection()\n      expect(result).toBe(true)\n    })\n\n    it('should return false when not initialized', async () => {\n      const result = await service.testConnection()\n      expect(result).toBe(false)\n    })\n  })\n\n  describe('isHealthy', () => {\n    it('should return health check result', async () => {\n      mockRunMigrations.mockResolvedValue(undefined)\n      await service.onModuleInit()\n\n      const result = await service.isHealthy()\n      expect(result).toBe(true)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should throw error when required config is missing', () => {\n      jest.spyOn(configService, 'get').mockImplementation((key: string) => {\n        if (key === 'DATABASE_URL') return undefined\n        return 'test-value'\n      })\n\n      expect(() => {\n        new StripeSyncService(configService, logger)\n      }).toThrow('Missing required configuration for Stripe Sync Engine')\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-sync.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":43,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":43,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":44,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":44,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":52,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":52,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":56,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":56,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2864,2867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2864,2867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, OnModuleInit, Optional } from '@nestjs/common'\nimport { ConfigService } from '@nestjs/config'\nimport { StripeSync, runMigrations } from '@supabase/stripe-sync-engine'\nimport { PinoLogger } from 'nestjs-pino'\nimport type { EnvironmentVariables } from '../config/config.schema'\n\n/**\n * Ultra-Native Stripe Sync Service\n * \n * Direct integration with @supabase/stripe-sync-engine\n * No abstractions, wrappers, or custom middleware\n * Follows official Supabase recommendations from Sub-Plan 1\n */\n@Injectable()\nexport class StripeSyncService implements OnModuleInit {\n  private stripeSync: StripeSync\n  private migrationsRun = false\n\n  constructor(\n    private readonly configService: ConfigService<EnvironmentVariables>,\n    @Optional() private readonly logger?: PinoLogger\n  ) {\n    this.logger?.setContext(StripeSyncService.name)\n    \n    // Ultra-native: Direct instantiation following official docs\n    const databaseUrl = this.configService.get('DATABASE_URL', { infer: true })\n    const stripeSecretKey = this.configService.get('STRIPE_SECRET_KEY', { infer: true })\n    const stripeWebhookSecret = this.configService.get('STRIPE_WEBHOOK_SECRET', { infer: true })\n\n    if (!databaseUrl || !stripeSecretKey) {\n      throw new Error('Missing required configuration for Stripe Sync Engine')\n    }\n\n    this.stripeSync = new StripeSync({\n      databaseUrl,\n      stripeSecretKey,\n      stripeWebhookSecret: stripeWebhookSecret || '',\n      schema: this.configService.get('STRIPE_SYNC_DATABASE_SCHEMA') ?? 'stripe',\n      autoExpandLists: this.configService.get('STRIPE_SYNC_AUTO_EXPAND_LISTS') ?? true\n    })\n\n    this.logger?.info('Stripe Sync Engine initialized', {\n      schema: this.configService.get('STRIPE_SYNC_DATABASE_SCHEMA') ?? 'stripe',\n      autoExpandLists: this.configService.get('STRIPE_SYNC_AUTO_EXPAND_LISTS') ?? true\n    })\n  }\n\n  async onModuleInit() {\n    try {\n      this.logger?.info('Running Stripe Sync Engine migrations...')\n      const databaseUrl = this.configService.get('DATABASE_URL', { infer: true })!\n      const schema = this.configService.get('STRIPE_SYNC_DATABASE_SCHEMA') ?? 'stripe'\n      \n      await runMigrations({\n        databaseUrl,\n        schema\n      })\n      \n      this.migrationsRun = true\n      this.logger?.info('Stripe Sync Engine migrations completed successfully')\n    } catch (error) {\n      this.logger?.error('Stripe Sync Engine migration failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Process Stripe webhook (called by webhook controller)\n   * Direct method exposure - no abstractions\n   */\n  async processWebhook(rawBody: Buffer, signature: string): Promise<void> {\n    return this.stripeSync.processWebhook(rawBody, signature)\n  }\n\n  /**\n   * Sync a single Stripe entity by ID\n   * Useful for manual sync or testing\n   */\n  async syncSingleEntity(entityId: string): Promise<any> {\n    this.logger?.info('Syncing single Stripe entity:', { entityId })\n    return this.stripeSync.syncSingleEntity(entityId)\n  }\n\n  /**\n   * Backfill all historical Stripe data\n   * Run once during initial setup\n   */\n  async backfillData(): Promise<{ success: boolean }> {\n    this.logger?.info('Starting Stripe data backfill...')\n    const startTime = Date.now()\n    \n    try {\n      await this.stripeSync.syncBackfill()\n      const duration = ((Date.now() - startTime) / 1000).toFixed(2)\n      this.logger?.info('Stripe data backfill completed successfully', { \n        duration: `${duration}s` \n      })\n      return { success: true }\n    } catch (error) {\n      this.logger?.error('Stripe data backfill failed:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Get sync engine health status\n   */\n  getHealthStatus(): { initialized: boolean; migrationsRun: boolean } {\n    return {\n      initialized: !!this.stripeSync,\n      migrationsRun: this.migrationsRun\n    }\n  }\n\n  /**\n   * Test connection - for health checks\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      return this.getHealthStatus().initialized && this.getHealthStatus().migrationsRun\n    } catch (error) {\n      this.logger?.error('Health check failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Check if service is healthy\n   */\n  async isHealthy(): Promise<boolean> {\n    return this.testConnection()\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-webhook-simple.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[648,651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[648,651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[737,740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[737,740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1791,1794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1791,1794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2682,2685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2682,2685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3232,3235],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3232,3235],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3851,3854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3851,3854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4530,4533],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4530,4533],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing';\nimport { EventEmitter2 } from '@nestjs/event-emitter';\nimport Stripe from 'stripe';\nimport { StripeWebhookService } from './stripe-webhook.service';\n\ndescribe('StripeWebhookService (Simplified)', () => {\n  let service: StripeWebhookService;\n  let mockStripe: jest.Mocked<Stripe>;\n  let mockEventEmitter: jest.Mocked<EventEmitter2>;\n\n  const mockWebhookSecret = 'whsec_test_secret';\n  const originalEnv = process.env;\n\n  beforeEach(async () => {\n    // Mock Stripe\n    mockStripe = {\n      webhooks: {\n        constructEvent: jest.fn(),\n      },\n    } as any;\n\n    // Mock EventEmitter2\n    mockEventEmitter = {\n      emit: jest.fn(),\n    } as any;\n\n    // Set environment variable\n    process.env = {\n      ...originalEnv,\n      STRIPE_WEBHOOK_SECRET: mockWebhookSecret,\n    };\n\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        StripeWebhookService,\n        { provide: Stripe, useValue: mockStripe },\n        { provide: EventEmitter2, useValue: mockEventEmitter },\n      ],\n    }).compile();\n\n    service = module.get<StripeWebhookService>(StripeWebhookService);\n  });\n\n  afterEach(() => {\n    process.env = originalEnv;\n    jest.clearAllMocks();\n  });\n\n  describe('processWebhook', () => {\n    const mockPayload = Buffer.from('test payload');\n    const mockSignature = 'test-signature';\n\n    it('should process subscription created event', async () => {\n      const mockEvent: Stripe.Event = {\n        id: 'evt_test',\n        type: 'customer.subscription.created',\n        data: {\n          object: {\n            id: 'sub_test',\n            customer: 'cus_test',\n            status: 'active',\n          } as Stripe.Subscription,\n        },\n      } as any;\n\n      mockStripe.webhooks.constructEvent.mockReturnValue(mockEvent);\n\n      await service.processWebhook(mockPayload, mockSignature);\n\n      expect(mockStripe.webhooks.constructEvent).toHaveBeenCalledWith(\n        mockPayload,\n        mockSignature,\n        mockWebhookSecret,\n      );\n      expect(mockEventEmitter.emit).toHaveBeenCalledWith('subscription.changed', {\n        customerId: 'cus_test',\n        subscriptionId: 'sub_test',\n        status: 'active',\n        eventType: 'customer.subscription.created',\n      });\n    });\n\n    it('should process payment succeeded event', async () => {\n      const mockEvent: Stripe.Event = {\n        id: 'evt_test',\n        type: 'invoice.payment_succeeded',\n        data: {\n          object: {\n            id: 'in_test',\n            customer: 'cus_test',\n            amount_paid: 2000,\n          } as Stripe.Invoice,\n        },\n      } as any;\n\n      mockStripe.webhooks.constructEvent.mockReturnValue(mockEvent);\n\n      await service.processWebhook(mockPayload, mockSignature);\n\n      expect(mockEventEmitter.emit).toHaveBeenCalledWith('payment.processed', {\n        customerId: 'cus_test',\n        amount: 2000,\n        status: 'success',\n        invoiceId: 'in_test',\n      });\n    });\n\n    it('should ignore unhandled event types', async () => {\n      const mockEvent: Stripe.Event = {\n        id: 'evt_test',\n        type: 'customer.created',\n        data: { object: {} },\n      } as any;\n\n      mockStripe.webhooks.constructEvent.mockReturnValue(mockEvent);\n\n      await service.processWebhook(mockPayload, mockSignature);\n\n      expect(mockEventEmitter.emit).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('handleWebhook', () => {\n    it('should process subscription events directly', async () => {\n      const mockEvent: Stripe.Event = {\n        id: 'evt_test',\n        type: 'customer.subscription.updated',\n        data: {\n          object: {\n            id: 'sub_test',\n            customer: 'cus_test',\n            status: 'canceled',\n          } as Stripe.Subscription,\n        },\n      } as any;\n\n      await service.handleWebhook(mockEvent);\n\n      expect(mockEventEmitter.emit).toHaveBeenCalledWith('subscription.changed', {\n        customerId: 'cus_test',\n        subscriptionId: 'sub_test',\n        status: 'canceled',\n        eventType: 'customer.subscription.updated',\n      });\n    });\n\n    it('should handle event processing errors gracefully', async () => {\n      const mockEvent: Stripe.Event = {\n        id: 'evt_error_test',\n        type: 'customer.subscription.created',\n        data: {\n          object: {\n            id: 'sub_test',\n            customer: 'cus_test',\n            status: 'active',\n          } as Stripe.Subscription,\n        },\n      } as any;\n\n      // Make EventEmitter throw an error\n      mockEventEmitter.emit.mockImplementation(() => {\n        throw new Error('EventEmitter failed');\n      });\n\n      // Should not throw - error handling prevents webhook HTTP failure\n      await expect(service.handleWebhook(mockEvent)).resolves.not.toThrow();\n      \n      expect(mockEventEmitter.emit).toHaveBeenCalled();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe-webhook.service.old.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe.controller.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'supabaseService' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5223,5226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5223,5226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":191,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6141,6144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6141,6144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6442,6445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6442,6445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12678,12681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12678,12681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":436,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":436,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13731,13734],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13731,13734],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":446,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14061,14064],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14061,14064],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":479,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":479,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15091,15094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15091,15094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16505,16508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16505,16508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":539,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":539,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16771,16774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16771,16774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":575,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":575,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18086,18089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18086,18089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestingModule } from '@nestjs/testing';\nimport { Test } from '@nestjs/testing';\nimport { BadRequestException, InternalServerErrorException, NotFoundException } from '@nestjs/common';\nimport { PinoLogger } from 'nestjs-pino';\nimport { StripeController } from './stripe.controller';\nimport { StripeService } from './stripe.service';\nimport { StripeWebhookService } from './stripe-webhook.service';\nimport { StripePortalService } from './stripe-portal.service';\nimport { SupabaseService } from '../database/supabase.service';\nimport type { AuthUser } from '@repo/shared/types/auth';\nimport type { Stripe } from 'stripe';\n\n// Mock Supabase client\nconst mockSupabaseClient = {\n  from: jest.fn().mockReturnThis(),\n  select: jest.fn().mockReturnThis(),\n  update: jest.fn().mockReturnThis(),\n  eq: jest.fn().mockReturnThis(),\n  single: jest.fn().mockReturnThis(),\n  order: jest.fn().mockReturnThis(),\n  limit: jest.fn().mockReturnThis(),\n  maybeSingle: jest.fn(),\n};\n\ndescribe('StripeController', () => {\n  let controller: StripeController;\n  let stripeService: StripeService;\n  let stripeWebhookService: StripeWebhookService;\n  let stripePortalService: StripePortalService;\n  let supabaseService: SupabaseService;\n  let logger: PinoLogger;\n\n  const mockUser: AuthUser = {\n    id: 'user_test123',\n    email: 'test@example.com'\n  };\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [StripeController],\n      providers: [\n        {\n          provide: StripeService,\n          useValue: {\n            createCustomer: jest.fn(),\n            handleWebhook: jest.fn(),\n            createSubscriptionWithConfirmationToken: jest.fn(),\n            client: {\n              setupIntents: {\n                create: jest.fn(),\n              },\n            },\n          },\n        },\n        {\n          provide: StripeWebhookService,\n          useValue: {\n            handleWebhook: jest.fn(),\n          },\n        },\n        {\n          provide: StripePortalService,\n          useValue: {\n            createCheckoutSession: jest.fn(),\n            createPortalSession: jest.fn(),\n          },\n        },\n        {\n          provide: SupabaseService,\n          useValue: {\n            getAdminClient: jest.fn(() => mockSupabaseClient),\n          },\n        },\n        {\n          provide: PinoLogger,\n          useValue: {\n            info: jest.fn(),\n            warn: jest.fn(),\n            error: jest.fn(),\n            debug: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    controller = module.get<StripeController>(StripeController);\n    stripeService = module.get<StripeService>(StripeService);\n    stripeWebhookService = module.get<StripeWebhookService>(StripeWebhookService);\n    stripePortalService = module.get<StripePortalService>(StripePortalService);\n    supabaseService = module.get<SupabaseService>(SupabaseService);\n    logger = module.get<PinoLogger>(PinoLogger);\n  });\n\n  describe('getSubscription', () => {\n    it('should return user subscription successfully', async () => {\n      const mockSubscription = {\n        id: 'sub_test123',\n        userId: 'user_test123',\n        status: 'ACTIVE',\n        planType: 'STARTER',\n        updatedAt: new Date().toISOString()\n      };\n\n      mockSupabaseClient.maybeSingle.mockResolvedValueOnce({\n        data: mockSubscription,\n        error: null\n      });\n\n      const result = await controller.getSubscription(mockUser);\n\n      expect(result).toEqual(mockSubscription);\n      expect(mockSupabaseClient.from).toHaveBeenCalledWith('Subscription');\n      expect(mockSupabaseClient.eq).toHaveBeenCalledWith('userId', 'user_test123');\n      expect(mockSupabaseClient.order).toHaveBeenCalledWith('updatedAt', { ascending: false });\n      expect(mockSupabaseClient.limit).toHaveBeenCalledWith(1);\n    });\n\n    it('should throw NotFoundException when no subscription found', async () => {\n      mockSupabaseClient.maybeSingle.mockResolvedValueOnce({\n        data: null,\n        error: null\n      });\n\n      await expect(controller.getSubscription(mockUser)).rejects.toThrow(NotFoundException);\n      expect(logger.error).not.toHaveBeenCalled();\n    });\n\n    it('should handle database errors', async () => {\n      mockSupabaseClient.maybeSingle.mockResolvedValueOnce({\n        data: null,\n        error: { message: 'Database error' }\n      });\n\n      await expect(controller.getSubscription(mockUser)).rejects.toThrow(InternalServerErrorException);\n      expect(logger.error).toHaveBeenCalledWith('Failed to fetch subscription', { message: 'Database error' });\n    });\n  });\n\n  describe('createSetupIntent', () => {\n    it('should create setup intent for existing customer', async () => {\n      const mockUser = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: 'cus_existing123'\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockUser,\n        error: null\n      });\n\n      const mockSetupIntent = {\n        id: 'seti_test123',\n        client_secret: 'seti_test123_secret_xyz'\n      };\n\n      jest.spyOn(stripeService.client.setupIntents, 'create').mockResolvedValueOnce(mockSetupIntent as any);\n\n      const result = await controller.createSetupIntent(mockUser as AuthUser);\n\n      expect(result).toEqual({\n        clientSecret: 'seti_test123_secret_xyz',\n        setupIntentId: 'seti_test123'\n      });\n\n      expect(stripeService.client.setupIntents.create).toHaveBeenCalledWith({\n        customer: 'cus_existing123',\n        payment_method_types: ['card'],\n        usage: 'off_session'\n      });\n    });\n\n    it('should create customer and setup intent for new user', async () => {\n      const mockUserWithoutCustomer = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: null\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockUserWithoutCustomer,\n        error: null\n      });\n\n      const mockCustomer = {\n        id: 'cus_new123'\n      };\n\n      jest.spyOn(stripeService, 'createCustomer').mockResolvedValueOnce(mockCustomer as any);\n      mockSupabaseClient.update.mockResolvedValueOnce({ error: null });\n\n      const mockSetupIntent = {\n        id: 'seti_test123',\n        client_secret: 'seti_test123_secret_xyz'\n      };\n\n      jest.spyOn(stripeService.client.setupIntents, 'create').mockResolvedValueOnce(mockSetupIntent as any);\n\n      const result = await controller.createSetupIntent(mockUser);\n\n      expect(stripeService.createCustomer).toHaveBeenCalledWith('test@example.com', 'test@example.com');\n      expect(mockSupabaseClient.update).toHaveBeenCalledWith({ stripeCustomerId: 'cus_new123' });\n      expect(result.setupIntentId).toBe('seti_test123');\n    });\n\n    it('should handle user not found', async () => {\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: null,\n        error: { code: 'PGRST116' }\n      });\n\n      await expect(controller.createSetupIntent(mockUser)).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('createCheckout', () => {\n    const mockCheckoutRequest = {\n      planId: 'STARTER',\n      interval: 'monthly' as const,\n      successUrl: 'https://example.com/success',\n      cancelUrl: 'https://example.com/cancel'\n    };\n\n    it('should create checkout session successfully', async () => {\n      const mockCheckoutResult = {\n        url: 'https://checkout.stripe.com/test123',\n        sessionId: 'cs_test123'\n      };\n\n      jest.spyOn(stripePortalService, 'createCheckoutSession').mockResolvedValueOnce(mockCheckoutResult);\n\n      const result = await controller.createCheckout(mockCheckoutRequest, mockUser);\n\n      expect(result).toEqual(mockCheckoutResult);\n      expect(stripePortalService.createCheckoutSession).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId: 'user_test123',\n          priceId: expect.any(String),\n          successUrl: 'https://example.com/success',\n          cancelUrl: 'https://example.com/cancel'\n        })\n      );\n\n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          checkout: expect.objectContaining({\n            sessionId: 'cs_test123',\n            userId: 'user_test123'\n          })\n        }),\n        'Checkout session created: cs_test123'\n      );\n    });\n\n    it('should use default URLs when not provided', async () => {\n      const minimalRequest = {\n        planId: 'GROWTH',\n        interval: 'yearly' as const\n      };\n\n      const mockCheckoutResult = {\n        url: 'https://checkout.stripe.com/test123',\n        sessionId: 'cs_test123'\n      };\n\n      jest.spyOn(stripePortalService, 'createCheckoutSession').mockResolvedValueOnce(mockCheckoutResult);\n\n      await controller.createCheckout(minimalRequest, mockUser);\n\n      expect(stripePortalService.createCheckoutSession).toHaveBeenCalledWith(\n        expect.objectContaining({\n          successUrl: expect.stringContaining('tenantflow.app/billing/success'),\n          cancelUrl: expect.stringContaining('tenantflow.app/pricing')\n        })\n      );\n    });\n\n    it('should handle invalid plan/interval combination', async () => {\n      const invalidRequest = {\n        planId: 'INVALID_PLAN',\n        interval: 'monthly' as const\n      };\n\n      await expect(controller.createCheckout(invalidRequest, mockUser)).rejects.toThrow(BadRequestException);\n    });\n\n    it('should handle checkout creation errors', async () => {\n      jest.spyOn(stripePortalService, 'createCheckoutSession').mockRejectedValueOnce(\n        new Error('Stripe API error')\n      );\n\n      await expect(controller.createCheckout(mockCheckoutRequest, mockUser)).rejects.toThrow(\n        InternalServerErrorException\n      );\n\n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          error: expect.objectContaining({\n            message: 'Stripe API error'\n          })\n        }),\n        'Failed to create checkout session'\n      );\n    });\n  });\n\n  describe('createPortal', () => {\n    const mockPortalRequest = {\n      returnUrl: 'https://example.com/billing'\n    };\n\n    it('should create portal session successfully', async () => {\n      const mockPortalResult = {\n        url: 'https://billing.stripe.com/portal/test123'\n      };\n\n      jest.spyOn(stripePortalService, 'createPortalSession').mockResolvedValueOnce(mockPortalResult);\n\n      const result = await controller.createPortal(mockPortalRequest, mockUser);\n\n      expect(result).toEqual(mockPortalResult);\n      expect(stripePortalService.createPortalSession).toHaveBeenCalledWith({\n        userId: 'user_test123',\n        returnUrl: 'https://example.com/billing'\n      });\n    });\n\n    it('should use default return URL when not provided', async () => {\n      const mockPortalResult = {\n        url: 'https://billing.stripe.com/portal/test123'\n      };\n\n      jest.spyOn(stripePortalService, 'createPortalSession').mockResolvedValueOnce(mockPortalResult);\n\n      await controller.createPortal({}, mockUser);\n\n      expect(stripePortalService.createPortalSession).toHaveBeenCalledWith({\n        userId: 'user_test123',\n        returnUrl: expect.stringContaining('tenantflow.app/billing')\n      });\n    });\n\n    it('should handle portal creation errors', async () => {\n      jest.spyOn(stripePortalService, 'createPortalSession').mockRejectedValueOnce(\n        new Error('Portal creation failed')\n      );\n\n      await expect(controller.createPortal(mockPortalRequest, mockUser)).rejects.toThrow(\n        InternalServerErrorException\n      );\n\n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          error: expect.objectContaining({\n            message: 'Portal creation failed'\n          })\n        }),\n        'Failed to create portal session'\n      );\n    });\n  });\n\n  describe('createSubscription', () => {\n    const mockSubscriptionDto = {\n      confirmationTokenId: 'ctok_test123',\n      planType: 'STARTER',\n      billingInterval: 'monthly'\n    };\n\n    it('should create subscription successfully', async () => {\n      const mockExistingUser = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: 'cus_existing123'\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockExistingUser,\n        error: null\n      });\n\n      const mockSubscription = {\n        id: 'sub_test123',\n        status: 'active',\n        latest_invoice: {\n          payment_intent: {\n            status: 'succeeded'\n          }\n        }\n      };\n\n      jest.spyOn(stripeService, 'createSubscriptionWithConfirmationToken').mockResolvedValueOnce(\n        mockSubscription as any\n      );\n\n      const result = await controller.createSubscription(mockSubscriptionDto, mockUser);\n\n      expect(result).toEqual({\n        subscription: {\n          id: 'sub_test123',\n          status: 'active'\n        },\n        clientSecret: undefined,\n        requiresAction: false\n      });\n\n      expect(stripeService.createSubscriptionWithConfirmationToken).toHaveBeenCalledWith(\n        'ctok_test123',\n        'cus_existing123',\n        expect.any(String),\n        {\n          userId: 'user_test123',\n          planType: 'STARTER'\n        }\n      );\n    });\n\n    it('should create customer for new user', async () => {\n      const mockUserWithoutCustomer = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: null\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockUserWithoutCustomer,\n        error: null\n      });\n\n      const mockCustomer = {\n        id: 'cus_new123'\n      };\n\n      jest.spyOn(stripeService, 'createCustomer').mockResolvedValueOnce(mockCustomer as any);\n      mockSupabaseClient.update.mockResolvedValueOnce({ error: null });\n\n      const mockSubscription = {\n        id: 'sub_test123',\n        status: 'active',\n        latest_invoice: null\n      };\n\n      jest.spyOn(stripeService, 'createSubscriptionWithConfirmationToken').mockResolvedValueOnce(\n        mockSubscription as any\n      );\n\n      await controller.createSubscription(mockSubscriptionDto, mockUser);\n\n      expect(stripeService.createCustomer).toHaveBeenCalledWith('test@example.com', 'test@example.com');\n      expect(mockSupabaseClient.update).toHaveBeenCalledWith({ stripeCustomerId: 'cus_new123' });\n    });\n\n    it('should handle subscription requiring action', async () => {\n      const mockExistingUser = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: 'cus_existing123'\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockExistingUser,\n        error: null\n      });\n\n      const mockSubscription = {\n        id: 'sub_test123',\n        status: 'incomplete',\n        latest_invoice: {\n          payment_intent: {\n            status: 'requires_action',\n            client_secret: 'pi_test123_secret_xyz'\n          }\n        }\n      };\n\n      jest.spyOn(stripeService, 'createSubscriptionWithConfirmationToken').mockResolvedValueOnce(\n        mockSubscription as any\n      );\n\n      const result = await controller.createSubscription(mockSubscriptionDto, mockUser);\n\n      expect(result).toEqual({\n        subscription: {\n          id: 'sub_test123',\n          status: 'incomplete'\n        },\n        clientSecret: 'pi_test123_secret_xyz',\n        requiresAction: true\n      });\n    });\n\n    it('should handle user not found', async () => {\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: null,\n        error: { code: 'PGRST116' }\n      });\n\n      await expect(controller.createSubscription(mockSubscriptionDto, mockUser)).rejects.toThrow(\n        NotFoundException\n      );\n    });\n\n    it('should handle subscription creation errors', async () => {\n      const mockExistingUser = {\n        id: 'user_test123',\n        email: 'test@example.com',\n        stripeCustomerId: 'cus_existing123'\n      };\n\n      mockSupabaseClient.single.mockResolvedValueOnce({\n        data: mockExistingUser,\n        error: null\n      });\n\n      jest.spyOn(stripeService, 'createSubscriptionWithConfirmationToken').mockRejectedValueOnce(\n        new Error('Subscription creation failed')\n      );\n\n      await expect(controller.createSubscription(mockSubscriptionDto, mockUser)).rejects.toThrow(\n        InternalServerErrorException\n      );\n    });\n  });\n\n  describe('handleWebhook', () => {\n    const mockRequest = {\n      rawBody: Buffer.from('{\"test\": \"data\"}')\n    } as any;\n\n    const mockStripeSignature = 'stripe_signature_test123';\n\n    const mockStripeEvent: Stripe.Event = {\n      id: 'evt_test123',\n      object: 'event',\n      api_version: '2023-10-16',\n      created: Math.floor(Date.now() / 1000),\n      data: { object: {} as any },\n      livemode: false,\n      pending_webhooks: 1,\n      request: { id: 'req_test123', idempotency_key: null },\n      type: 'customer.subscription.created',\n    };\n\n    it('should handle webhook successfully', async () => {\n      jest.spyOn(stripeService, 'handleWebhook').mockResolvedValueOnce(mockStripeEvent);\n      jest.spyOn(stripeWebhookService, 'handleWebhook').mockResolvedValueOnce();\n\n      const result = await controller.handleWebhook(mockRequest, mockStripeSignature);\n\n      expect(result).toEqual({ received: true });\n\n      expect(stripeService.handleWebhook).toHaveBeenCalledWith(\n        Buffer.from('{\"test\": \"data\"}'),\n        'stripe_signature_test123'\n      );\n\n      expect(stripeWebhookService.handleWebhook).toHaveBeenCalledWith(mockStripeEvent);\n\n      expect(logger.info).toHaveBeenCalledWith('Received Stripe webhook');\n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          webhook: expect.objectContaining({\n            eventType: 'customer.subscription.created',\n            eventId: 'evt_test123',\n            livemode: false\n          })\n        }),\n        'Processing webhook event: customer.subscription.created'\n      );\n    });\n\n    it('should handle missing raw body', async () => {\n      const invalidRequest = { rawBody: null } as any;\n\n      await expect(controller.handleWebhook(invalidRequest, mockStripeSignature)).rejects.toThrow(\n        BadRequestException\n      );\n    });\n\n    it('should handle missing signature', async () => {\n      await expect(controller.handleWebhook(mockRequest, '')).rejects.toThrow(BadRequestException);\n    });\n\n    it('should handle signature verification failure', async () => {\n      jest.spyOn(stripeService, 'handleWebhook').mockRejectedValueOnce(\n        new Error('Invalid signature')\n      );\n\n      await expect(controller.handleWebhook(mockRequest, mockStripeSignature)).rejects.toThrow(\n        InternalServerErrorException\n      );\n\n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          error: expect.objectContaining({\n            message: 'Invalid signature'\n          }),\n          webhook: expect.objectContaining({\n            hasRawBody: true,\n            hasSignature: true\n          })\n        }),\n        'Webhook processing failed'\n      );\n    });\n\n    it('should handle webhook processing failure', async () => {\n      jest.spyOn(stripeService, 'handleWebhook').mockResolvedValueOnce(mockStripeEvent);\n      jest.spyOn(stripeWebhookService, 'handleWebhook').mockRejectedValueOnce(\n        new Error('Webhook processing error')\n      );\n\n      await expect(controller.handleWebhook(mockRequest, mockStripeSignature)).rejects.toThrow(\n        InternalServerErrorException\n      );\n\n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          error: expect.objectContaining({\n            message: 'Webhook processing error'\n          })\n        }),\n        'Webhook processing failed'\n      );\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":95,"column":12,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":95,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":109,"column":4,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":109,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":142,"column":12,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":142,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":160,"column":4,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":160,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":193,"column":12,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":193,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":1,"message":"Unsafe return of a value of type `any`.","line":208,"column":4,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":208,"endColumn":15},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe object destructuring of a property with an `any` value.","line":240,"column":18,"nodeType":"Identifier","messageId":"unsafeObjectPattern","endLine":240,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":256,"column":10,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":256,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":260,"column":6,"nodeType":"Property","messageId":"anyAssignment","endLine":260,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":260,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":260,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":261,"column":6,"nodeType":"Property","messageId":"anyAssignment","endLine":261,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":261,"column":22,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":261,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":262,"column":6,"nodeType":"Property","messageId":"anyAssignment","endLine":262,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .livemode on an `any` value.","line":262,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":262,"endColumn":31},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":264,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":264,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":277,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":277,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":277,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":277,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":278,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":278,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":278,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":278,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":284,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":284,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .type on an `any` value.","line":284,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":284,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":1,"message":"Unsafe assignment of an `any` value.","line":285,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":285,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":1,"message":"Unsafe member access .id on an `any` value.","line":285,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":285,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { RawBodyRequest } from '@nestjs/common'\nimport {\n\tBadRequestException,\n\tBody,\n\tController,\n\tGet,\n\tHeaders,\n\tInternalServerErrorException,\n\tNotFoundException,\n\tPost,\n\tReq,\n\tUseGuards\n} from '@nestjs/common'\nimport {\n\tApiBearerAuth,\n\tApiOperation,\n\tApiResponse,\n\tApiTags\n} from '@nestjs/swagger'\nimport type { FastifyRequest } from 'fastify'\nimport { PinoLogger } from 'nestjs-pino'\nimport { SupabaseService } from '../database/supabase.service'\nimport {\n\tcreateCheckoutSchema,\n\tcreatePortalSchema,\n\ttype CreateCheckoutRequest,\n\ttype CreatePortalRequest\n} from '../schemas/stripe.schemas'\nimport { CurrentUser } from '../shared/decorators/current-user.decorator'\nimport { Public } from '../shared/decorators/public.decorator'\nimport { AuthGuard } from '../shared/guards/auth.guard'\nimport { StripeSyncService } from './stripe-sync.service'\n\n// Use proper auth type from shared\nimport type { AuthUser } from '@repo/shared/types/auth'\n\n@ApiTags('stripe')\n@UseGuards(AuthGuard)\n@Controller('stripe')\nexport class StripeController {\n\tconstructor(\n\t\tprivate readonly stripeSyncService: StripeSyncService,\n\t\tprivate readonly supabaseService: SupabaseService,\n\t\tprivate readonly logger: PinoLogger\n\t) {\n\t\tthis.logger.setContext(StripeController.name)\n\t}\n\n\t@Get('subscription')\n\t@ApiOperation({ summary: 'Get current user subscription' })\n\t@ApiResponse({\n\t\tstatus: 200,\n\t\tdescription: 'Returns latest subscription for user'\n\t})\n\t@ApiResponse({ status: 404, description: 'Subscription not found' })\n\t@ApiBearerAuth()\n\tasync getSubscription(@CurrentUser() user: AuthUser) {\n\t\tthis.logger.info({ userId: user.id }, 'Getting user subscription')\n\n\t\t// Ultra-native: Direct database query with RLS enforcement\n\t\tconst client = this.supabaseService.getAdminClient()\n\t\tconst { data: sub, error } = await client\n\t\t\t.from('Subscription')\n\t\t\t.select('*')\n\t\t\t.eq('userId', user.id)\n\t\t\t.order('updatedAt', { ascending: false })\n\t\t\t.limit(1)\n\t\t\t.maybeSingle()\n\n\t\tif (error) {\n\t\t\tthis.logger.error('Failed to fetch subscription', error)\n\t\t\tthrow new InternalServerErrorException('Failed to fetch subscription')\n\t\t}\n\n\t\tif (!sub) {\n\t\t\tthrow new NotFoundException('No subscription found')\n\t\t}\n\n\t\treturn sub\n\t}\n\n\t@Post('setup-intent')\n\t@ApiOperation({ summary: 'Create Setup Intent for adding a payment method' })\n\t@ApiResponse({\n\t\tstatus: 200,\n\t\tdescription: 'Returns setup intent client secret'\n\t})\n\t@ApiBearerAuth()\n\tasync createSetupIntent(@CurrentUser() user: AuthUser) {\n\t\tthis.logger.info({ userId: user.id }, 'Creating setup intent')\n\n\t\ttry {\n\t\t\t// Ultra-native: Direct RPC call\n\t\t\tconst client = this.supabaseService.getAdminClient()\n\t\t\tconst { data, error } = await client.rpc(\n\t\t\t\t'create_stripe_setup_intent' as any,\n\t\t\t\t{\n\t\t\t\t\tp_user_id: user.id\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (error) {\n\t\t\t\tthis.logger.error('RPC call failed', error)\n\t\t\t\tthrow new InternalServerErrorException(\n\t\t\t\t\t`Setup intent creation failed: ${error.message}`\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn data\n\t\t} catch (error) {\n\t\t\tthis.logger.error('Setup intent creation failed', error)\n\t\t\tthrow new InternalServerErrorException('Failed to create setup intent')\n\t\t}\n\t}\n\n\t@Post('checkout')\n\t@ApiOperation({\n\t\tsummary: 'Create Stripe checkout session',\n\t\tdescription: 'Creates a secure checkout session for subscription purchase'\n\t})\n\t@ApiResponse({\n\t\tstatus: 200,\n\t\tdescription: 'Checkout session created successfully'\n\t})\n\t@ApiResponse({ status: 400, description: 'Invalid request data' })\n\t@ApiBearerAuth()\n\tasync createCheckout(\n\t\t@Body() dto: CreateCheckoutRequest,\n\t\t@CurrentUser() user: AuthUser\n\t) {\n\t\t// Ultra-native: Zod validation\n\t\tconst validatedDto = createCheckoutSchema.parse(dto)\n\n\t\tthis.logger.info(\n\t\t\t{ userId: user.id, planId: validatedDto.planId },\n\t\t\t'Creating checkout session'\n\t\t)\n\n\t\ttry {\n\t\t\t// Ultra-native: Direct RPC call\n\t\t\tconst client = this.supabaseService.getAdminClient()\n\t\t\tconst { data, error } = await client.rpc(\n\t\t\t\t'create_stripe_checkout_session' as any,\n\t\t\t\t{\n\t\t\t\t\tp_user_id: user.id,\n\t\t\t\t\tp_plan_id: validatedDto.planId,\n\t\t\t\t\tp_interval: validatedDto.interval,\n\t\t\t\t\tp_success_url: validatedDto.successUrl,\n\t\t\t\t\tp_cancel_url: validatedDto.cancelUrl\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (error) {\n\t\t\t\tthis.logger.error('RPC call failed', error)\n\t\t\t\tthrow new InternalServerErrorException(\n\t\t\t\t\t`Checkout creation failed: ${error.message}`\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn data\n\t\t} catch (error) {\n\t\t\tthis.logger.error('Checkout creation failed', error)\n\t\t\tthrow new InternalServerErrorException(\n\t\t\t\t'Failed to create checkout session'\n\t\t\t)\n\t\t}\n\t}\n\n\t@Post('portal')\n\t@ApiOperation({\n\t\tsummary: 'Create customer portal session',\n\t\tdescription:\n\t\t\t'Creates a secure customer portal session for subscription management'\n\t})\n\t@ApiResponse({\n\t\tstatus: 200,\n\t\tdescription: 'Portal session created successfully'\n\t})\n\t@ApiResponse({ status: 400, description: 'Invalid request data' })\n\t@ApiBearerAuth()\n\tasync createPortal(\n\t\t@Body() dto: CreatePortalRequest,\n\t\t@CurrentUser() user: AuthUser\n\t) {\n\t\t// Ultra-native: Zod validation\n\t\tconst validatedDto = createPortalSchema.parse(dto)\n\n\t\tthis.logger.info({ userId: user.id }, 'Creating portal session')\n\n\t\ttry {\n\t\t\t// Ultra-native: Direct RPC call\n\t\t\tconst client = this.supabaseService.getAdminClient()\n\t\t\tconst { data, error } = await client.rpc(\n\t\t\t\t'create_stripe_portal_session' as any,\n\t\t\t\t{\n\t\t\t\t\tp_user_id: user.id,\n\t\t\t\t\tp_return_url: validatedDto.returnUrl\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (error) {\n\t\t\t\tthis.logger.error('RPC call failed', error)\n\t\t\t\tthrow new InternalServerErrorException(\n\t\t\t\t\t`Portal creation failed: ${error.message}`\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn data\n\t\t} catch (error) {\n\t\t\tthis.logger.error('Portal creation failed', error)\n\t\t\tthrow new InternalServerErrorException('Failed to create portal session')\n\t\t}\n\t}\n\n\t@Post('webhook')\n\t@ApiOperation({\n\t\tsummary: 'Stripe webhook endpoint',\n\t\tdescription: 'Handles Stripe webhook events with signature verification'\n\t})\n\t@ApiResponse({ status: 200, description: 'Webhook processed successfully' })\n\t@ApiResponse({ status: 400, description: 'Invalid webhook signature' })\n\t@Public()\n\tasync handleWebhook(\n\t\t@Req() req: RawBodyRequest<FastifyRequest>,\n\t\t@Headers('stripe-signature') signature: string\n\t) {\n\t\tconst startTime = Date.now()\n\t\tthis.logger.info('Received Stripe webhook')\n\n\t\ttry {\n\t\t\tif (!req.rawBody) {\n\t\t\t\tthrow new BadRequestException('No raw body found in request')\n\t\t\t}\n\t\t\tif (!signature) {\n\t\t\t\tthrow new BadRequestException('No stripe signature found in headers')\n\t\t\t}\n\n\t\t\t// Ultra-native: Direct RPC call for webhook verification\n\t\t\tconst client = this.supabaseService.getAdminClient()\n\t\t\tconst { data: eventData, error } = await client.rpc(\n\t\t\t\t'verify_stripe_webhook' as any,\n\t\t\t\t{\n\t\t\t\t\tp_payload: req.rawBody.toString(),\n\t\t\t\t\tp_signature: signature\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (error) {\n\t\t\t\tthis.logger.error('Webhook verification failed', error)\n\t\t\t\tthrow new BadRequestException(\n\t\t\t\t\t`Webhook verification failed: ${error.message}`\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Parse the verified event\n\t\t\tconst event = eventData as any\n\n\t\t\tthis.logger.info(\n\t\t\t\t{\n\t\t\t\t\teventType: event?.type,\n\t\t\t\t\teventId: event?.id,\n\t\t\t\t\tlivemode: event?.livemode\n\t\t\t\t},\n\t\t\t\t`Processing webhook event: ${event?.type}`\n\t\t\t)\n\n\t\t\t// Process asynchronously to return 200 quickly (Stripe best practice)\n\t\t\tsetImmediate(async () => {\n\t\t\t\tconst processingStartTime = Date.now()\n\n\t\t\t\ttry {\n\t\t\t\t\t// Step 1: Auto-sync data using Stripe Sync Engine (Ultra-native)\n\t\t\t\t\tawait this.stripeSyncService.processWebhook(req.rawBody!, signature)\n\n\t\t\t\t\tconst totalTime = Date.now() - processingStartTime\n\t\t\t\t\tthis.logger.info('Webhook processed successfully', {\n\t\t\t\t\t\teventType: event?.type,\n\t\t\t\t\t\teventId: event?.id,\n\t\t\t\t\t\tprocessingTime: `${totalTime}ms`\n\t\t\t\t\t})\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Log error but don't fail the webhook (already returned 200)\n\t\t\t\t\tthis.logger.error('Async webhook processing failed', {\n\t\t\t\t\t\teventType: event?.type,\n\t\t\t\t\t\teventId: event?.id,\n\t\t\t\t\t\terror: error instanceof Error ? error.message : 'Unknown error',\n\t\t\t\t\t\tprocessingTime: `${Date.now() - processingStartTime}ms`,\n\t\t\t\t\t\tstack: error instanceof Error ? error.stack : undefined\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tconst responseTime = Date.now() - startTime\n\t\t\tthis.logger.info(`Webhook response sent in ${responseTime}ms`)\n\n\t\t\treturn { received: true }\n\t\t} catch (error) {\n\t\t\tthis.logger.error(\n\t\t\t\t{\n\t\t\t\t\terror: {\n\t\t\t\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\t\t\t\tstack:\n\t\t\t\t\t\t\tprocess.env.NODE_ENV !== 'production' && error instanceof Error\n\t\t\t\t\t\t\t\t? error.stack\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t},\n\t\t\t\t\twebhook: {\n\t\t\t\t\t\thasRawBody: !!req.rawBody,\n\t\t\t\t\t\thasSignature: !!signature\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'Webhook processing failed'\n\t\t\t)\n\t\t\tthrow new InternalServerErrorException(\n\t\t\t\t`Webhook processing failed: ${error instanceof Error ? error.message : String(error)}`\n\t\t\t)\n\t\t}\n\t}\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/billing/stripe.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/config/app-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/config/config.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/config/env.validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/config/fastify.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/config/performance.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/contact/contact.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/contact/contact.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/dashboard/dashboard.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/dashboard/dashboard.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/dashboard/dashboard.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/database/database-optimization.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/database/storage.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/database/supabase.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/database/supabase.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/emails/direct-email.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/emails/maintenance-request-email.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/emails/payment-failed-email.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/emails/payment-success-email.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/emails/subscription-canceled-email.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/health.controller.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/health.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/health.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/stripe-fdw.health.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/stripe-fdw.health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/health/supabase.health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/leases/lease-generator.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/leases/leases.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/leases/leases.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/leases/leases.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/maintenance/maintenance.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/maintenance/maintenance.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/maintenance/maintenance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/notifications/events/notification.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/notifications/notifications.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/notifications/notifications.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/notifications/notifications.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/pdf/lease-pdf.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/pdf/pdf-generator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/pdf/pdf.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/pdf/pdf.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/properties/properties.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/properties/properties.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/properties/properties.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/properties/property.schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/auth.schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/contact.schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/leases.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/maintenance.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/properties.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/shared.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/stripe.schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/tenants.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/schemas/units.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/security/csrf.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/security/security-monitor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/security/security.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/common.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/constants/billing-plans.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/constants/routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/constants/validation.constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/auth-token.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/auth.decorators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/current-user.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/public.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/roles.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/subscription.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/decorators/usage-limits.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/exceptions/business.exception.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/exceptions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/auth.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/roles.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/subscription.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/throttler-proxy.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/guards/usage-limits.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/pipes/limit-validation.pipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/pipes/zod-validation.pipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/serializers/fastify-currency.serializer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/serializers/fastify-date.serializer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/serializers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/test-utils/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/auth.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/billing.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/fastify-request.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/fastify-type-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/types/subscription.events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/utils/performance.decorators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/shared/utils/rate-limit.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/tenants/tenants.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/tenants/tenants.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/tenants/tenants.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/units/units.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/units/units.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/units/units.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/users/users.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/richard/Developer/tenant-flow/apps/backend/src/users/users.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
