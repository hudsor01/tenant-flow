/**
 * Stripe Sync Engine Webhook Controller
 *
 * Processes Stripe webhooks using @supabase/stripe-sync-engine npm library
 * Direct integration per official documentation - no custom abstractions
 *
 * See: https://github.com/supabase/stripe-sync-engine
 */

import {
	BadRequestException,
	Controller,
	Header,
	Inject,
	Logger,
	Post,
	Req,
	SetMetadata
} from '@nestjs/common'
import type { Request } from 'express'
import Stripe from 'stripe'
import { SupabaseService } from '../../database/supabase.service'
import { StripeClientService } from '../../shared/stripe-client.service'
import { StripeAccessControlService } from '../billing/stripe-access-control.service'
import { StripeSyncService } from '../billing/stripe-sync.service'

// Public decorator for webhook endpoints (bypasses JWT auth)
const Public = () => SetMetadata('isPublic', true)

@Controller('webhooks')
export class StripeSyncController {
	private readonly logger = new Logger(StripeSyncController.name)

	constructor(
		@Inject(StripeSyncService)
		private readonly stripeSyncService: StripeSyncService,
		private readonly stripeClientService: StripeClientService,
		private readonly supabaseService: SupabaseService,
		private readonly accessControlService: StripeAccessControlService
	) {}

	/**
	 * Check if webhook event already processed (idempotency per Stripe best practices 2025)
	 * Prevents duplicate processing if Stripe sends same event multiple times
	 */
	private async isEventProcessed(eventId: string): Promise<boolean> {
		const { data, error } = await this.supabaseService
			.getAdminClient()
			.from('stripe_processed_events')
			.select('event_id')
			.eq('event_id', eventId)
			.maybeSingle()

		if (error && error.code !== 'PGRST116') {
			// PGRST116 = not found, which is expected for new events
			this.logger.error('Error checking event idempotency', {
				error: error.message,
				eventId
			})
		}

		return !!data
	}

	/**
	 * Mark webhook event as processed (idempotency tracking)
	 */
	private async markEventProcessed(eventId: string, eventType: string): Promise<void> {
		const { error } = await this.supabaseService
			.getAdminClient()
			.from('stripe_processed_events')
			.insert({
				event_id: eventId,
				event_type: eventType
			})

		if (error && error.code !== '23505') {
			// 23505 = unique constraint violation (event already exists, safe to ignore)
			this.logger.warn('Failed to mark event as processed', {
				error: error.message,
				eventId
			})
		}
	}

	/**
	 * Link Stripe customer to Supabase user + Handle business logic
	 * Called after Sync Engine processes webhook to maintain user_id mapping
	 */
	private async processWebhookBusinessLogic(
		rawBody: Buffer,
		signature: string
	) {
		try {
			// We need to parse the event again to get the event type
			// This is safe because Sync Engine already validated the signature
			const event: Stripe.Event =
				this.stripeClientService.constructWebhookEvent(
					rawBody,
					signature,
					process.env.STRIPE_WEBHOOK_SECRET!
				)

			this.logger.log('Processing webhook business logic', {
				eventType: event.type,
				eventId: event.id
			})

			// IDEMPOTENCY CHECK: Prevent duplicate processing
			if (await this.isEventProcessed(event.id)) {
				this.logger.log('Event already processed, skipping', {
					eventId: event.id,
					eventType: event.type
				})
				return
			}

			// Handle customer linking
			if (
				event.type === 'customer.created' ||
				event.type === 'customer.updated'
			) {
				await this.linkCustomerToUser(event)
			}

			// Handle checkout.session.completed (CRITICAL: was missing!)
			if (event.type === 'checkout.session.completed') {
				await this.handleCheckoutCompleted(event)
			}

			// Handle payment_intent.succeeded (CRITICAL: was missing!)
			if (event.type === 'payment_intent.succeeded') {
				await this.handlePaymentSucceeded(event)
			}

			// Handle subscription access control
			switch (event.type) {
				case 'customer.subscription.created':
				case 'customer.subscription.updated': {
					const subscription = event.data.object as Stripe.Subscription
					// Grant access if subscription is active or trialing
					if (
						subscription.status === 'active' ||
						subscription.status === 'trialing'
					) {
						await this.accessControlService.grantSubscriptionAccess(
							subscription
						)
					}
					// Revoke access if subscription is canceled
					else if (
						subscription.status === 'canceled' ||
						subscription.status === 'past_due' ||
						subscription.status === 'unpaid'
					) {
						await this.accessControlService.revokeSubscriptionAccess(
							subscription
						)
					}
					break
				}
				case 'customer.subscription.deleted': {
					const subscription = event.data.object as Stripe.Subscription
					await this.accessControlService.revokeSubscriptionAccess(subscription)
					break
				}
			}

			// Mark event as processed AFTER successful handling
			await this.markEventProcessed(event.id, event.type)
		} catch (error) {
			this.logger.error('Error processing webhook business logic', {
				error: error instanceof Error ? error.message : 'Unknown error'
			})
			// Don't throw - business logic errors shouldn't fail the webhook
		}
	}

	/**
	 * CRITICAL FIX: Handle checkout.session.completed webhook
	 * Records one-time payments in rent_payment table
	 *
	 * Without this handler, payments succeed but are NEVER recorded in DB!
	 */
	private async handleCheckoutCompleted(event: Stripe.Event) {
		const session = event.data.object as Stripe.Checkout.Session

		this.logger.log('Processing checkout.session.completed', {
			sessionId: session.id,
			customerId: session.customer,
			amountTotal: session.amount_total,
			currency: session.currency,
			paymentStatus: session.payment_status
		})

		// Only process successful payments
		if (session.payment_status !== 'paid') {
			this.logger.warn('Checkout session not paid, skipping', {
				sessionId: session.id,
				paymentStatus: session.payment_status
			})
			return
		}

		// Extract metadata (should contain leaseId, tenantId from frontend)
		const leaseId = session.metadata?.leaseId
		const tenantId = session.metadata?.tenantId
		const paymentType = session.metadata?.paymentType || 'rent' // 'rent' or 'deposit'

		if (!leaseId || !tenantId) {
			this.logger.error('Missing required metadata in checkout session', {
				sessionId: session.id,
				metadata: session.metadata
			})
			return
		}

		// Record payment in database
		const { error } = await this.supabaseService
			.getAdminClient()
			.from('rent_payment')
			.insert({
				leaseId,
				tenantId,
				amount: (session.amount_total || 0) / 100, // Convert cents to dollars
				paymentDate: new Date().toISOString(),
				paymentMethod: 'stripe_checkout',
				status: 'completed',
				stripePaymentId: session.payment_intent as string,
				notes: `One-time payment via Stripe Checkout (${paymentType})`
			})

		if (error) {
			this.logger.error('Failed to record checkout payment', {
				error: error.message,
				sessionId: session.id,
				leaseId,
				tenantId
			})
		} else {
			this.logger.log('Checkout payment recorded successfully', {
				sessionId: session.id,
				leaseId,
				tenantId,
				amount: (session.amount_total || 0) / 100
			})
		}
	}

	/**
	 * Handle payment_intent.succeeded webhook
	 * Tracks successful payments for subscriptions and one-time charges
	 */
	private async handlePaymentSucceeded(event: Stripe.Event) {
		const paymentIntent = event.data.object as Stripe.PaymentIntent

		this.logger.log('Processing payment_intent.succeeded', {
			paymentIntentId: paymentIntent.id,
			customerId: paymentIntent.customer,
			amount: paymentIntent.amount,
			currency: paymentIntent.currency,
			status: paymentIntent.status
		})

		// If payment is for a subscription, it's already handled by subscription webhooks
		// This handler is for additional payment tracking/logging
		// Can be extended for: fraud detection, analytics, email receipts, etc.
	}

	/**
	 * Link Stripe customer to Supabase user by email
	 * Uses the link_stripe_customer_to_user database function
	 */
	private async linkCustomerToUser(event: Stripe.Event) {
const customer = event.data.object as Stripe.Customer

		if (!customer.email) {
			this.logger.warn('Customer has no email, skipping user linking', {
				customerId: customer.id
			})
			return
		}

		// Call the database function to link customer to user
		const { data, error } = await this.supabaseService.rpcWithRetries(
			'link_stripe_customer_to_user',
			{
				p_stripe_customer_id: customer.id,
				p_email: customer.email
			}
		)

		if (error) {
			this.logger.warn('Failed to link Stripe customer to user', {
				error: error.message || String(error),
				customerId: customer.id,
				email: customer.email
			})
		} else if (data) {
			this.logger.log('Linked Stripe customer to user', {
				customerId: customer.id,
				userId: data
			})
		}
	}

	/**
	 * Stripe Sync Engine webhook endpoint
	 * Automatically syncs all Stripe data to stripe.* tables
	 *
	 * Endpoint: POST /webhooks/stripe-sync
	 * Security: Validates Stripe signature
	 */
	@Public() // Stripe webhooks don't use JWT auth
	@Post('stripe-sync')
	@Header('content-type', 'application/json')
	async handleStripeSyncWebhook(@Req() req: Request) {
		const signature = req.headers['stripe-signature']

		if (!signature || typeof signature !== 'string') {
			throw new BadRequestException('Missing Stripe signature')
		}

		// Express raw() middleware stores buffer in req.body
		const rawBody = req.body as Buffer

		if (!rawBody || !Buffer.isBuffer(rawBody)) {
			throw new BadRequestException(
				'Missing raw body for signature verification'
			)
		}

		try {
			this.logger.log('Processing Stripe webhook via Sync Engine')

			// Stripe Sync Engine handles:
			// - Signature verification
			// - Event processing
			// - Database synchronization to stripe.* schema
			// - Idempotency
			await this.stripeSyncService.processWebhook(rawBody, signature)

			// Process business logic AFTER sync to ensure stripe.* data exists
			// This includes:
			// - Linking customers to users
			// - Granting/revoking subscription access
			// - Sending email notifications
			await this.processWebhookBusinessLogic(rawBody, signature)

			this.logger.log('Stripe webhook processed successfully')

			return { received: true }
		} catch (error) {
			this.logger.error('Failed to process Stripe webhook', {
				error: error instanceof Error ? error.message : 'Unknown error',
				stack: error instanceof Error ? error.stack : undefined
			})
			throw new BadRequestException('Webhook processing failed')
		}
	}
}
