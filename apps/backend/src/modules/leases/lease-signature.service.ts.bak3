/**
 * LeaseSignatureService
 *
 * Handles the lease signature workflow:
 * 1. Owner creates lease draft (status: 'draft')
 * 2. Owner sends lease for signature (status: 'pending_signature')
 * 3. Tenant signs the lease
 * 4. Owner signs the lease (can be before or after tenant)
 * 5. When BOTH signed: delegates activation to LeaseSubscriptionService
 *
 * Key principle: NO Stripe billing until BOTH parties have signed.
 *
 * RESPONSIBILITY: Signature workflow only - delegates subscription creation
 * to LeaseSubscriptionService (SRP compliance).
 */

import {
	BadRequestException,
	ForbiddenException,
	Injectable,
	NotFoundException
} from '@nestjs/common'
import { EventEmitter2 } from '@nestjs/event-emitter'
import { SupabaseService } from '../../database/supabase.service'
import { DocuSealService } from '../docuseal/docuseal.service'
import { LeaseSubscriptionService } from './lease-subscription.service'
import { LeasePdfMapperService } from '../pdf/lease-pdf-mapper.service'
import { LeasePdfGeneratorService } from '../pdf/lease-pdf-generator.service'
import { PdfStorageService } from '../pdf/pdf-storage.service'
import { LeasesService } from './leases.service'
import {
	LEASE_SIGNATURE_ERROR_MESSAGES,
	LEASE_SIGNATURE_ERROR_CODES
} from '@repo/shared/constants/lease-signature-errors'
import { AppLogger } from '../../logger/app-logger.service'

export interface SignatureStatus {
	lease_id: string
	status: string
	owner_signed: boolean
	owner_signed_at: string | null
	tenant_signed: boolean
	tenant_signed_at: string | null
	sent_for_signature_at: string | null
	both_signed: boolean
	docuseal_submission_id?: string | null
}

export interface SendForSignatureOptions {
	message?: string | undefined
	templateId?: number | undefined // DEPRECATED: DocuSeal template ID (legacy approach)
	missingFields?: {
		immediate_family_members?: string
		landlord_notice_address?: string
	} | undefined // User-provided missing PDF fields
	token?: string | undefined // JWT token for database queries
}

/**
 * Result from the sign_lease_and_check_activation RPC function
 */
export interface SignLeaseRpcResult {
	success: boolean
	both_signed: boolean
	error_message: string | null
}

@Injectable()
export class LeaseSignatureService {
	constructor(
		private readonly supabase: SupabaseService,
		private readonly eventEmitter: EventEmitter2,
		private readonly docuSealService: DocuSealService,
		private readonly leaseSubscriptionService: LeaseSubscriptionService,
		private readonly leasesService: LeasesService,
		private readonly pdfMapper: LeasePdfMapperService,
		private readonly pdfGenerator: LeasePdfGeneratorService,
		private readonly pdfStorage: PdfStorageService,
		private readonly logger: AppLogger
	) {}

	/**
	 * Parse the result from sign_lease_and_check_activation RPC
	 * RPC returns SETOF (array of rows), extract the first row's values
	 */
	private parseSignLeaseRpcResult(rpcResult: unknown): SignLeaseRpcResult {
		if (!rpcResult || (Array.isArray(rpcResult) && rpcResult.length === 0)) {
			return {
				success: false,
				both_signed: false,
				error_message:
					LEASE_SIGNATURE_ERROR_MESSAGES[
						LEASE_SIGNATURE_ERROR_CODES.RPC_NO_RESULT
					]
			}
		}

		const row = Array.isArray(rpcResult) ? rpcResult[0] : rpcResult

		return {
			success: Boolean((row as Record<string, unknown>).success),
			both_signed: Boolean((row as Record<string, unknown>).both_signed),
			error_message:
				((row as Record<string, unknown>).error_message as string) || null
		}
	}

	/**
	 * Owner sends a lease for signature (draft -> pending_signature)
	 * Production-ready workflow:
	 * 1. Query lease data from database
	 * 2. Auto-fill PDF fields from DB
	 * 3. Validate missing fields (user must provide)
	 * 4. Generate filled PDF with pdf-lib
	 * 5. Upload PDF to Supabase Storage
	 * 6. Create DocuSeal submission from uploaded PDF URL
	 * 7. Update lease status to pending_signature
	 */
	async sendForSignature(
		ownerId: string,
		leaseId: string,
		options?: SendForSignatureOptions
	): Promise<void> {
		this.logger.log('Sending lease for signature with PDF generation', {
			ownerId,
			leaseId
		})
		const client = this.supabase.getAdminClient()

		// Step 1: Validate ownership and lease status
		const { data: lease, error: leaseError } = await client
			.from('leases')
			.select('id, lease_status, owner_user_id, primary_tenant_id')
			.eq('id', leaseId)
			.single()

		if (leaseError || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Verify ownership
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.owner_user_id === ownerId
		if (!isOwner) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NOT_LEASE_OWNER
				]
			)
		}

		// Verify draft status
		if (lease.lease_status !== 'draft') {
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_DRAFT
				]
			)
		}

		// Step 2: Get complete lease data for PDF generation
		if (!options?.token) {
			throw new BadRequestException(
				'JWT token required for PDF generation. Please provide options.token.'
			)
		}

		const leaseData = await this.leasesService.getLeaseDataForPdf(
			options.token,
			leaseId
		)

		// Step 3: Auto-fill PDF fields and check for missing data
		const { fields: autoFilledFields, missing } =
			this.pdfMapper.mapLeaseToPdfFields(leaseData)

		// Validate missing fields are provided
		if (!missing.isComplete) {
			if (!options.missingFields) {
				this.logger.warn('Missing required PDF fields', {
					leaseId,
					missingFields: missing.fields
				})
				throw new BadRequestException(
					`Cannot send for signature: missing required fields: ${missing.fields.join(', ')}. Please provide these in options.missingFields.`
				)
			}

			// Validate provided missing fields
			const validation = this.pdfMapper.validateMissingFields(
				options.missingFields as { [key: string]: string }
			)
			if (!validation.isValid) {
				throw new BadRequestException(
					`Invalid missing fields: ${validation.errors.join(', ')}`
				)
			}
		}

		// Step 4: Merge auto-filled + user-provided fields
		const completeFields = this.pdfMapper.mergeMissingFields(
			autoFilledFields,
			(options.missingFields as { [key: string]: string }) || {}
		)

		// Step 5: Generate filled PDF
		let pdfBuffer: Buffer
		try {
			pdfBuffer = await this.pdfGenerator.generateFilledPdf(completeFields, leaseId)
			this.logger.log('Generated filled lease PDF', {
				leaseId,
				sizeBytes: pdfBuffer.length
			})
		} catch (error) {
			this.logger.error('Failed to generate lease PDF', {
				error: error instanceof Error ? error.message : String(error),
				leaseId
			})
			throw new BadRequestException(
				'Failed to generate lease PDF. Please contact support.'
			)
		}

		// Step 6: Upload PDF to Supabase Storage
		let pdfUrl: string
		try {
			const uploadResult = await this.pdfStorage.uploadLeasePdf(leaseId, pdfBuffer)
			pdfUrl = uploadResult.publicUrl
			this.logger.log('Uploaded lease PDF to storage', {
				leaseId,
				pdfUrl,
				path: uploadResult.path
			})
		} catch (error) {
			this.logger.error('Failed to upload lease PDF to storage', {
				error: error instanceof Error ? error.message : String(error),
				leaseId
			})
			throw new BadRequestException(
				'Failed to upload lease PDF. Please try again.'
			)
		}

		// Step 7: Get user emails for DocuSeal
		// Query users table directly (no property_owners table)
		const [{ data: tenantRecord }] = await Promise.all([
			client
				.from('tenants')
				.select('user_id')
				.eq('id', lease.primary_tenant_id)
				.single()
		])

		let ownerUser: { email: string; first_name: string | null; last_name: string | null } | null = null
		let tenantUser: { email: string; first_name: string | null; last_name: string | null } | null = null

		if (lease.owner_user_id && tenantRecord?.user_id) {
			const [ownerResult, tenantResult] = await Promise.all([
				client
					.from('users')
					.select('email, first_name, last_name')
					.eq('id', lease.owner_user_id)
					.single(),
				client
					.from('users')
					.select('email, first_name, last_name')
					.eq('id', tenantRecord.user_id)
					.single()
			])
			ownerUser = ownerResult.data
			tenantUser = tenantResult.data
		}

		if (!ownerUser?.email || !tenantUser?.email) {
			throw new BadRequestException(
				'Owner and tenant must have valid email addresses for signature workflow.'
			)
		}

		// Step 8: Create DocuSeal submission from uploaded PDF
		let docusealSubmissionId: string | null = null

		if (this.docuSealService.isEnabled()) {
			try {
				const submission = await this.docuSealService.createSubmissionFromPdf({
					leaseId,
					pdfUrl,
					ownerEmail: ownerUser.email,
					ownerName:
						`${ownerUser.first_name || ''} ${ownerUser.last_name || ''}`.trim() ||
						'Property Owner',
					tenantEmail: tenantUser.email,
					tenantName:
						`${tenantUser.first_name || ''} ${tenantUser.last_name || ''}`.trim() ||
						'Tenant',
					sendEmail: false // We handle emails via Resend
				})

				docusealSubmissionId = String(submission.id)
				this.logger.log('Created DocuSeal submission from PDF', {
					submissionId: submission.id,
					leaseId,
					pdfUrl
				})
			} catch (error) {
				this.logger.error('Failed to create DocuSeal submission from PDF', {
					error: error instanceof Error ? error.message : String(error),
					leaseId
				})
				// Continue without DocuSeal - fallback to in-app signing
			}
		} else {
			this.logger.warn('DocuSeal not enabled, skipping submission creation', {
				leaseId
			})
		}

		// Step 9: Update lease status
		const now = new Date().toISOString()
		const updateData: Record<string, unknown> = {
			lease_status: 'pending_signature',
			sent_for_signature_at: now,
			pdf_storage_path: pdfUrl // Store PDF URL for future reference
		}

		if (docusealSubmissionId) {
			updateData.docuseal_submission_id = docusealSubmissionId
		}

		const { error: updateError } = await client
			.from('leases')
			.update(updateData)
			.eq('id', leaseId)

		if (updateError) {
			this.logger.error('Failed to update lease status to pending_signature', {
				error: updateError.message,
				leaseId,
				ownerId
			})
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.SEND_FOR_SIGNATURE_FAILED
				]
			)
		}

		// Step 10: Emit event for notification service
		this.eventEmitter.emit('lease.sent_for_signature', {
			lease_id: leaseId,
			tenant_id: lease.primary_tenant_id,
			message: options?.message,
			docuseal_submission_id: docusealSubmissionId,
			pdf_url: pdfUrl
		})

		this.logger.log('Lease sent for signature successfully', {
			leaseId,
			docusealSubmissionId,
			pdfUrl
		})
	}

	/**
	 * Owner signs the lease via in-app signature
	 */
	async signLeaseAsOwner(
		ownerId: string,
		leaseId: string,
		signatureIp: string
	): Promise<void> {
		this.logger.log('Owner signing lease', { ownerId, leaseId })
		const client = this.supabase.getAdminClient()

		// Step 1: Get lease for authorization check (read-only, no lock needed)
		const { data: lease, error: leaseError } = await client
			.from('leases')
			.select(
				'id, owner_user_id, rent_amount, primary_tenant_id'
			)
			.eq('id', leaseId)
			.single()

		if (leaseError || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Step 2: Verify owner owns the lease (ownerId is auth.users.id)
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.property_owner?.user_id === ownerId
		if (!isOwner) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NOT_LEASE_OWNER
				]
			)
		}

		// Step 3: Call atomic RPC to sign and check if both signed
		// This uses SELECT FOR UPDATE to prevent race conditions
		const now = new Date().toISOString()
		const { data: rpcResult, error: rpcError } = await client.rpc(
			'sign_lease_and_check_activation',
			{
				p_lease_id: leaseId,
				p_signer_type: 'owner',
				p_signature_ip: signatureIp,
				p_signed_at: now
			}
		)

		if (rpcError) {
			this.logger.error('RPC sign_lease_and_check_activation failed', {
				leaseId,
				error: rpcError
			})
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.RECORD_SIGNATURE_FAILED
				]
			)
		}

		const result = this.parseSignLeaseRpcResult(rpcResult)

		if (!result.success) {
			throw new BadRequestException(
				result.error_message ||
					LEASE_SIGNATURE_ERROR_MESSAGES[
						LEASE_SIGNATURE_ERROR_CODES.SIGN_LEASE_FAILED
					]
			)
		}

		// Step 4: Handle activation if both signed (delegates to subscription service)
		if (result.both_signed) {
			await this.leaseSubscriptionService.activateLease(client, lease, {
				owner_signed_at: now,
				owner_signature_ip: signatureIp
			})
		} else {
			this.eventEmitter.emit('lease.owner_signed', {
				lease_id: leaseId,
				signed_at: now
			})
		}

		this.logger.log('Owner signed lease', {
			leaseId,
			bothSigned: result.both_signed
		})
	}

	/**
	 * Tenant signs the lease via in-app signature
	 */
	async signLeaseAsTenant(
		tenantUserId: string,
		leaseId: string,
		signatureIp: string
	): Promise<void> {
		this.logger.log('Tenant signing lease', { tenantUserId, leaseId })
		const client = this.supabase.getAdminClient()

		// Step 1: Get tenant record from user_id
		const { data: tenant, error: tenantError } = await client
			.from('tenants')
			.select('id, user_id, stripe_customer_id')
			.eq('user_id', tenantUserId)
			.single()

		if (tenantError || !tenant) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.TENANT_NOT_FOUND
				]
			)
		}

		// Step 2: Get lease for authorization check (read-only, no lock needed)
		const { data: lease, error: leaseError } = await client
			.from('leases')
			.select('id, owner_user_id, primary_tenant_id, rent_amount')
			.eq('id', leaseId)
			.single()

		if (leaseError || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Step 3: Verify tenant is assigned to this lease
		if (lease.primary_tenant_id !== tenant.id) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NOT_ASSIGNED_TO_LEASE
				]
			)
		}

		// Step 4: Call atomic RPC to sign and check if both signed
		// This uses SELECT FOR UPDATE to prevent race conditions
		const now = new Date().toISOString()
		const { data: rpcResult, error: rpcError } = await client.rpc(
			'sign_lease_and_check_activation',
			{
				p_lease_id: leaseId,
				p_signer_type: 'tenant',
				p_signature_ip: signatureIp,
				p_signed_at: now
			}
		)

		if (rpcError) {
			this.logger.error('RPC sign_lease_and_check_activation failed', {
				leaseId,
				error: rpcError
			})
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.RECORD_SIGNATURE_FAILED
				]
			)
		}

		const result = this.parseSignLeaseRpcResult(rpcResult)

		if (!result.success) {
			throw new BadRequestException(
				result.error_message ||
					LEASE_SIGNATURE_ERROR_MESSAGES[
						LEASE_SIGNATURE_ERROR_CODES.SIGN_LEASE_FAILED
					]
			)
		}

		// Step 5: Handle activation if both signed (delegates to subscription service)
		if (result.both_signed) {
			await this.leaseSubscriptionService.activateLease(client, lease, {
				tenant_signed_at: now,
				tenant_signature_ip: signatureIp
			})
		} else {
			this.eventEmitter.emit('lease.tenant_signed', {
				lease_id: leaseId,
				tenant_id: tenant.id,
				signed_at: now
			})
		}

		this.logger.log('Tenant signed lease', {
			leaseId,
			bothSigned: result.both_signed
		})
	}

	/**
	 * Get signature status for a lease
	 */
	async getSignatureStatus(
		leaseId: string,
		userId: string
	): Promise<SignatureStatus> {
		const client = this.supabase.getAdminClient()

		const { data: lease, error } = await client
			.from('leases')
			.select(
				'id, lease_status, owner_signed_at, tenant_signed_at, sent_for_signature_at, owner_user_id, primary_tenant_id, docuseal_submission_id'
			)
			.eq('id', leaseId)
			.single()

		if (error || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Authorization check: user must be owner or tenant
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.property_owner?.user_id === userId

		let isTenant = false
		if (!isOwner) {
			// Check if user is the tenant (primary_tenant_id references tenants table)
			const { data: tenant } = await client
				.from('tenants')
				.select('id')
				.eq('user_id', userId)
				.eq('id', lease.primary_tenant_id)
				.single()

			isTenant = !!tenant
		}

		if (!isOwner && !isTenant) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NO_ACCESS_TO_LEASE
				]
			)
		}

		const ownerSigned = !!lease.owner_signed_at
		const tenantSigned = !!lease.tenant_signed_at

		return {
			lease_id: lease.id,
			status: lease.lease_status,
			owner_signed: ownerSigned,
			owner_signed_at: lease.owner_signed_at,
			tenant_signed: tenantSigned,
			tenant_signed_at: lease.tenant_signed_at,
			sent_for_signature_at: lease.sent_for_signature_at,
			both_signed: ownerSigned && tenantSigned,
			docuseal_submission_id: lease.docuseal_submission_id
		}
	}

	/**
	 * Get DocuSeal signing URL for a user
	 */
	async getSigningUrl(leaseId: string, userId: string): Promise<string | null> {
		const client = this.supabase.getAdminClient()

		// Get lease with DocuSeal submission ID
		const { data: lease, error } = await client
			.from('leases')
			.select(
				'id, docuseal_submission_id, owner_user_id, primary_tenant_id'
			)
			.eq('id', leaseId)
			.single()

		if (error || !lease || !lease.docuseal_submission_id) {
			return null
		}

		// Determine if user is owner or tenant and get their email
		if (!lease.owner_user_id) {
			return null // Can't determine ownership without owner_user_id
		}
		let userEmail: string | null = null
		const isOwner = lease.property_owner?.user_id === userId

		if (isOwner) {
			// User is the owner - get their email
			const { data: ownerUser } = await client
				.from('users')
				.select('email')
				.eq('id', userId)
				.single()
			userEmail = ownerUser?.email || null
		} else {
			// Check if user is tenant
			const { data: tenant } = await client
				.from('tenants')
				.select('user_id')
				.eq('id', lease.primary_tenant_id)
				.single()

			if (tenant?.user_id === userId) {
				const { data: tenantUser } = await client
					.from('users')
					.select('email')
					.eq('id', userId)
					.single()
				userEmail = tenantUser?.email || null
			}
		}

		if (!userEmail) {
			return null
		}

		// Get signing URL from DocuSeal
		try {
			const signingUrl = await this.docuSealService.getSubmitterSigningUrl(
				parseInt(lease.docuseal_submission_id, 10),
				userEmail
			)
			return signingUrl
		} catch (error) {
			this.logger.error('Failed to get DocuSeal signing URL', {
				error: error instanceof Error ? error.message : String(error),
				leaseId
			})
			return null
		}
	}

	/**
	 * Cancel a pending signature request
	 */
	async cancelSignatureRequest(
		ownerId: string,
		leaseId: string
	): Promise<void> {
		const client = this.supabase.getAdminClient()

		// Get lease and verify ownership
		const { data: lease, error } = await client
			.from('leases')
			.select(
				'id, lease_status, owner_user_id, docuseal_submission_id'
			)
			.eq('id', leaseId)
			.single()

		if (error || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Verify owner owns the lease (ownerId is auth.users.id)
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.property_owner?.user_id === ownerId
		if (!isOwner) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NOT_LEASE_OWNER
				]
			)
		}

		if (lease.lease_status !== 'pending_signature') {
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_PENDING_SIGNATURE
				]
			)
		}

		// Archive DocuSeal submission if exists
		if (lease.docuseal_submission_id && this.docuSealService.isEnabled()) {
			try {
				await this.docuSealService.archiveSubmission(
					parseInt(lease.docuseal_submission_id, 10)
				)
				this.logger.log('Archived DocuSeal submission', {
					submissionId: lease.docuseal_submission_id,
					leaseId
				})
			} catch (error) {
				this.logger.error('Failed to archive DocuSeal submission', {
					error: error instanceof Error ? error.message : String(error),
					leaseId
				})
				// Continue with cancellation even if DocuSeal fails
			}
		}

		// Revert lease to draft status
		const { error: updateError } = await client
			.from('leases')
			.update({
				lease_status: 'draft',
				sent_for_signature_at: null,
				docuseal_submission_id: null,
				owner_signed_at: null,
				owner_signature_ip: null,
				owner_signature_method: null,
				tenant_signed_at: null,
				tenant_signature_ip: null,
				tenant_signature_method: null
			})
			.eq('id', leaseId)

		if (updateError) {
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.CANCEL_SIGNATURE_FAILED
				]
			)
		}

		this.eventEmitter.emit('lease.signature_cancelled', {
			lease_id: leaseId
		})

		this.logger.log('Signature request cancelled', { leaseId })
	}

	/**
	 * Resend signature request using DocuSeal's native PUT /submitters endpoint.
	 * This re-sends email notifications to pending submitters without creating a new submission.
	 */
	async resendSignatureRequest(
		ownerId: string,
		leaseId: string,
		options?: { message?: string }
	): Promise<void> {
		const client = this.supabase.getAdminClient()

		// Get lease and verify ownership
		const { data: lease, error } = await client
			.from('leases')
			.select(
				'id, lease_status, owner_user_id, docuseal_submission_id'
			)
			.eq('id', leaseId)
			.single()

		if (error || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Verify owner owns the lease
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.property_owner?.user_id === ownerId
		if (!isOwner) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NOT_LEASE_OWNER
				]
			)
		}

		// Verify lease is in pending_signature status
		if (lease.lease_status !== 'pending_signature') {
			throw new BadRequestException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_PENDING_SIGNATURE
				]
			)
		}

		// Verify DocuSeal submission exists
		if (!lease.docuseal_submission_id || !this.docuSealService.isEnabled()) {
			throw new BadRequestException(
				'No DocuSeal submission found for this lease. Cannot resend.'
			)
		}

		// Get submission to find pending submitters
		const submission = await this.docuSealService.getSubmission(
			parseInt(lease.docuseal_submission_id, 10)
		)

		// Resend to all pending submitters
		const pendingSubmitters = submission.submitters.filter(
			s => s.status === 'pending' || s.status === 'opened'
		)

		if (pendingSubmitters.length === 0) {
			throw new BadRequestException(
				'All parties have already signed. Nothing to resend.'
			)
		}

		// Resend to each pending submitter
		for (const submitter of pendingSubmitters) {
			if (submitter.id) {
				const resendOptions: { message?: string } = {}
				if (options?.message) {
					resendOptions.message = options.message
				}
				await this.docuSealService.resendToSubmitter(submitter.id, resendOptions)
			}
		}

		this.logger.log('Resent signature request', {
			leaseId,
			submitterCount: pendingSubmitters.length
		})
	}

	/**
	 * Get signed document URL from DocuSeal
	 * Only available for active leases with completed signatures
	 */
	async getSignedDocumentUrl(
		leaseId: string,
		userId: string
	): Promise<string | null> {
		const client = this.supabase.getAdminClient()

		// Get lease with DocuSeal submission ID
		const { data: lease, error } = await client
			.from('leases')
			.select(
				'id, lease_status, docuseal_submission_id, owner_user_id, primary_tenant_id'
			)
			.eq('id', leaseId)
			.single()

		if (error || !lease) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NOT_FOUND
				]
			)
		}

		// Authorization check: user must be owner or tenant
		if (!lease.owner_user_id) {
			throw new NotFoundException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.LEASE_NO_OWNER
				]
			)
		}
		const isOwner = lease.property_owner?.user_id === userId

		let isTenant = false
		if (!isOwner) {
			const { data: tenant } = await client
				.from('tenants')
				.select('id')
				.eq('user_id', userId)
				.eq('id', lease.primary_tenant_id)
				.single()
			isTenant = !!tenant
		}

		if (!isOwner && !isTenant) {
			throw new ForbiddenException(
				LEASE_SIGNATURE_ERROR_MESSAGES[
					LEASE_SIGNATURE_ERROR_CODES.NO_ACCESS_TO_LEASE
				]
			)
		}

		// Only active leases have signed documents
		if (lease.lease_status !== 'active') {
			return null
		}

		// Get document URL from DocuSeal
		if (!lease.docuseal_submission_id || !this.docuSealService.isEnabled()) {
			return null
		}

		try {
			const submission = await this.docuSealService.getSubmission(
				parseInt(lease.docuseal_submission_id, 10)
			)
			// Return the first document URL (the signed lease PDF)
			return submission.documents?.[0]?.url || null
		} catch (error) {
			this.logger.error('Failed to get signed document from DocuSeal', {
				error: error instanceof Error ? error.message : String(error),
				leaseId
			})
			return null
		}
	}
}
