import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { apiClient } from '@/lib/api-client'
import { toast } from 'sonner'
import type { MaintenancePriority as Priority } from '@repo/shared'
import type { 
	NotificationData, 
	NotificationRequest, 
	NotificationResponse
} from '@repo/shared/types/notifications'
import { NotificationType } from '@repo/shared/types/notifications'

/**
 * Hook for managing notifications - Direct API client usage (no service wrapper)
 */
export function useNotifications() {
  const queryClient = useQueryClient()
  
  // Get notifications query - Direct API call
  const {
    data: notifications,
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['notifications'],
    queryFn: async () => {
      return apiGet<NotificationData[]>('/notifications')
    }
  })

  // Get unread notifications query - Direct API call
  const {
    data: unreadNotifications,
    isLoading: isLoadingUnread
  } = useQuery({
    queryKey: ['notifications', 'unread'],
    queryFn: async () => {
      return apiGet<NotificationData[]>('/notifications?unreadOnly=true')
    }
  })

  // Create notification mutation - Direct API call
  const createNotificationMutation = useMutation({
    mutationFn: async (notificationData: NotificationRequest): Promise<NotificationResponse> => {
      const payload: NotificationRequest = {
        recipientId: notificationData.recipientId,
        title: notificationData.title || '',
        message: notificationData.message || '',
        type: notificationData.type || NotificationType.INFO,
        priority: notificationData.priority,
        actionUrl: notificationData.actionUrl,
        data: notificationData.data
      }

      const result = await apiMutate('POST',<{ id?: string; success?: boolean }>('/notifications', payload)

      return {
        id: result?.id || `notification_${Date.now()}`,
        sent: true,
        sentAt: new Date().toISOString()
      }
    },
    onSuccess: () => {
      toast.success('Notification sent successfully')
      void queryClient.invalidateQueries({ queryKey: ['notifications'] })
    },
    onError: () => {
      toast.error('Failed to send notification')
    }
  })

  // Mark as read mutation - Direct API call
  const markAsReadMutation = useMutation({
    mutationFn: async (notificationId: string): Promise<void> => {
      await apiMutate('PUT',<void>(`/notifications/${notificationId}/read`)
    },
    onSuccess: () => {
      toast.success('Notification marked as read')
      void queryClient.invalidateQueries({ queryKey: ['notifications'] })
    },
    onError: () => {
      toast.error('Failed to mark notification as read')
    }
  })

  // Create maintenance notification mutation - Direct API call
  const createMaintenanceNotificationMutation = useMutation({
    mutationFn: async ({
      ownerId,
      title,
      description,
      priority,
      propertyName,
      unitNumber,
      maintenanceId,
      actionUrl
    }: {
      ownerId: string
      title: string
      description: string
      priority: Priority
      propertyName: string
      unitNumber: string
      maintenanceId?: string
      actionUrl?: string
    }): Promise<NotificationResponse> => {
      const payload: NotificationRequest = {
        recipientId: ownerId,
        title,
        message: description,
        priority,
        type: NotificationType.MAINTENANCE,
        actionUrl,
        data: {
          propertyName,
          unitNumber,
          maintenanceId,
          requestTitle: title
        }
      }

      const result = await apiMutate('POST',<{ id?: string; success?: boolean }>('/notifications', payload)

      return {
        id: result?.id || `notification_${Date.now()}`,
        sent: true,
        sentAt: new Date().toISOString()
      }
    },
    onSuccess: () => {
      toast.success('Maintenance notification created')
      void queryClient.invalidateQueries({ queryKey: ['notifications'] })
    },
    onError: () => {
      toast.error('Failed to create maintenance notification')
    }
  })

  return {
    // Data
    notifications,
    unreadNotifications,
    
    // Loading states
    isLoading,
    isLoadingUnread,
    
    // Error states
    error,
    
    // Actions
    createNotification: createNotificationMutation.mutate,
    markAsRead: markAsReadMutation.mutate,
    createMaintenanceNotification: createMaintenanceNotificationMutation.mutate,
    refetch,
    
    // Mutation states
    isCreating: createNotificationMutation.isPending,
    isMarkingRead: markAsReadMutation.isPending,
    isCreatingMaintenance: createMaintenanceNotificationMutation.isPending
  }
}