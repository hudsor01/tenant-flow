/**
 * Tests for Maintenance API Hooks
 * Comprehensive test suite covering maintenance request lifecycle, status updates, and vendor assignment
 */

// Jest global functions available automatically from '@jest/globals'

// Mock the API client module
jest.mock('@/lib/api-client')

// Mock shared utilities BEFORE importing them
jest.mock('@repo/shared', () => ({
	...jest.requireActual('@repo/shared'),
	createQueryAdapter: jest.fn(params => params || {}),
	createMutationAdapter: jest.fn(data => data || {})
}))

import { renderHook, waitFor } from '@testing-library/react'
import { apiClient } from '@/lib/api-client'
import { createQueryAdapter, createMutationAdapter } from '@repo/shared'
import {
	useMaintenanceRequests,
	useMaintenanceRequest,
	useCreateMaintenanceRequest,
	useUpdateMaintenanceRequest,
	useDeleteMaintenanceRequest,
	useUpdateMaintenanceStatus,
	useAssignMaintenanceVendor
} from '../use-maintenance'
import {
	createTestQueryClient,
	createHookWrapper,
	mockApiClient,
	createMockApiResponse,
	createMockMaintenanceRequest,
	createApiError,
	expectSuccessToast,
	expectErrorToast,
	setupSuccessfulQuery,
	setupFailedQuery,
	setupSuccessfulMutation,
	setupFailedMutation
} from '@/test/utils/test-utils'

// Setup mocks after imports
const mockApiClientInstance = jest.mocked(apiClient)
Object.assign(mockApiClientInstance, mockApiClient)

// These are already properly mocked in the jest.mock() call above
const _mockedCreateQueryAdapter = jest.mocked(createQueryAdapter)
const _mockedCreateMutationAdapter = jest.mocked(createMutationAdapter)

// Mock toast functions
jest.mock('sonner', () => ({
	toast: {
		success: jest.fn(),
		error: jest.fn(),
		info: jest.fn(),
		warning: jest.fn(),
		promise: jest.fn(),
		dismiss: jest.fn(),
		loading: jest.fn()
	}
}))

describe.skip('Maintenance API Hooks', () => {
	let queryClient: ReturnType<typeof createTestQueryClient>

	beforeEach(() => {
		queryClient = createTestQueryClient()
		jest.clearAllMocks()
	})

	describe.skip('useMaintenanceRequests', () => {
		it('should fetch maintenance requests successfully', async () => {
			const mockRequests = [
				createMockMaintenanceRequest({
					id: 'maint-1',
					title: 'Leaky Faucet',
					priority: 'HIGH'
				}),
				createMockMaintenanceRequest({
					id: 'maint-2',
					title: 'Broken AC',
					priority: 'MEDIUM'
				})
			]

			setupSuccessfulQuery(mockRequests)

			const { result } = renderHook(() => useMaintenanceRequests(), {
				wrapper: createHookWrapper(queryClient)
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data).toEqual(mockRequests)
			expect(mockApiClient.get).toHaveBeenCalledWith('/maintenance', {
				params: {}
			})
		})

		it('should handle query parameters correctly', async () => {
			const mockRequests = [createMockMaintenanceRequest()]
			const queryParams = {
				unitId: 'unit-1',
				status: 'OPEN',
				priority: 'HIGH'
			}

			setupSuccessfulQuery(mockRequests)

			const { result } = renderHook(
				() => useMaintenanceRequests(queryParams),
				{
					wrapper: createHookWrapper(queryClient)
				}
			)

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.get).toHaveBeenCalledWith('/maintenance', {
				params: queryParams
			})
		})

		it('should handle API errors', async () => {
			setupFailedQuery(createApiError(500, 'Server error'))

			const { result } = renderHook(() => useMaintenanceRequests(), {
				wrapper: createHookWrapper(queryClient)
			})

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toBeDefined()
		})

		it('should handle enabled option correctly', async () => {
			const { result } = renderHook(
				() => useMaintenanceRequests(undefined, { enabled: false }),
				{
					wrapper: createHookWrapper(queryClient)
				}
			)

			expect(result.current.isLoading).toBe(false)
			expect(mockApiClient.get).not.toHaveBeenCalled()
		})

		it('should handle empty maintenance requests list', async () => {
			setupSuccessfulQuery([])

			const { result } = renderHook(() => useMaintenanceRequests(), {
				wrapper: createHookWrapper(queryClient)
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data).toEqual([])
		})
	})

	describe.skip('useMaintenanceRequest', () => {
		const mockRequest = createMockMaintenanceRequest({ id: 'maint-1' })

		it('should fetch single maintenance request successfully', async () => {
			setupSuccessfulQuery(mockRequest)

			const { result } = renderHook(
				() => useMaintenanceRequest('maint-1'),
				{
					wrapper: createHookWrapper(queryClient)
				}
			)

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data).toEqual(mockRequest)
			expect(mockApiClient.get).toHaveBeenCalledWith(
				'/maintenance/maint-1'
			)
		})

		it('should not fetch when id is empty', () => {
			const { result } = renderHook(() => useMaintenanceRequest(''), {
				wrapper: createHookWrapper(queryClient)
			})

			expect(result.current.isLoading).toBe(false)
			expect(mockApiClient.get).not.toHaveBeenCalled()
		})

		it('should handle enabled option correctly', () => {
			const { result } = renderHook(
				() => useMaintenanceRequest('maint-1', { enabled: false }),
				{
					wrapper: createHookWrapper(queryClient)
				}
			)

			expect(result.current.isLoading).toBe(false)
			expect(mockApiClient.get).not.toHaveBeenCalled()
		})

		it('should handle 404 errors', async () => {
			setupFailedQuery(
				createApiError(404, 'Maintenance request not found')
			)

			const { result } = renderHook(
				() => useMaintenanceRequest('nonexistent'),
				{
					wrapper: createHookWrapper(queryClient)
				}
			)

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toBeDefined()
		})
	})

	describe.skip('useCreateMaintenanceRequest', () => {
		const newRequest = {
			title: 'AC Not Working',
			description:
				'Air conditioning unit in bedroom not cooling properly',
			priority: 'HIGH' as const,
			unitId: 'unit-1',
			propertyId: 'prop-1',
			allowEntry: true,
			contactPhone: '+1234567890'
		}
		const createdRequest = createMockMaintenanceRequest(newRequest)

		it('should create maintenance request successfully', async () => {
			setupSuccessfulMutation(createdRequest)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate(newRequest)

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.post).toHaveBeenCalledWith(
				'/maintenance',
				newRequest
			)
			expect(result.current.data).toEqual(createdRequest)
			expectSuccessToast('Maintenance request created successfully')
		})

		it('should handle validation errors', async () => {
			const validationError = createApiError(422, 'Title is required')
			setupFailedMutation(validationError)

			const invalidRequest = { ...newRequest, title: '' }
			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate(invalidRequest)

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expectErrorToast('Failed to create maintenance request')
		})

		it('should handle unit not found errors', async () => {
			const notFoundError = createApiError(404, 'Unit not found')
			setupFailedMutation(notFoundError)

			const requestWithInvalidUnit = {
				...newRequest,
				unitId: 'nonexistent'
			}
			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate(requestWithInvalidUnit)

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(notFoundError)
		})

		it('should perform optimistic updates with complete structure', async () => {
			setupSuccessfulMutation(createdRequest)

			// Add some initial data to query cache
			queryClient.setQueryData(
				['tenantflow', 'maintenance', 'list', undefined],
				[]
			)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate(newRequest)

			// Check optimistic update immediately
			const cachedData = queryClient.getQueryData([
				'tenantflow',
				'maintenance',
				'list',
				undefined
			]) as unknown[]
			expect(Array.isArray(cachedData)).toBe(true)

			if (cachedData && cachedData.length > 0) {
				const optimisticRequest = cachedData[0]
				expect(optimisticRequest.title).toBe('AC Not Working')
				expect(optimisticRequest.status).toBe('OPEN')
				expect(optimisticRequest.allowEntry).toBe(true)
				expect(optimisticRequest.assignedTo).toBe(null)
				expect(optimisticRequest.estimatedCost).toBe(null)
				expect(optimisticRequest.actualCost).toBe(null)
				expect(optimisticRequest.completedAt).toBe(null)
				expect(optimisticRequest.photos).toEqual([])
				expect(optimisticRequest.id).toMatch(/^temp-\d+$/)
			}
		})

		it('should handle emergency maintenance requests', async () => {
			const emergencyRequest = createMockMaintenanceRequest({
				...newRequest,
				priority: 'URGENT',
				title: 'Gas Leak Emergency'
			})

			setupSuccessfulMutation(emergencyRequest)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				...newRequest,
				priority: 'URGENT' as const,
				title: 'Gas Leak Emergency'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data?.priority).toBe('URGENT')
		})
	})

	describe.skip('useUpdateMaintenanceRequest', () => {
		const updateData = {
			title: 'AC Repair - Updated',
			description: 'Updated description with more details',
			estimatedCost: 150
		}
		const updatedRequest = createMockMaintenanceRequest({
			...updateData,
			id: 'maint-1'
		})

		it('should update maintenance request successfully', async () => {
			setupSuccessfulMutation(updatedRequest)

			const { result } = renderHook(() => useUpdateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', data: updateData })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.put).toHaveBeenCalledWith(
				'/maintenance/maint-1',
				updateData
			)
			expect(result.current.data).toEqual(updatedRequest)
			expectSuccessToast('Maintenance request updated successfully')
		})

		it('should handle update errors', async () => {
			const error = createApiError(404, 'Maintenance request not found')
			setupFailedMutation(error)

			const { result } = renderHook(() => useUpdateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'nonexistent', data: updateData })

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expectErrorToast('Failed to update maintenance request')
		})

		it('should handle partial updates', async () => {
			const partialUpdate = { estimatedCost: 200 }
			const partiallyUpdatedRequest = createMockMaintenanceRequest({
				...partialUpdate,
				id: 'maint-1'
			})

			mockApiClient.put.mockResolvedValue(
				createMockApiResponse(partiallyUpdatedRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', data: partialUpdate })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.put).toHaveBeenCalledWith(
				'/maintenance/maint-1',
				partialUpdate
			)
		})

		it('should handle cost validation errors', async () => {
			const costValidationError = createApiError(
				422,
				'Estimated cost cannot be negative'
			)
			setupFailedMutation(costValidationError)

			const invalidCostUpdate = { estimatedCost: -100 }
			const { result } = renderHook(() => useUpdateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', data: invalidCostUpdate })

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(costValidationError)
		})
	})

	describe.skip('useDeleteMaintenanceRequest', () => {
		it('should delete maintenance request successfully', async () => {
			mockApiClient.delete.mockResolvedValue({ data: null })

			const { result } = renderHook(() => useDeleteMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate('maint-1')

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.delete).toHaveBeenCalledWith(
				'/maintenance/maint-1'
			)
			expectSuccessToast('Maintenance request deleted successfully')
		})

		it('should handle deletion errors', async () => {
			const error = createApiError(
				409,
				'Cannot delete maintenance request with active work orders'
			)
			mockApiClient.delete.mockRejectedValue(error)

			const { result } = renderHook(() => useDeleteMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate('maint-1')

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expectErrorToast('Failed to delete maintenance request')
		})

		it('should handle in-progress request deletion restrictions', async () => {
			const inProgressError = createApiError(
				409,
				'Cannot delete maintenance request that is in progress'
			)
			mockApiClient.delete.mockRejectedValue(inProgressError)

			const { result } = renderHook(() => useDeleteMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate('maint-1')

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(inProgressError)
		})

		it('should perform optimistic removal', async () => {
			mockApiClient.delete.mockResolvedValue({ data: null })

			// Set up initial cache with some maintenance requests
			const initialRequests = [
				createMockMaintenanceRequest({ id: 'maint-1' }),
				createMockMaintenanceRequest({ id: 'maint-2' })
			]
			queryClient.setQueryData(
				['tenantflow', 'maintenance', 'list', undefined],
				initialRequests
			)

			const { result } = renderHook(() => useDeleteMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate('maint-1')

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			// Check that request was removed from cache
			const cachedData = queryClient.getQueryData([
				'tenantflow',
				'maintenance',
				'list',
				undefined
			]) as Array<{ id: string }> | undefined
			if (cachedData) {
				expect(cachedData).toHaveLength(1)
				expect(cachedData[0].id).toBe('maint-2')
			} else {
				// If optimistic removal isn't working, the query should still succeed
				expect(result.current.isSuccess).toBe(true)
			}
		})
	})

	describe.skip('useUpdateMaintenanceStatus', () => {
		it('should update status to IN_PROGRESS successfully', async () => {
			const inProgressRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'IN_PROGRESS'
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(inProgressRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'IN_PROGRESS' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.patch).toHaveBeenCalledWith(
				'/maintenance/maint-1/status',
				{
					status: 'IN_PROGRESS'
				}
			)
			expect(result.current.data).toEqual(inProgressRequest)
			expectSuccessToast('Request marked as in progress')
		})

		it('should update status to COMPLETED successfully', async () => {
			const completedRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'COMPLETED',
				completedAt: new Date().toISOString()
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(completedRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'COMPLETED' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expectSuccessToast('Request marked as completed')
		})

		it('should update status to CANCELED successfully', async () => {
			const canceledRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'CANCELED'
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(canceledRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'CANCELED' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expectSuccessToast('Request cancelled')
		})

		it('should handle status update errors', async () => {
			const error = createApiError(400, 'Invalid status transition')
			mockApiClient.patch.mockRejectedValue(error)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'COMPLETED' })

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expectErrorToast('Failed to update status')
		})

		it('should handle legacy status values', async () => {
			const legacyStatusRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'in_progress' as unknown // Legacy lowercase value
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(legacyStatusRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				status: 'in_progress' as unknown
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expectSuccessToast('Request marked as in progress')
		})

		it('should handle unknown status gracefully', async () => {
			const unknownStatusRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'UNKNOWN_STATUS' as unknown
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(unknownStatusRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				status: 'UNKNOWN_STATUS' as unknown
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expectSuccessToast('Request status updated') // Default message
		})

		it('should handle dynamic toast import properly', async () => {
			const updatedRequest = createMockMaintenanceRequest({
				id: 'maint-1',
				status: 'COMPLETED'
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(updatedRequest)
			)

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'COMPLETED' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			// The hook should import sonner dynamically and call toast.success
			const sonner = await import('sonner')
			expect(sonner.toast.success).toHaveBeenCalledWith(
				'Request marked as completed'
			)
		})
	})

	describe.skip('useAssignMaintenanceVendor', () => {
		const assignedRequest = createMockMaintenanceRequest({
			id: 'maint-1',
			assignedTo: 'vendor-1'
		})

		it('should assign vendor successfully', async () => {
			setupSuccessfulMutation(assignedRequest)

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				vendorId: 'vendor-1',
				notes: 'Assigned to preferred HVAC contractor'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.post).toHaveBeenCalledWith(
				'/maintenance/maint-1/assign',
				{
					vendorId: 'vendor-1',
					notes: 'Assigned to preferred HVAC contractor'
				}
			)
			expect(result.current.data).toEqual(assignedRequest)
			expectSuccessToast('Vendor assigned successfully')
		})

		it('should assign vendor without notes', async () => {
			setupSuccessfulMutation(assignedRequest)

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				vendorId: 'vendor-1'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(mockApiClient.post).toHaveBeenCalledWith(
				'/maintenance/maint-1/assign',
				{
					vendorId: 'vendor-1',
					notes: undefined
				}
			)
		})

		it('should handle vendor assignment errors', async () => {
			const error = createApiError(404, 'Vendor not found')
			setupFailedMutation(error)

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				vendorId: 'nonexistent-vendor'
			})

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expectErrorToast('Failed to assign vendor')
		})

		it('should handle already assigned errors', async () => {
			const alreadyAssignedError = createApiError(
				409,
				'Maintenance request is already assigned'
			)
			setupFailedMutation(alreadyAssignedError)

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				vendorId: 'vendor-2'
			})

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(alreadyAssignedError)
		})

		it('should handle completed request assignment errors', async () => {
			const completedError = createApiError(
				400,
				'Cannot assign vendor to completed request'
			)
			setupFailedMutation(completedError)

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-completed',
				vendorId: 'vendor-1'
			})

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(completedError)
		})
	})

	describe.skip('Edge Cases and Error Scenarios', () => {
		it('should handle malformed maintenance request data', async () => {
			const malformedRequest = {
				title: '', // Empty required field
				description: 'A'.repeat(10000), // Very long description
				priority: 'INVALID' as unknown, // Invalid priority
				unitId: 'unit-1',
				propertyId: 'prop-1',
				allowEntry: 'yes' as unknown, // Wrong data type
				contactPhone: 'invalid-phone' // Invalid phone format
			}

			const validationError = createApiError(
				422,
				'Invalid maintenance request data'
			)
			setupFailedMutation(validationError)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate(malformedRequest)

			await waitFor(() => {
				expect(result.current.isError).toBe(true)
			})

			expect(result.current.error).toEqual(validationError)
		})

		it('should handle special characters in maintenance requests', async () => {
			const specialCharsRequest = createMockMaintenanceRequest({
				title: 'Repair "Smart" Lock & Café Entrance',
				description:
					'The "smart" lock at the café entrance isn\'t responding. Need to fix ASAP! Cost: €150-200.',
				notes: 'Special instructions: Use código 1234 🔑'
			})

			setupSuccessfulMutation(specialCharsRequest)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				title: 'Repair "Smart" Lock & Café Entrance',
				description:
					'The "smart" lock at the café entrance isn\'t responding. Need to fix ASAP! Cost: €150-200.',
				priority: 'HIGH' as const,
				unitId: 'unit-1',
				propertyId: 'prop-1'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data).toEqual(specialCharsRequest)
		})

		it('should handle extremely high-priority maintenance requests', async () => {
			const emergencyRequest = createMockMaintenanceRequest({
				title: 'EMERGENCY: Water Leak in Electrical Room',
				priority: 'URGENT',
				description:
					'Major water leak near electrical panel. Immediate attention required.'
			})

			setupSuccessfulMutation(emergencyRequest)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				title: 'EMERGENCY: Water Leak in Electrical Room',
				description:
					'Major water leak near electrical panel. Immediate attention required.',
				priority: 'URGENT' as const,
				unitId: 'unit-1',
				propertyId: 'prop-1',
				allowEntry: true
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data?.priority).toBe('URGENT')
		})

		it('should handle concurrent maintenance operations', async () => {
			const request1 = createMockMaintenanceRequest({
				id: 'maint-1',
				title: 'Request 1'
			})
			const request2 = createMockMaintenanceRequest({
				id: 'maint-2',
				title: 'Request 2'
			})

			mockApiClient.post
				.mockResolvedValueOnce(createMockApiResponse(request1))
				.mockResolvedValueOnce(createMockApiResponse(request2))

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			// Start two mutations concurrently
			const mutation1 = result.current.mutateAsync({
				title: 'Request 1',
				description: 'First request',
				priority: 'MEDIUM' as const,
				unitId: 'unit-1',
				propertyId: 'prop-1'
			})

			const mutation2 = result.current.mutateAsync({
				title: 'Request 2',
				description: 'Second request',
				priority: 'LOW' as const,
				unitId: 'unit-2',
				propertyId: 'prop-1'
			})

			const results = await Promise.all([mutation1, mutation2])

			expect(results[0]).toEqual(request1)
			expect(results[1]).toEqual(request2)
			expect(mockApiClient.post).toHaveBeenCalledTimes(2)
		})

		it('should handle maintenance requests with photo uploads', async () => {
			const requestWithPhotos = createMockMaintenanceRequest({
				title: 'Damaged Wall - Photos Attached',
				photos: ['photo1.jpg', 'photo2.jpg']
			})

			setupSuccessfulMutation(requestWithPhotos)

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				title: 'Damaged Wall - Photos Attached',
				description: 'Wall damage in living room, photos attached',
				priority: 'MEDIUM' as const,
				unitId: 'unit-1',
				propertyId: 'prop-1'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data?.photos).toEqual([
				'photo1.jpg',
				'photo2.jpg'
			])
		})

		it('should handle large-scale property maintenance lists', async () => {
			const largeMaintenanceList = Array.from({ length: 200 }, (_, i) =>
				createMockMaintenanceRequest({
					id: `maint-${i}`,
					title: `Maintenance Request ${i}`,
					priority:
						i % 3 === 0 ? 'HIGH' : i % 2 === 0 ? 'MEDIUM' : 'LOW'
				})
			)

			setupSuccessfulQuery(largeMaintenanceList)

			const { result } = renderHook(() => useMaintenanceRequests(), {
				wrapper: createHookWrapper(queryClient)
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(result.current.data).toHaveLength(200)
			expect(result.current.data![0].title).toBe('Maintenance Request 0')
			expect(result.current.data![199].title).toBe(
				'Maintenance Request 199'
			)
		})
	})

	describe.skip('Cache Invalidation', () => {
		it('should invalidate maintenance queries after creation', async () => {
			setupSuccessfulMutation(createMockMaintenanceRequest())

			const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries')

			const { result } = renderHook(() => useCreateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				title: 'Test Request',
				description: 'Test description',
				priority: 'MEDIUM' as const,
				unitId: 'unit-1',
				propertyId: 'prop-1'
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(invalidateSpy).toHaveBeenCalledWith({
				queryKey: ['tenantflow', 'maintenance']
			})
		})

		it('should invalidate maintenance queries after update', async () => {
			setupSuccessfulMutation(createMockMaintenanceRequest())

			const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries')

			const { result } = renderHook(() => useUpdateMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({
				id: 'maint-1',
				data: { title: 'Updated Title' }
			})

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(invalidateSpy).toHaveBeenCalledWith({
				queryKey: ['tenantflow', 'maintenance']
			})
		})

		it('should invalidate maintenance queries after deletion', async () => {
			mockApiClient.delete.mockResolvedValue({ data: null })

			const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries')

			const { result } = renderHook(() => useDeleteMaintenanceRequest(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate('maint-1')

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(invalidateSpy).toHaveBeenCalledWith({
				queryKey: ['tenantflow', 'maintenance']
			})
		})

		it('should invalidate maintenance queries after status update', async () => {
			const updatedRequest = createMockMaintenanceRequest({
				status: 'COMPLETED'
			})
			mockApiClient.patch.mockResolvedValue(
				createMockApiResponse(updatedRequest)
			)

			const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries')

			const { result } = renderHook(() => useUpdateMaintenanceStatus(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', status: 'COMPLETED' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(invalidateSpy).toHaveBeenCalledWith({
				queryKey: ['tenantflow', 'maintenance']
			})
		})

		it('should invalidate maintenance queries after vendor assignment', async () => {
			const assignedRequest = createMockMaintenanceRequest({
				assignedTo: 'vendor-1'
			})
			mockApiClient.post.mockResolvedValue(
				createMockApiResponse(assignedRequest)
			)

			const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries')

			const { result } = renderHook(() => useAssignMaintenanceVendor(), {
				wrapper: createHookWrapper(queryClient)
			})

			result.current.mutate({ id: 'maint-1', vendorId: 'vendor-1' })

			await waitFor(() => {
				expect(result.current.isSuccess).toBe(true)
			})

			expect(invalidateSpy).toHaveBeenCalledWith({
				queryKey: ['tenantflow', 'maintenance']
			})
		})
	})
})
