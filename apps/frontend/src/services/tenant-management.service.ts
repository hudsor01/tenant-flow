/**
 * Tenant Management Service
 *
 * Encapsulates tenant management business logic, including validation,
 * communication tracking, and lease relationships.
 */

import type {
	Tenant,
	CreateTenantInput,
	UpdateTenantInput,
	Lease,
	Result
} from '@repo/shared'
import type {
	TenantRepository,
	LeaseRepository
} from '@/repositories/interfaces'
import { Email, PhoneNumber, DomainError, ValidationError } from '@repo/shared'

export interface TenantManagementService {
	getTenant(id: string): Promise<Result<Tenant>>
	getAllTenants(): Promise<Result<Tenant[]>>
	getTenantsByProperty(propertyId: string): Promise<Result<Tenant[]>>
	createTenant(input: CreateTenantInput): Promise<Result<Tenant>>
	updateTenant(id: string, input: UpdateTenantInput): Promise<Result<Tenant>>
	deleteTenant(id: string): Promise<Result<void>>
	getTenantLeases(tenantId: string): Promise<Result<Lease[]>>
	findTenantByEmail(email: string): Promise<Result<Tenant | null>>
	getExpiringSoonTenants(days: number): Promise<Result<Tenant[]>>
	validateTenantData(
		input: CreateTenantInput | UpdateTenantInput
	): Result<void>
	canDeleteTenant(tenantId: string): Promise<Result<boolean>>
}

interface TenantBusinessRules {
	maxNameLength: number
	maxNotesLength: number
	minAge: number
	maxTenantsPerUnit: number
	requiredFields: (keyof CreateTenantInput)[]
	allowedContactMethods: string[]
}

export class DefaultTenantManagementService implements TenantManagementService {
	private readonly businessRules: TenantBusinessRules = {
		maxNameLength: 100,
		maxNotesLength: 1000,
		minAge: 18,
		maxTenantsPerUnit: 10,
		requiredFields: ['name', 'email'],
		allowedContactMethods: ['email', 'phone', 'text', 'mail']
	}

	constructor(
		private readonly tenantRepository: TenantRepository,
		private readonly leaseRepository?: LeaseRepository
	) {}

	async getTenant(id: string): Promise<Result<Tenant>> {
		if (!id?.trim()) {
			return {
				success: false,
				error: new ValidationError('Tenant ID is required')
			}
		}

		try {
			const tenant = await this.tenantRepository.findById(id)

			if (!tenant) {
				return {
					success: false,
					error: new DomainError(`Tenant with ID ${id} not found`)
				}
			}

			return {
				success: true,
				value: tenant
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to get tenant')
			}
		}
	}

	async getAllTenants(): Promise<Result<Tenant[]>> {
		try {
			const tenants = await this.tenantRepository.findMany()
			return {
				success: true,
				value: tenants
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to fetch tenants')
			}
		}
	}

	async getTenantsByProperty(propertyId: string): Promise<Result<Tenant[]>> {
		if (!propertyId?.trim()) {
			return {
				success: false,
				error: new ValidationError('Property ID is required')
			}
		}

		try {
			const tenants =
				await this.tenantRepository.findByProperty(propertyId)
			return {
				success: true,
				value: tenants
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError(
								'Failed to fetch tenants for property'
							)
			}
		}
	}

	async createTenant(input: CreateTenantInput): Promise<Result<Tenant>> {
		// Validate input
		const validation = this.validateTenantData(input)
		if (!validation.success) {
			return validation
		}

		// Check for duplicate email
		const existingTenant = await this.findTenantByEmail(input.email)
		if (existingTenant.success && existingTenant.value) {
			return {
				success: false,
				error: new DomainError(
					`A tenant with email ${input.email} already exists`
				)
			}
		}

		// Apply business rules
		const businessRuleCheck = this.checkBusinessRules(input)
		if (!businessRuleCheck.success) {
			return businessRuleCheck
		}

		// Normalize and enhance input
		const normalizedInput = this.normalizeTenantData(input)

		try {
			const tenant = await this.tenantRepository.save({
				...normalizedInput,
				id: '', // Will be generated by repository
				createdAt: new Date(),
				updatedAt: new Date()
			} as Tenant)

			return {
				success: true,
				value: tenant
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to create tenant')
			}
		}
	}

	async updateTenant(
		id: string,
		input: UpdateTenantInput
	): Promise<Result<Tenant>> {
		if (!id?.trim()) {
			return {
				success: false,
				error: new ValidationError('Tenant ID is required')
			}
		}

		// Validate input
		const validation = this.validateTenantData(input)
		if (!validation.success) {
			return validation
		}

		// Check if tenant exists
		const existingTenant = await this.getTenant(id)
		if (!existingTenant.success) {
			return existingTenant
		}

		// Check for duplicate email if email is being changed
		if (input.email && input.email !== existingTenant.value.email) {
			const duplicateCheck = await this.findTenantByEmail(input.email)
			if (duplicateCheck.success && duplicateCheck.value) {
				return {
					success: false,
					error: new DomainError(
						`A tenant with email ${input.email} already exists`
					)
				}
			}
		}

		// Apply business rules
		const businessRuleCheck = this.checkBusinessRules(input)
		if (!businessRuleCheck.success) {
			return businessRuleCheck
		}

		// Normalize input and merge with existing data
		const normalizedInput = this.normalizeTenantData(input)
		const updatedTenant: Tenant = {
			...existingTenant.value,
			...normalizedInput,
			updatedAt: new Date()
		}

		try {
			const tenant = await this.tenantRepository.save(updatedTenant)
			return {
				success: true,
				value: tenant
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to update tenant')
			}
		}
	}

	async deleteTenant(id: string): Promise<Result<void>> {
		if (!id?.trim()) {
			return {
				success: false,
				error: new ValidationError('Tenant ID is required')
			}
		}

		// Check if tenant exists
		const existingTenant = await this.getTenant(id)
		if (!existingTenant.success) {
			return {
				success: false,
				error: existingTenant.error
			}
		}

		// Check if tenant can be deleted
		const canDelete = await this.canDeleteTenant(id)
		if (!canDelete.success) {
			return {
				success: false,
				error: canDelete.error
			}
		}

		if (!canDelete.value) {
			return {
				success: false,
				error: new DomainError(
					'Cannot delete tenant with active leases. Please terminate all leases first.'
				)
			}
		}

		try {
			await this.tenantRepository.delete(id)
			return {
				success: true,
				value: undefined
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to delete tenant')
			}
		}
	}

	async getTenantLeases(tenantId: string): Promise<Result<Lease[]>> {
		if (!this.leaseRepository) {
			return {
				success: false,
				error: new DomainError('Lease repository not available')
			}
		}

		if (!tenantId?.trim()) {
			return {
				success: false,
				error: new ValidationError('Tenant ID is required')
			}
		}

		try {
			const leases = await this.leaseRepository.findByTenant(tenantId)
			return {
				success: true,
				value: leases
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to fetch tenant leases')
			}
		}
	}

	async findTenantByEmail(email: string): Promise<Result<Tenant | null>> {
		if (!email?.trim()) {
			return {
				success: false,
				error: new ValidationError('Email is required')
			}
		}

		// Validate email format
		try {
			new Email(email)
		} catch {
			return {
				success: false,
				error: new ValidationError('Invalid email format')
			}
		}

		try {
			const tenant = await this.tenantRepository.findByEmail(
				email.toLowerCase().trim()
			)
			return {
				success: true,
				value: tenant
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to find tenant by email')
			}
		}
	}

	async getExpiringSoonTenants(days = 30): Promise<Result<Tenant[]>> {
		if (days < 1 || days > 365) {
			return {
				success: false,
				error: new ValidationError('Days must be between 1 and 365')
			}
		}

		try {
			const tenants =
				await this.tenantRepository.findExpiringSoonTenants(days)
			return {
				success: true,
				value: tenants
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError('Failed to fetch expiring tenants')
			}
		}
	}

	validateTenantData(
		input: CreateTenantInput | UpdateTenantInput
	): Result<void> {
		const errors: string[] = []

		// Validate name
		if ('name' in input && input.name !== undefined) {
			if (!input.name?.trim()) {
				errors.push('Name is required')
			} else if (input.name.length > this.businessRules.maxNameLength) {
				errors.push(
					`Name cannot exceed ${this.businessRules.maxNameLength} characters`
				)
			}
		}

		// Validate email
		if ('email' in input && input.email !== undefined) {
			if (!input.email?.trim()) {
				errors.push('Email is required')
			} else {
				try {
					new Email(input.email)
				} catch {
					errors.push('Please enter a valid email address')
				}
			}
		}

		// Validate phone number if provided
		if ('phone' in input && input.phone) {
			try {
				new PhoneNumber(input.phone)
			} catch {
				errors.push('Please enter a valid phone number')
			}
		}

		// Validate notes length if provided
		if ('notes' in input && input.notes) {
			if (input.notes.length > this.businessRules.maxNotesLength) {
				errors.push(
					`Notes cannot exceed ${this.businessRules.maxNotesLength} characters`
				)
			}
		}

		// Validate emergency contact if provided (simple string validation)
		if ('emergencyContact' in input && input.emergencyContact) {
			if (
				input.emergencyContact.length > this.businessRules.maxNameLength
			) {
				errors.push(
					`Emergency contact cannot exceed ${this.businessRules.maxNameLength} characters`
				)
			}
		}

		if (errors.length > 0) {
			return {
				success: false,
				error: new ValidationError(errors.join('; '))
			}
		}

		return { success: true, value: undefined }
	}

	async canDeleteTenant(tenantId: string): Promise<Result<boolean>> {
		if (!this.leaseRepository) {
			return {
				success: true,
				value: true // Allow deletion if we can't check leases
			}
		}

		try {
			const leases = await this.leaseRepository.findByTenant(tenantId)
			const activeLeases = leases.filter(
				lease => lease.status === 'active' || lease.status === 'pending'
			)

			return {
				success: true,
				value: activeLeases.length === 0
			}
		} catch (error) {
			return {
				success: false,
				error:
					error instanceof Error
						? error
						: new DomainError(
								'Failed to check tenant deletion eligibility'
							)
			}
		}
	}

	// Private helper methods

	private checkBusinessRules(
		_input: CreateTenantInput | UpdateTenantInput
	): Result<void> {
		// Add specific business rules here
		// For example: Credit score requirements, background check status, etc.

		return { success: true, value: undefined }
	}

	private normalizeTenantData(
		input: CreateTenantInput | UpdateTenantInput
	): CreateTenantInput | UpdateTenantInput {
		return {
			...input,
			name: input.name?.trim(),
			email: input.email?.toLowerCase().trim(),
			phone: input.phone?.replace(/\D/g, ''), // Remove non-digits for storage
			notes: input.notes?.trim(),
			emergencyContact: input.emergencyContact?.trim()
		}
	}

	private calculateAge(dateOfBirth: Date | string): number {
		const birthDate = new Date(dateOfBirth)
		const today = new Date()
		let age = today.getFullYear() - birthDate.getFullYear()
		const monthDiff = today.getMonth() - birthDate.getMonth()

		if (
			monthDiff < 0 ||
			(monthDiff === 0 && today.getDate() < birthDate.getDate())
		) {
			age--
		}

		return age
	}

	// Business logic helper methods

	public getFullName(tenant: Tenant): string {
		return tenant.name.trim()
	}

	public formatPhone(phone?: string): string {
		if (!phone) return ''

		// Format as (XXX) XXX-XXXX
		const cleaned = phone.replace(/\D/g, '')
		if (cleaned.length === 10) {
			return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`
		}
		return phone
	}

	public getTenantAge(_tenant: Tenant): number | null {
		// Age information is not available in the current Tenant type
		return null
	}

	public hasActiveLeases(_tenant: Tenant): boolean {
		// Lease information is not directly available on the Tenant type
		// This would need to be checked through the lease repository
		return false
	}
}
