/**
 * Tenant Management Service
 * 
 * Encapsulates tenant management business logic, including validation,
 * communication tracking, and lease relationships.
 */

import type { 
  Tenant, 
  CreateTenantInput, 
  UpdateTenantInput,
  Lease,
  Result
} from '@repo/shared';
import type { 
  TenantRepository,
  LeaseRepository 
} from '@/repositories/interfaces';
import { Email, PhoneNumber, DomainError, ValidationError } from '@repo/shared';

export interface TenantManagementService {
  getTenant(id: string): Promise<Result<Tenant>>;
  getAllTenants(): Promise<Result<Tenant[]>>;
  getTenantsByProperty(propertyId: string): Promise<Result<Tenant[]>>;
  createTenant(input: CreateTenantInput): Promise<Result<Tenant>>;
  updateTenant(id: string, input: UpdateTenantInput): Promise<Result<Tenant>>;
  deleteTenant(id: string): Promise<Result<void>>;
  getTenantLeases(tenantId: string): Promise<Result<Lease[]>>;
  findTenantByEmail(email: string): Promise<Result<Tenant | null>>;
  getExpiringSoonTenants(days: number): Promise<Result<Tenant[]>>;
  validateTenantData(input: CreateTenantInput | UpdateTenantInput): Result<void>;
  canDeleteTenant(tenantId: string): Promise<Result<boolean>>;
}

interface TenantBusinessRules {
  maxNameLength: number;
  maxNotesLength: number;
  minAge: number;
  maxTenantsPerUnit: number;
  requiredFields: (keyof CreateTenantInput)[];
  allowedContactMethods: string[];
}

export class DefaultTenantManagementService implements TenantManagementService {
  private readonly businessRules: TenantBusinessRules = {
    maxNameLength: 100,
    maxNotesLength: 1000,
    minAge: 18,
    maxTenantsPerUnit: 10,
    requiredFields: ['name', 'email'],
    allowedContactMethods: ['email', 'phone', 'text', 'mail'],
  };

  constructor(
    private readonly tenantRepository: TenantRepository,
    private readonly leaseRepository?: LeaseRepository
  ) {}

  async getTenant(id: string): Promise<Result<Tenant>> {
    if (!id?.trim()) {
      return {
        success: false,
        error: new ValidationError('Tenant ID is required'),
      };
    }

    try {
      const tenant = await this.tenantRepository.findById(id);
      
      if (!tenant) {
        return {
          success: false,
          error: new DomainError(`Tenant with ID ${id} not found`),
        };
      }

      return {
        success: true,
        value: tenant,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to get tenant'),
      };
    }
  }

  async getAllTenants(): Promise<Result<Tenant[]>> {
    try {
      const tenants = await this.tenantRepository.findMany();
      return {
        success: true,
        value: tenants,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to fetch tenants'),
      };
    }
  }

  async getTenantsByProperty(propertyId: string): Promise<Result<Tenant[]>> {
    if (!propertyId?.trim()) {
      return {
        success: false,
        error: new ValidationError('Property ID is required'),
      };
    }

    try {
      const tenants = await this.tenantRepository.findByProperty(propertyId);
      return {
        success: true,
        value: tenants,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to fetch tenants for property'),
      };
    }
  }

  async createTenant(input: CreateTenantInput): Promise<Result<Tenant>> {
    // Validate input
    const validation = this.validateTenantData(input);
    if (!validation.success) {
      return validation;
    }

    // Check for duplicate email
    const existingTenant = await this.findTenantByEmail(input.email);
    if (existingTenant.success && existingTenant.value) {
      return {
        success: false,
        error: new DomainError(`A tenant with email ${input.email} already exists`),
      };
    }

    // Apply business rules
    const businessRuleCheck = this.checkBusinessRules(input);
    if (!businessRuleCheck.success) {
      return businessRuleCheck;
    }

    // Normalize and enhance input
    const normalizedInput = this.normalizeTenantData(input);

    try {
      const tenant = await this.tenantRepository.save({
        ...normalizedInput,
        id: '', // Will be generated by repository
        createdAt: new Date(),
        updatedAt: new Date(),
      } as Tenant);

      return {
        success: true,
        value: tenant,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to create tenant'),
      };
    }
  }

  async updateTenant(id: string, input: UpdateTenantInput): Promise<Result<Tenant>> {
    if (!id?.trim()) {
      return {
        success: false,
        error: new ValidationError('Tenant ID is required'),
      };
    }

    // Validate input
    const validation = this.validateTenantData(input);
    if (!validation.success) {
      return validation;
    }

    // Check if tenant exists
    const existingTenant = await this.getTenant(id);
    if (!existingTenant.success) {
      return existingTenant;
    }

    // Check for duplicate email if email is being changed
    if (input.email && input.email !== existingTenant.value.email) {
      const duplicateCheck = await this.findTenantByEmail(input.email);
      if (duplicateCheck.success && duplicateCheck.value) {
        return {
          success: false,
          error: new DomainError(`A tenant with email ${input.email} already exists`),
        };
      }
    }

    // Apply business rules
    const businessRuleCheck = this.checkBusinessRules(input);
    if (!businessRuleCheck.success) {
      return businessRuleCheck;
    }

    // Normalize input and merge with existing data
    const normalizedInput = this.normalizeTenantData(input);
    const updatedTenant: Tenant = {
      ...existingTenant.value,
      ...normalizedInput,
      updatedAt: new Date(),
    };

    try {
      const tenant = await this.tenantRepository.save(updatedTenant);
      return {
        success: true,
        value: tenant,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to update tenant'),
      };
    }
  }

  async deleteTenant(id: string): Promise<Result<void>> {
    if (!id?.trim()) {
      return {
        success: false,
        error: new ValidationError('Tenant ID is required'),
      };
    }

    // Check if tenant exists
    const existingTenant = await this.getTenant(id);
    if (!existingTenant.success) {
      return {
        success: false,
        error: existingTenant.error,
      };
    }

    // Check if tenant can be deleted
    const canDelete = await this.canDeleteTenant(id);
    if (!canDelete.success) {
      return {
        success: false,
        error: canDelete.error,
      };
    }

    if (!canDelete.value) {
      return {
        success: false,
        error: new DomainError('Cannot delete tenant with active leases. Please terminate all leases first.'),
      };
    }

    try {
      await this.tenantRepository.delete(id);
      return {
        success: true,
        value: undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to delete tenant'),
      };
    }
  }

  async getTenantLeases(tenantId: string): Promise<Result<Lease[]>> {
    if (!this.leaseRepository) {
      return {
        success: false,
        error: new DomainError('Lease repository not available'),
      };
    }

    if (!tenantId?.trim()) {
      return {
        success: false,
        error: new ValidationError('Tenant ID is required'),
      };
    }

    try {
      const leases = await this.leaseRepository.findByTenant(tenantId);
      return {
        success: true,
        value: leases,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to fetch tenant leases'),
      };
    }
  }

  async findTenantByEmail(email: string): Promise<Result<Tenant | null>> {
    if (!email?.trim()) {
      return {
        success: false,
        error: new ValidationError('Email is required'),
      };
    }

    // Validate email format
    try {
      new Email(email);
    } catch {
      return {
        success: false,
        error: new ValidationError('Invalid email format'),
      };
    }

    try {
      const tenant = await this.tenantRepository.findByEmail(email.toLowerCase().trim());
      return {
        success: true,
        value: tenant,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to find tenant by email'),
      };
    }
  }

  async getExpiringSoonTenants(days = 30): Promise<Result<Tenant[]>> {
    if (days < 1 || days > 365) {
      return {
        success: false,
        error: new ValidationError('Days must be between 1 and 365'),
      };
    }

    try {
      const tenants = await this.tenantRepository.findExpiringSoonTenants(days);
      return {
        success: true,
        value: tenants,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to fetch expiring tenants'),
      };
    }
  }

  validateTenantData(input: CreateTenantInput | UpdateTenantInput): Result<void> {
    const errors: string[] = [];

    // Validate name
    if ('name' in input && input.name !== undefined) {
      if (!input.name?.trim()) {
        errors.push('Name is required');
      } else if (input.name.length > this.businessRules.maxNameLength) {
        errors.push(`Name cannot exceed ${this.businessRules.maxNameLength} characters`);
      }
    }

    // Validate email
    if ('email' in input && input.email !== undefined) {
      if (!input.email?.trim()) {
        errors.push('Email is required');
      } else {
        try {
          new Email(input.email);
        } catch {
          errors.push('Please enter a valid email address');
        }
      }
    }

    // Validate phone number if provided
    if ('phone' in input && input.phone) {
      try {
        new PhoneNumber(input.phone);
      } catch {
        errors.push('Please enter a valid phone number');
      }
    }

    // Validate notes length if provided
    if ('notes' in input && input.notes) {
      if (input.notes.length > this.businessRules.maxNotesLength) {
        errors.push(`Notes cannot exceed ${this.businessRules.maxNotesLength} characters`);
      }
    }

    // Validate emergency contact if provided (simple string validation)
    if ('emergencyContact' in input && input.emergencyContact) {
      if (input.emergencyContact.length > this.businessRules.maxNameLength) {
        errors.push(`Emergency contact cannot exceed ${this.businessRules.maxNameLength} characters`);
      }
    }

    if (errors.length > 0) {
      return {
        success: false,
        error: new ValidationError(errors.join('; ')),
      };
    }

    return { success: true, value: undefined };
  }

  async canDeleteTenant(tenantId: string): Promise<Result<boolean>> {
    if (!this.leaseRepository) {
      return {
        success: true,
        value: true, // Allow deletion if we can't check leases
      };
    }

    try {
      const leases = await this.leaseRepository.findByTenant(tenantId);
      const activeLeases = leases.filter(lease => 
        lease.status === 'active' || lease.status === 'pending'
      );
      
      return {
        success: true,
        value: activeLeases.length === 0,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new DomainError('Failed to check tenant deletion eligibility'),
      };
    }
  }

  // Private helper methods

  private checkBusinessRules(_input: CreateTenantInput | UpdateTenantInput): Result<void> {
    // Add specific business rules here
    // For example: Credit score requirements, background check status, etc.
    
    return { success: true, value: undefined };
  }

  private normalizeTenantData(input: CreateTenantInput | UpdateTenantInput): CreateTenantInput | UpdateTenantInput {
    return {
      ...input,
      name: input.name?.trim(),
      email: input.email?.toLowerCase().trim(),
      phone: input.phone?.replace(/\D/g, ''), // Remove non-digits for storage
      notes: input.notes?.trim(),
      emergencyContact: input.emergencyContact?.trim(),
    };
  }

  private calculateAge(dateOfBirth: Date | string): number {
    const birthDate = new Date(dateOfBirth);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  }

  // Business logic helper methods

  public getFullName(tenant: Tenant): string {
    return tenant.name.trim();
  }

  public formatPhone(phone?: string): string {
    if (!phone) return '';
    
    // Format as (XXX) XXX-XXXX
    const cleaned = phone.replace(/\D/g, '');
    if (cleaned.length === 10) {
      return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
    }
    return phone;
  }

  public getTenantAge(_tenant: Tenant): number | null {
    // Age information is not available in the current Tenant type
    return null;
  }

  public hasActiveLeases(_tenant: Tenant): boolean {
    // Lease information is not directly available on the Tenant type
    // This would need to be checked through the lease repository
    return false;
  }
}