/**
 * Backend API Integration Tests - Production Ready
 * Tests your actual NestJS backend endpoints with real data structures
 */

import { test, expect } from '@playwright/test'

// Your actual backend configuration
const BACKEND_CONFIG = {
	baseURL: process.env.BACKEND_URL || 'http://localhost:3002',
	timeout: 15000 // Backend may be slower than frontend
}

// Your actual plan types from shared package
const PLAN_TYPES = {
	FREETRIAL: 'FREETRIAL',
	STARTER: 'STARTER',
	GROWTH: 'GROWTH',
	TENANTFLOW_MAX: 'TENANTFLOW_MAX'
} as const

// Test user for authenticated requests
const TEST_USER = {
	id: 'test-user-id',
	email: 'test@example.com',
	stripeCustomerId: 'cus_test_customer',
	token: 'mock-jwt-token' // Would be real JWT in actual test
}

test.describe('Backend Health and Configuration', () => {
	test('Backend server is running and healthy', async ({ request }) => {
		const response = await request.get(`${BACKEND_CONFIG.baseURL}/health`)

		expect(response.ok()).toBeTruthy()

		const healthData = await response.json()
		expect(healthData).toHaveProperty('status', 'ok')
		expect(healthData).toHaveProperty('uptime')
		expect(healthData).toHaveProperty('timestamp')

		console.log('✅ Backend server is healthy')
	})

	test('Stripe configuration is valid', async ({ request }) => {
		// Test that backend has Stripe configured
		// This endpoint should exist if Stripe is properly configured
		const response = await request.get(`${BACKEND_CONFIG.baseURL}/`, {
			timeout: BACKEND_CONFIG.timeout
		})

		expect(response.ok()).toBeTruthy()

		const data = await response.json()
		expect(data).toHaveProperty('service', 'tenantflow-backend')

		console.log('✅ Backend Stripe configuration accessible')
	})
})

test.describe('Stripe Checkout Controller - /stripe endpoints', () => {
	test('POST /stripe/create-checkout-session - Unauthenticated User', async ({
		request
	}) => {
		const checkoutData = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl:
				'http://localhost:3000/billing/success?session_id={CHECKOUT_SESSION_ID}',
			cancelUrl: 'http://localhost:3000/pricing'
			// No customerId or customerEmail for unauthenticated user
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: checkoutData,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		if (response.ok()) {
			const data = await response.json()

			// Should return session data
			expect(data).toHaveProperty('url')
			expect(data).toHaveProperty('sessionId')
			expect(data.sessionId).toMatch(/^cs_/)
			expect(data.url).toContain('checkout.stripe.com')

			console.log('✅ Unauthenticated checkout session creation works')
		} else {
			const errorData = await response.json()
			console.log(
				`❌ Checkout failed: ${response.status()} - ${JSON.stringify(errorData)}`
			)

			// Log the error but don't fail the test if it's due to Stripe config
			if (
				response.status() === 500 &&
				errorData.message?.includes('Stripe')
			) {
				console.log(
					'⚠️  Stripe not configured - this is expected in test environment'
				)
			} else {
				expect(response.ok()).toBeTruthy()
			}
		}
	})

	test('POST /stripe/create-checkout-session - Authenticated User', async ({
		request
	}) => {
		const checkoutData = {
			planType: PLAN_TYPES.GROWTH,
			billingInterval: 'annual',
			successUrl:
				'http://localhost:3000/billing/success?session_id={CHECKOUT_SESSION_ID}',
			cancelUrl: 'http://localhost:3000/pricing',
			customerId: TEST_USER.stripeCustomerId,
			customerEmail: TEST_USER.email
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: checkoutData,
				headers: {
					Authorization: `Bearer ${TEST_USER.token}`,
					'Content-Type': 'application/json'
				},
				timeout: BACKEND_CONFIG.timeout
			}
		)

		if (response.ok()) {
			const data = await response.json()

			expect(data).toHaveProperty('url')
			expect(data).toHaveProperty('sessionId')
			expect(data.sessionId).toMatch(/^cs_/)

			console.log('✅ Authenticated checkout session creation works')
		} else {
			const errorData = await response.json()
			console.log(
				`Checkout response: ${response.status()} - ${JSON.stringify(errorData)}`
			)

			// Don't fail test if Stripe is not configured in test environment
			if (response.status() === 500) {
				console.log(
					'⚠️  Expected in test environment without Stripe secrets'
				)
			} else {
				expect(response.ok()).toBeTruthy()
			}
		}
	})

	test('POST /stripe/create-checkout-session - Validation Errors', async ({
		request
	}) => {
		// Test with invalid plan type
		const invalidData = {
			planType: 'INVALID_PLAN',
			billingInterval: 'monthly',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: invalidData,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		expect(response.status()).toBeGreaterThanOrEqual(400)

		const errorData = await response.json()
		expect(errorData).toHaveProperty('message')

		console.log('✅ Validation errors handled correctly')
	})

	test('POST /stripe/create-portal-session - Requires Authentication', async ({
		request
	}) => {
		const portalData = {
			customerId: TEST_USER.stripeCustomerId,
			returnUrl: 'http://localhost:3000/settings/billing'
		}

		// Test without auth header
		const unauthResponse = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-portal-session`,
			{
				data: portalData,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		expect(unauthResponse.status()).toBe(401)

		console.log('✅ Portal session properly requires authentication')
	})
})

test.describe('Billing Endpoints - /billing routes', () => {
	test('POST /billing/create-checkout-session - Frontend Route', async ({
		request
	}) => {
		// This tests the route your frontend actually calls
		const checkoutData = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl:
				'http://localhost:3000/billing/success?session_id={CHECKOUT_SESSION_ID}',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/billing/create-checkout-session`,
			{
				data: checkoutData,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		// This endpoint might not exist, or might redirect to /stripe/create-checkout-session
		if (response.status() === 404) {
			console.log(
				'ℹ️  /billing/create-checkout-session not found - using /stripe endpoint instead'
			)
		} else if (response.ok()) {
			const data = await response.json()
			expect(data).toHaveProperty('sessionId')
			console.log('✅ Billing checkout endpoint works')
		} else {
			console.log(`Billing endpoint: ${response.status()}`)
		}
	})

	test('GET /billing/subscription - User Subscription Status', async ({
		request
	}) => {
		const response = await request.get(
			`${BACKEND_CONFIG.baseURL}/billing/subscription`,
			{
				headers: {
					Authorization: `Bearer ${TEST_USER.token}`
				},
				timeout: BACKEND_CONFIG.timeout
			}
		)

		if (response.status() === 404) {
			console.log('ℹ️  Subscription endpoint not implemented yet')
		} else if (response.status() === 401) {
			console.log('✅ Subscription endpoint requires authentication')
		} else if (response.ok()) {
			const data = await response.json()
			// Should contain subscription info
			console.log('✅ Subscription endpoint returns data')
		}
	})
})

test.describe('Request/Response Structure Validation', () => {
	test('Checkout request matches CreateCheckoutSessionDto', async ({
		request
	}) => {
		// Test the exact structure expected by your DTO
		const validRequest = {
			planType: PLAN_TYPES.GROWTH,
			billingInterval: 'annual',
			successUrl:
				'http://localhost:3000/billing/success?session_id={CHECKOUT_SESSION_ID}',
			cancelUrl: 'http://localhost:3000/pricing',
			couponId: undefined // Optional field
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: validRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		// If not configured, we expect a 500 error with Stripe message
		// If configured, we expect a 200 with session data
		// If validation fails, we expect a 400

		if (response.status() === 400) {
			const errorData = await response.json()
			console.log(`Validation error: ${JSON.stringify(errorData)}`)
			// This would indicate our DTO structure is wrong
			expect(response.status()).not.toBe(400)
		} else {
			console.log(`Request structure valid: ${response.status()}`)
		}
	})

	test('Invalid billing interval is rejected', async ({ request }) => {
		const invalidRequest = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'quarterly', // Invalid - should be 'monthly' or 'annual'
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: invalidRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		expect(response.status()).toBe(400)

		const errorData = await response.json()
		expect(errorData).toHaveProperty('message')

		console.log('✅ Invalid billing interval properly rejected')
	})
})

test.describe('Error Handling - Production Scenarios', () => {
	test('Missing required fields return proper error', async ({ request }) => {
		const incompleteRequest = {
			planType: PLAN_TYPES.STARTER,
			// Missing billingInterval
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: incompleteRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		expect(response.status()).toBe(400)

		const errorData = await response.json()
		expect(errorData).toHaveProperty('message')
		expect(errorData.message).toContain('billingInterval')

		console.log('✅ Missing required fields handled correctly')
	})

	test('Invalid plan type returns validation error', async ({ request }) => {
		const invalidPlanRequest = {
			planType: 'ENTERPRISE', // Not a valid PlanType in your enum
			billingInterval: 'monthly',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: invalidPlanRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		expect(response.status()).toBe(400)

		console.log('✅ Invalid plan type properly rejected')
	})

	test('Malformed URLs are handled', async ({ request }) => {
		const malformedRequest = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl: 'not-a-valid-url',
			cancelUrl: 'also-not-valid'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: malformedRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		// Backend might accept these or validate them - depends on your implementation
		if (response.status() >= 400) {
			console.log('✅ Malformed URLs rejected')
		} else {
			console.log(
				'ℹ️  Backend accepts malformed URLs (might be validated by Stripe)'
			)
		}
	})
})

test.describe('Performance and Reliability', () => {
	test('Checkout endpoint responds within acceptable time', async ({
		request
	}) => {
		const startTime = Date.now()

		const checkoutData = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: checkoutData,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		const responseTime = Date.now() - startTime

		// Should respond within 5 seconds even if Stripe is slow
		expect(responseTime).toBeLessThan(5000)

		console.log(`✅ Checkout endpoint response time: ${responseTime}ms`)
	})

	test('Backend handles concurrent checkout requests', async ({
		request
	}) => {
		const checkoutData = {
			planType: PLAN_TYPES.GROWTH,
			billingInterval: 'annual',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		// Make 5 concurrent requests
		const promises = Array(5)
			.fill(0)
			.map(() =>
				request.post(
					`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
					{
						data: checkoutData,
						timeout: BACKEND_CONFIG.timeout
					}
				)
			)

		const responses = await Promise.all(promises)

		// All should get a response (might be error if Stripe not configured)
		responses.forEach(response => {
			expect(response.status()).toBeGreaterThanOrEqual(200)
			expect(response.status()).toBeLessThan(600)
		})

		console.log('✅ Backend handles concurrent requests')
	})
})

test.describe('Security - Production Validation', () => {
	test('CORS headers are properly configured', async ({ request }) => {
		const response = await request.options(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				headers: {
					Origin: 'http://localhost:3000',
					'Access-Control-Request-Method': 'POST',
					'Access-Control-Request-Headers': 'Content-Type'
				}
			}
		)

		// Should allow CORS from your frontend origin
		expect(response.headers()['access-control-allow-origin']).toBeTruthy()

		console.log('✅ CORS properly configured')
	})

	test('Request size limits are enforced', async ({ request }) => {
		// Try to send a very large request
		const largeRequest = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing',
			metadata: 'x'.repeat(10000) // Very large string
		}

		const response = await request.post(
			`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
			{
				data: largeRequest,
				timeout: BACKEND_CONFIG.timeout
			}
		)

		// Should either succeed or fail with 413 (Payload Too Large)
		if (response.status() === 413) {
			console.log('✅ Request size limits enforced')
		} else {
			console.log('ℹ️  Large requests accepted')
		}
	})

	test('Rate limiting is configured', async ({ request }) => {
		// Make many rapid requests to test rate limiting
		const checkoutData = {
			planType: PLAN_TYPES.STARTER,
			billingInterval: 'monthly',
			successUrl: 'http://localhost:3000/billing/success',
			cancelUrl: 'http://localhost:3000/pricing'
		}

		const promises = Array(20)
			.fill(0)
			.map(() =>
				request.post(
					`${BACKEND_CONFIG.baseURL}/stripe/create-checkout-session`,
					{
						data: checkoutData,
						timeout: BACKEND_CONFIG.timeout
					}
				)
			)

		const responses = await Promise.all(promises)
		const statusCodes = responses.map(r => r.status())

		// If rate limiting is configured, some should be 429
		const rateLimited = statusCodes.some(code => code === 429)

		if (rateLimited) {
			console.log('✅ Rate limiting is configured')
		} else {
			console.log('ℹ️  No rate limiting detected')
		}
	})
})
