#!/usr/bin/env node

import * as fs from 'fs'
import { jsonSchemaToZod } from 'json-schema-to-zod'
import path from 'path'
import * as ts from 'typescript'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const BACKEND_SCHEMAS_DIR = path.resolve(__dirname, '../../backend/src/schemas')
const OUTPUT_DIR = path.resolve(__dirname, '../src/lib/validation/generated')
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'backend-schemas.ts')

const SCHEMA_FILES = [
	'contact.schemas.ts',
	'auth.schemas.ts',
	'stripe.schemas.ts',
	'property.schemas.ts'
]

interface ConversionStats {
	processed: number
	converted: number
	failed: number
	skipped: number
}

function parseSchemaFile(
	filePath: string
): Array<{ name: string; schema: Record<string, unknown> }> {
	const sourceText = fs.readFileSync(filePath, 'utf-8')
	const sourceFile = ts.createSourceFile(
		filePath,
		sourceText,
		ts.ScriptTarget.Latest,
		true
	)

	const schemas: Array<{ name: string; schema: Record<string, unknown> }> = []

	function visit(node: ts.Node) {
		if (ts.isVariableStatement(node)) {
			for (const declaration of node.declarationList.declarations) {
				if (
					ts.isIdentifier(declaration.name) &&
					declaration.name.text.endsWith('Schema') &&
					declaration.initializer &&
					ts.isObjectLiteralExpression(declaration.initializer)
				) {
					try {
						const schemaText = declaration.initializer.getFullText(sourceFile)
						const cleanedText = schemaText.trim()
						// Use JSON.parse instead of Function constructor for security
						const jsonSchema = JSON.parse(cleanedText) as Record<
							string,
							unknown
						>

						if (typeof jsonSchema === 'object' && jsonSchema !== null) {
							schemas.push({
								name: declaration.name.text,
								schema: jsonSchema
							})
						}
					} catch {
						// Skip invalid schemas in production
					}
				}
			}
		}
		ts.forEachChild(node, visit)
	}

	visit(sourceFile)
	return schemas
}

async function validateZodSchema(
	zodCode: string,
	_schemaName: string
): Promise<boolean> {
	try {
		const { z } = await import('zod')
		const testCode = `
			const zodSchema = ${zodCode};
			return typeof zodSchema === 'object' && zodSchema !== null;
		`
		// Build-time validation using Function constructor with explicit z parameter
		const validatorFn = new Function(
			'z',
			`return (function() { ${testCode} })()`
		)
		return validatorFn(z) as boolean
	} catch {
		return false
	}
}

async function convertSchemas() {
	if (!fs.existsSync(OUTPUT_DIR)) {
		fs.mkdirSync(OUTPUT_DIR, { recursive: true })
	}

	const zodSchemas: string[] = []
	const imports: string[] = ['import { z } from "zod"']
	const stats: ConversionStats = {
		processed: 0,
		converted: 0,
		failed: 0,
		skipped: 0
	}

	for (const schemaFile of SCHEMA_FILES) {
		const schemaPath = path.join(BACKEND_SCHEMAS_DIR, schemaFile)

		if (!fs.existsSync(schemaPath)) {
			stats.skipped++
			continue
		}

		stats.processed++

		try {
			const extractedSchemas = parseSchemaFile(schemaPath)

			for (const { name: schemaName, schema: jsonSchema } of extractedSchemas) {
				try {
					const zodSchemaCode = jsonSchemaToZod(jsonSchema)
					const zodSchemaName = schemaName.replace('Schema', 'ZodSchema')

					if (await validateZodSchema(zodSchemaCode, schemaName)) {
						zodSchemas.push(`export const ${zodSchemaName} = ${zodSchemaCode}`)
						stats.converted++
					} else {
						stats.failed++
					}
				} catch {
					stats.failed++
				}
			}
		} catch {
			stats.failed++
		}
	}

	if (zodSchemas.length === 0) {
		throw new Error('Schema conversion failed: no valid schemas generated')
	}

	const outputContent = `/**
 * Generated Zod Schemas from Backend JSON Schemas
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated by: scripts/convert-schemas.ts
 * Generated at: ${new Date().toISOString()}
 */

${imports.join('\n')}

${zodSchemas.join('\n\n')}

${zodSchemas
	.map(schema => {
		const match = schema.match(/export const (\w+) =/)
		if (match && match[1]) {
			const schemaName = match[1]
			const typeName = schemaName.replace('ZodSchema', 'Type')
			return `export type ${typeName} = z.infer<typeof ${schemaName}>`
		}
		return ''
	})
	.filter(Boolean)
	.join('\n')}
`

	fs.writeFileSync(OUTPUT_FILE, outputContent, 'utf-8')

	if (stats.failed > 0) {
		throw new Error(`Schema conversion completed with ${stats.failed} failures`)
	}
}

if (import.meta.url === `file://${process.argv[1]}`) {
	convertSchemas().catch(() => {
		process.exit(1)
	})
}

export { convertSchemas }