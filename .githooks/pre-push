#!/bin/bash
# Enhanced Pre-push Hook for TenantFlow
# Final quality checks and SEO optimization before remote push

echo "ğŸš€ TenantFlow Pre-push Hook - Final Quality & SEO Verification"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SEO_SCRIPT="$PROJECT_ROOT/scripts/generate-seo-optimized.js"
HOOK_START_TIME=$(date +%s)

# Performance optimizations
current_branch=$(git rev-parse --abbrev-ref HEAD)
changed_files=$(git diff --name-only HEAD~1 2>/dev/null || git diff --name-only --cached 2>/dev/null || true)

# Fast path for documentation-only changes
if [ -n "$changed_files" ]; then
    non_doc_changes=$(echo "$changed_files" | grep -v -E '\.(md|txt|rst|adoc)$|^docs/|^README' || true)
    if [ -z "$non_doc_changes" ]; then
        log_step "ğŸ“ Documentation-only changes detected - skipping most checks" "info"
        DOC_ONLY=true
    fi
fi

# Fast path for trusted automation branches
if [[ "$current_branch" =~ ^(dependabot|renovate|auto-update)/ ]]; then
    log_step "ğŸ¤– Automated branch detected - reduced checks" "info"
    AUTOMATED=true
fi

# Color codes for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log_step() {
    local message="$1"
    local type="${2:-info}"
    
    case $type in
        "success") echo -e "${GREEN}âœ… $message${NC}" ;;
        "warning") echo -e "${YELLOW}âš ï¸  $message${NC}" ;;
        "error") echo -e "${RED}âŒ $message${NC}" ;;
        "info") echo -e "${BLUE}ğŸ“ $message${NC}" ;;
        *) echo "   $message" ;;
    esac
}

# 1. SEO Files Verification (skip for doc-only or automated changes)
if [ "$DOC_ONLY" != true ] && [ "$AUTOMATED" != true ]; then
    log_step "Verifying SEO files are up to date..."
    cd "$PROJECT_ROOT"

    seo_files=(
        "apps/frontend/public/sitemap.xml"
        "apps/frontend/public/robots.txt"
    )

    seo_missing=false
    for file in "${seo_files[@]}"; do
        if [ ! -f "$file" ]; then
            log_step "Missing SEO file: $file" "warning"
            seo_missing=true
        fi
    done

    if [ "$seo_missing" = true ]; then
        log_step "Some SEO files are missing. Run 'node $SEO_SCRIPT' to generate them." "warning"
        log_step "Continuing with push anyway..." "info"
    fi
else
    log_step "Skipping SEO verification (doc-only or automated change)" "info"
fi

# 2. Ensure monorepo packages are built (skip if no package.json changes)
package_changes=$(echo "$changed_files" | grep -E 'package\.json|package-lock\.json|turbo\.json' || true)
if [ -n "$package_changes" ] || [ "$DOC_ONLY" != true ]; then
    log_step "Checking monorepo package builds..."
    packages_need_build=false

    # Check if package dist folders exist
    for pkg in "types" "shared"; do
        if [ ! -d "packages/$pkg/dist" ]; then
            log_step "Package @tenantflow/$pkg needs building" "warning"
            packages_need_build=true
        fi
    done

    if [ "$packages_need_build" = true ]; then
        log_step "Building monorepo packages..."
        if timeout 60 npm run build >/dev/null 2>&1; then
            log_step "Packages built successfully" "success"
        else
            log_step "Build failed or timed out - trying to continue anyway" "warning"
        fi
    fi
else
    log_step "Skipping package build check (no package changes)" "info"
fi

# 3. Secrets and Environment Protection (CRITICAL SECURITY - ALWAYS RUN)
log_step "Scanning for secrets and sensitive information..."

if [ -n "$changed_files" ]; then
    security_issues=false
    
    # Check for .env files being pushed
    env_files=$(echo "$changed_files" | grep -E '\.(env|environment)' || echo "$changed_files" | grep -E '^\.env' || true)
    if [ -n "$env_files" ]; then
        log_step "âŒ SECURITY BLOCK: Environment files detected!" "error"
        echo "$env_files"
        log_step "Remove .env files from commit before pushing" "error"
        security_issues=true
    fi
    
    # Scan for secrets in changed files
    secret_patterns=(
        "AKIA[0-9A-Z]{16}"                          # AWS Access Keys
        "['\"][0-9a-zA-Z]{32,}['\"]"               # Generic API keys
        "password[[:space:]]*=[[:space:]]*['\"][^'\"]{6,}"  # Passwords
        "secret[[:space:]]*=[[:space:]]*['\"][^'\"]{10,}"   # Secrets
        "token[[:space:]]*=[[:space:]]*['\"][^'\"]{20,}"    # Tokens
        "-----BEGIN[[:space:]]+.*PRIVATE KEY-----"          # Private keys
        "sk_live_[0-9a-zA-Z]{24,}"                 # Stripe live keys
        "pk_live_[0-9a-zA-Z]{24,}"                 # Stripe live public keys
    )
    
    for file in $changed_files; do
        if [ -f "$file" ] && [[ ! "$file" =~ \.(png|jpg|jpeg|gif|ico|pdf|zip|tar|gz)$ ]]; then
            for pattern in "${secret_patterns[@]}"; do
                if grep -qE "$pattern" "$file" 2>/dev/null; then
                    log_step "âŒ POTENTIAL SECRET in $file" "error"
                    security_issues=true
                fi
            done
        fi
    done
    
    if [ "$security_issues" = true ]; then
        log_step "âŒ PUSH BLOCKED: Security issues found!" "error"
        log_step "Review and remove sensitive information before pushing" "error"
        exit 1
    else
        log_step "Security scan passed - no secrets detected" "success"
    fi
else
    log_step "No files to scan for security issues" "info"
fi

# 4. Security Check (critical vulnerabilities only)
log_step "Checking npm for critical vulnerabilities..."
if command -v npm >/dev/null 2>&1 && [ "$DOC_ONLY" != true ]; then
    # Only check for critical vulnerabilities with timeout
    critical_vulns=$(timeout 30 npm audit --json 2>/dev/null | grep -c '"severity":"critical"' 2>/dev/null || echo "0")
    critical_vulns="${critical_vulns//[^0-9]/}"  # Remove any non-numeric characters
    if [ -z "$critical_vulns" ]; then
        critical_vulns="0"
    fi
    if [ "$critical_vulns" -gt 0 ]; then
        log_step "âŒ PUSH BLOCKED: $critical_vulns critical vulnerabilities found!" "error"
        log_step "Run 'npm audit --audit-level critical' to see details" "error"
        log_step "Use 'npm audit fix' to attempt automatic fixes" "info"
        exit 1
    else
        log_step "No critical vulnerabilities found" "success"
    fi
else
    log_step "Skipping npm audit (documentation changes or npm unavailable)" "info"
fi

# 5. Final Quick Checks
log_step "Running final checks..."

# Check if pushing to main/master - always check for conflicts on main
if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
    log_step "Pushing to $current_branch branch" "info"
    
    # Ensure no merge conflicts markers (only if remote branch exists)
    if git rev-parse --verify origin/$current_branch >/dev/null 2>&1; then
        conflict_files=$(git diff --name-only origin/$current_branch...HEAD 2>/dev/null | xargs -I {} sh -c 'test -f "{}" && grep -l "^<<<<<<< " "{}" 2>/dev/null' || true)
        if [ -n "$conflict_files" ]; then
            log_step "âŒ PUSH BLOCKED: Merge conflict markers detected!" "error"
            echo "$conflict_files"
            exit 1
        fi
    fi
fi

# Check commit message quality (warning only, skip for automated branches)
if [ "$AUTOMATED" != true ]; then
    recent_commits=$(git log --oneline -3 --no-merges 2>/dev/null || true)
    if echo "$recent_commits" | grep -E "^[a-f0-9]+ (wip|WIP|todo|TODO|fix|Fix)$" >/dev/null 2>&1; then
        log_step "Consider using more descriptive commit messages" "warning"
    fi
fi

# 6. Database Safety Check
db_files=$(git diff --name-only origin/main...HEAD 2>/dev/null | grep -E '\.(sql|prisma)$' || true)

if [ -n "$db_files" ]; then
    log_step "Database changes detected" "info"
    destructive_found=false
    
    for file in $db_files; do
        if [ -f "$file" ]; then
            # Check for destructive operations in new migrations only
            if [[ "$file" =~ migrations/.*\.sql$ ]] && grep -iE "drop\s+(table|column|database)|truncate|delete\s+from" "$file" 2>/dev/null; then
                log_step "âš ï¸ Destructive operation in $file" "warning"
                destructive_found=true
            fi
        fi
    done
    
    if [ "$destructive_found" = true ]; then
        log_step "Destructive database operations detected - ensure proper backup" "warning"
        read -p "Are you sure you want to push destructive migrations? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_step "Push cancelled by user" "info"
            exit 1
        fi
    fi
fi

# Performance Summary
end_time=$(date +%s)
duration=$((end_time - HOOK_START_TIME))

log_step "Pre-push checks completed in ${duration}s" "success"

# Summary of what was checked
if [ "$DOC_ONLY" = true ]; then
    log_step "ğŸ“ Fast track: Documentation-only changes" "info"
elif [ "$AUTOMATED" = true ]; then
    log_step "ğŸ¤– Fast track: Automated branch with reduced checks" "info"
else
    log_step "ğŸ” Full security and quality checks completed" "success"
fi

log_step "ğŸ‰ All checks passed! Ready for remote push..." "success"

exit 0
