/**\n * Stripe Test Configuration\n * \n * Centralized configuration for all Stripe testing with MCP server integration.\n * This file provides test setup, utilities, and environment configuration\n * for comprehensive Stripe payment testing.\n */\n\nimport { ConfigService } from '@nestjs/config'\nimport { Test, TestingModule } from '@nestjs/testing'\nimport { Logger } from '@nestjs/common'\nimport { createMCPStripeHelper, MCPStripeTestHelper } from './test-utilities/mcp-stripe-helpers'\n\n// ========================\n// Test Environment Configuration\n// ========================\n\nexport interface StripeTestConfig {\n  secretKey: string\n  publishableKey: string\n  webhookSecret?: string\n  apiVersion: string\n  enableMCPIntegration: boolean\n  testMode: 'unit' | 'integration' | 'e2e'\n  cleanupAfterTests: boolean\n}\n\n/**\n * Get test configuration from environment variables\n */\nexport function getStripeTestConfig(): StripeTestConfig {\n  return {\n    secretKey: process.env.STRIPE_TEST_SECRET_KEY || 'sk_test_mock_key',\n    publishableKey: process.env.STRIPE_TEST_PUBLISHABLE_KEY || 'pk_test_mock_key',\n    webhookSecret: process.env.STRIPE_TEST_WEBHOOK_SECRET || 'whsec_test_secret',\n    apiVersion: process.env.STRIPE_API_VERSION || '2024-06-20',\n    enableMCPIntegration: process.env.ENABLE_MCP_STRIPE_TESTS === 'true',\n    testMode: (process.env.TEST_MODE as any) || 'unit',\n    cleanupAfterTests: process.env.CLEANUP_STRIPE_TESTS !== 'false'\n  }\n}\n\n/**\n * Check if MCP Stripe testing is available\n */\nexport function isMCPStripeAvailable(): boolean {\n  const config = getStripeTestConfig()\n  return config.enableMCPIntegration && \n         config.secretKey.startsWith('sk_test_') &&\n         config.publishableKey.startsWith('pk_test_')\n}\n\n// ========================\n// Test Module Factories\n// ========================\n\n/**\n * Create a test module for Stripe unit tests\n */\nexport async function createStripeUnitTestModule(customProviders: any[] = []): Promise<TestingModule> {\n  const config = getStripeTestConfig()\n  \n  return await Test.createTestingModule({\n    providers: [\n      {\n        provide: ConfigService,\n        useValue: {\n          get: (key: string) => {\n            const configMap: Record<string, any> = {\n              'STRIPE_SECRET_KEY': config.secretKey,\n              'STRIPE_PUBLISHABLE_KEY': config.publishableKey,\n              'STRIPE_WEBHOOK_SECRET': config.webhookSecret,\n              'STRIPE_API_VERSION': config.apiVersion\n            }\n            return configMap[key]\n          }\n        }\n      },\n      ...customProviders\n    ]\n  }).compile()\n}\n\n/**\n * Create a test module for Stripe integration tests with MCP\n */\nexport async function createStripeIntegrationTestModule(\n  customProviders: any[] = [],\n  enableMCP = true\n): Promise<{\n  module: TestingModule\n  mcpHelper?: MCPStripeTestHelper\n  cleanup?: () => Promise<void>\n}> {\n  if (!enableMCP || !isMCPStripeAvailable()) {\n    console.warn('⚠️  MCP Stripe integration not available, falling back to mocked tests')\n    return {\n      module: await createStripeUnitTestModule(customProviders)\n    }\n  }\n\n  const config = getStripeTestConfig()\n  const mcpSetup = createMCPStripeHelper({\n    secretKey: config.secretKey,\n    publishableKey: config.publishableKey,\n    webhookSecret: config.webhookSecret\n  })\n\n  const module = await Test.createTestingModule({\n    providers: [\n      {\n        provide: ConfigService,\n        useValue: {\n          get: (key: string) => {\n            const configMap: Record<string, any> = {\n              'STRIPE_SECRET_KEY': config.secretKey,\n              'STRIPE_PUBLISHABLE_KEY': config.publishableKey,\n              'STRIPE_WEBHOOK_SECRET': config.webhookSecret,\n              'STRIPE_API_VERSION': config.apiVersion\n            }\n            return configMap[key]\n          }\n        }\n      },\n      ...customProviders\n    ]\n  }).compile()\n\n  return {\n    module,\n    mcpHelper: mcpSetup.helper,\n    cleanup: mcpSetup.cleanup\n  }\n}\n\n// ========================\n// Test Data Management\n// ========================\n\n/**\n * Test data cleanup utility\n */\nexport class StripeTestDataManager {\n  private testResources: {\n    customers: string[]\n    subscriptions: string[]\n    paymentIntents: string[]\n    paymentMethods: string[]\n    products: string[]\n    prices: string[]\n    coupons: string[]\n    invoices: string[]\n  } = {\n    customers: [],\n    subscriptions: [],\n    paymentIntents: [],\n    paymentMethods: [],\n    products: [],\n    prices: [],\n    coupons: [],\n    invoices: []\n  }\n\n  private mcpHelper?: MCPStripeTestHelper\n\n  constructor(mcpHelper?: MCPStripeTestHelper) {\n    this.mcpHelper = mcpHelper\n  }\n\n  /**\n   * Track a test resource for cleanup\n   */\n  track(type: keyof typeof this.testResources, id: string): void {\n    this.testResources[type].push(id)\n  }\n\n  /**\n   * Clean up all tracked test resources\n   */\n  async cleanup(): Promise<void> {\n    if (!this.mcpHelper) {\n      console.log('No MCP helper available, skipping Stripe resource cleanup')\n      return\n    }\n\n    const stripe = this.mcpHelper.getStripeClient()\n    const cleanupPromises: Promise<any>[] = []\n\n    // Cancel subscriptions\n    for (const subscriptionId of this.testResources.subscriptions) {\n      cleanupPromises.push(\n        stripe.subscriptions.cancel(subscriptionId).catch(() => {})\n      )\n    }\n\n    // Cancel payment intents\n    for (const paymentIntentId of this.testResources.paymentIntents) {\n      cleanupPromises.push(\n        stripe.paymentIntents.cancel(paymentIntentId).catch(() => {})\n      )\n    }\n\n    // Detach payment methods\n    for (const paymentMethodId of this.testResources.paymentMethods) {\n      cleanupPromises.push(\n        stripe.paymentMethods.detach(paymentMethodId).catch(() => {})\n      )\n    }\n\n    // Delete customers (will cascade to related resources)\n    for (const customerId of this.testResources.customers) {\n      cleanupPromises.push(\n        stripe.customers.del(customerId).catch(() => {})\n      )\n    }\n\n    // Delete coupons\n    for (const couponId of this.testResources.coupons) {\n      cleanupPromises.push(\n        stripe.coupons.del(couponId).catch(() => {})\n      )\n    }\n\n    // Archive prices and products\n    for (const priceId of this.testResources.prices) {\n      cleanupPromises.push(\n        stripe.prices.update(priceId, { active: false }).catch(() => {})\n      )\n    }\n\n    for (const productId of this.testResources.products) {\n      cleanupPromises.push(\n        stripe.products.update(productId, { active: false }).catch(() => {})\n      )\n    }\n\n    await Promise.all(cleanupPromises)\n\n    // Reset tracking\n    this.testResources = {\n      customers: [],\n      subscriptions: [],\n      paymentIntents: [],\n      paymentMethods: [],\n      products: [],\n      prices: [],\n      coupons: [],\n      invoices: []\n    }\n\n    console.log('✅ Stripe test resources cleaned up')\n  }\n\n  /**\n   * Get summary of tracked resources\n   */\n  getSummary(): typeof this.testResources {\n    return { ...this.testResources }\n  }\n}\n\n// ========================\n// Test Assertion Helpers\n// ========================\n\n/**\n * Assert that a Stripe object has expected properties\n */\nexport function assertStripeObject(\n  object: any,\n  expectedProps: Record<string, any>,\n  objectType: string\n): void {\n  if (!object) {\n    throw new Error(`Expected ${objectType} object but got ${object}`)\n  }\n\n  if (!object.id || !object.object) {\n    throw new Error(`Invalid Stripe ${objectType} object: missing id or object property`)\n  }\n\n  for (const [key, expectedValue] of Object.entries(expectedProps)) {\n    if (expectedValue !== undefined && object[key] !== expectedValue) {\n      throw new Error(\n        `Expected ${objectType}.${key} to be ${expectedValue} but got ${object[key]}`\n      )\n    }\n  }\n}\n\n/**\n * Assert that a subscription is in expected state\n */\nexport function assertSubscriptionState(\n  subscription: any,\n  expectedState: {\n    status?: string\n    customerId?: string\n    priceId?: string\n    trialEnd?: Date | null\n    cancelAtPeriodEnd?: boolean\n  }\n): void {\n  assertStripeObject(subscription, {}, 'subscription')\n\n  if (expectedState.status && subscription.status !== expectedState.status) {\n    throw new Error(\n      `Expected subscription status ${expectedState.status} but got ${subscription.status}`\n    )\n  }\n\n  if (expectedState.customerId && subscription.customer !== expectedState.customerId) {\n    throw new Error(\n      `Expected subscription customer ${expectedState.customerId} but got ${subscription.customer}`\n    )\n  }\n\n  if (expectedState.priceId) {\n    const actualPriceId = subscription.items?.data?.[0]?.price?.id\n    if (actualPriceId !== expectedState.priceId) {\n      throw new Error(\n        `Expected subscription price ${expectedState.priceId} but got ${actualPriceId}`\n      )\n    }\n  }\n\n  if (expectedState.cancelAtPeriodEnd !== undefined) {\n    if (subscription.cancel_at_period_end !== expectedState.cancelAtPeriodEnd) {\n      throw new Error(\n        `Expected cancel_at_period_end ${expectedState.cancelAtPeriodEnd} but got ${subscription.cancel_at_period_end}`\n      )\n    }\n  }\n}\n\n/**\n * Assert that an invoice has expected properties\n */\nexport function assertInvoiceState(\n  invoice: any,\n  expectedState: {\n    status?: string\n    customerId?: string\n    subscriptionId?: string\n    amountDue?: number\n    paid?: boolean\n  }\n): void {\n  assertStripeObject(invoice, {}, 'invoice')\n\n  if (expectedState.status && invoice.status !== expectedState.status) {\n    throw new Error(\n      `Expected invoice status ${expectedState.status} but got ${invoice.status}`\n    )\n  }\n\n  if (expectedState.customerId && invoice.customer !== expectedState.customerId) {\n    throw new Error(\n      `Expected invoice customer ${expectedState.customerId} but got ${invoice.customer}`\n    )\n  }\n\n  if (expectedState.subscriptionId && invoice.subscription !== expectedState.subscriptionId) {\n    throw new Error(\n      `Expected invoice subscription ${expectedState.subscriptionId} but got ${invoice.subscription}`\n    )\n  }\n\n  if (expectedState.amountDue !== undefined && invoice.amount_due !== expectedState.amountDue) {\n    throw new Error(\n      `Expected invoice amount_due ${expectedState.amountDue} but got ${invoice.amount_due}`\n    )\n  }\n\n  if (expectedState.paid !== undefined && invoice.paid !== expectedState.paid) {\n    throw new Error(\n      `Expected invoice paid ${expectedState.paid} but got ${invoice.paid}`\n    )\n  }\n}\n\n// ========================\n// Test Scenario Builders\n// ========================\n\n/**\n * Build a comprehensive test scenario with customer, subscription, and payment method\n */\nexport async function buildFullPaymentScenario(\n  mcpHelper: MCPStripeTestHelper,\n  dataManager: StripeTestDataManager,\n  options: {\n    planType: 'STARTER' | 'GROWTH' | 'ENTERPRISE'\n    billingInterval: 'monthly' | 'annual'\n    trialDays?: number\n    withPaymentMethod?: boolean\n  }\n) {\n  // Create test infrastructure\n  const { products, prices } = await mcpHelper.createTestPlanPrices()\n  \n  // Track products and prices\n  for (const [planType, product] of Object.entries(products)) {\n    dataManager.track('products', product.id)\n    dataManager.track('prices', prices[planType].monthly.id)\n    dataManager.track('prices', prices[planType].annual.id)\n  }\n\n  // Create customer\n  const customer = await mcpHelper.createTestCustomer({\n    email: `scenario-${Date.now()}@example.com`,\n    name: `Test Scenario Customer`,\n    metadata: {\n      scenarioType: 'full_payment',\n      planType: options.planType,\n      billingInterval: options.billingInterval\n    }\n  })\n  dataManager.track('customers', customer.id)\n\n  // Create payment method if requested\n  let paymentMethod: any = null\n  if (options.withPaymentMethod) {\n    paymentMethod = await mcpHelper.createTestPaymentMethod({\n      customerId: customer.id\n    })\n    dataManager.track('paymentMethods', paymentMethod.id)\n  }\n\n  // Create subscription\n  const selectedPrice = prices[options.planType][options.billingInterval]\n  const subscription = await mcpHelper.createTestSubscription({\n    customerId: customer.id,\n    priceId: selectedPrice.id,\n    paymentMethodId: paymentMethod?.id,\n    trialPeriodDays: options.trialDays || 0,\n    metadata: {\n      scenarioType: 'full_payment',\n      planType: options.planType\n    }\n  })\n  dataManager.track('subscriptions', subscription.id)\n\n  return {\n    customer,\n    paymentMethod,\n    subscription,\n    product: products[options.planType],\n    price: selectedPrice,\n    prices: prices[options.planType]\n  }\n}\n\n// ========================\n// Test Utilities\n// ========================\n\n/**\n * Wait for webhook processing with timeout\n */\nexport async function waitForWebhookProcessing(\n  timeoutMs: number = 3000,\n  checkInterval: number = 100\n): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeoutMs)\n  })\n}\n\n/**\n * Retry a test operation with exponential backoff\n */\nexport async function retryOperation<T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  initialDelayMs: number = 100\n): Promise<T> {\n  let lastError: Error\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation()\n    } catch (error) {\n      lastError = error as Error\n      \n      if (attempt === maxRetries) {\n        throw lastError\n      }\n      \n      const delayMs = initialDelayMs * Math.pow(2, attempt)\n      await new Promise(resolve => setTimeout(resolve, delayMs))\n    }\n  }\n  \n  throw lastError!\n}\n\n/**\n * Mock console methods for clean test output\n */\nexport function mockConsoleForTests(): {\n  restore: () => void\n  getLogs: () => { level: string; message: string }[]\n} {\n  const originalMethods = {\n    log: console.log,\n    warn: console.warn,\n    error: console.error,\n    info: console.info\n  }\n  \n  const logs: { level: string; message: string }[] = []\n  \n  console.log = (...args) => logs.push({ level: 'log', message: args.join(' ') })\n  console.warn = (...args) => logs.push({ level: 'warn', message: args.join(' ') })\n  console.error = (...args) => logs.push({ level: 'error', message: args.join(' ') })\n  console.info = (...args) => logs.push({ level: 'info', message: args.join(' ') })\n  \n  return {\n    restore: () => {\n      Object.assign(console, originalMethods)\n    },\n    getLogs: () => [...logs]\n  }\n}\n\n/**\n * Setup test environment with proper cleanup\n */\nexport function setupStripeTestEnvironment(options: {\n  enableMCP?: boolean\n  autoCleanup?: boolean\n} = {}) {\n  const { enableMCP = true, autoCleanup = true } = options\n  \n  let mcpHelper: MCPStripeTestHelper | undefined\n  let dataManager: StripeTestDataManager\n  let cleanup: (() => Promise<void>) | undefined\n  \n  return {\n    async setup() {\n      if (enableMCP && isMCPStripeAvailable()) {\n        const mcpSetup = createMCPStripeHelper()\n        mcpHelper = mcpSetup.helper\n        cleanup = mcpSetup.cleanup\n        dataManager = new StripeTestDataManager(mcpHelper)\n      } else {\n        dataManager = new StripeTestDataManager()\n      }\n      \n      return { mcpHelper, dataManager }\n    },\n    \n    async teardown() {\n      if (autoCleanup) {\n        if (dataManager) {\n          await dataManager.cleanup()\n        }\n        if (cleanup) {\n          await cleanup()\n        }\n      }\n    },\n    \n    isMCPEnabled: () => Boolean(mcpHelper)\n  }\n}\n\n// ========================\n// Export Test Configuration\n// ========================\n\nexport const STRIPE_TEST_CONFIG = {\n  // Test card numbers for different scenarios\n  TEST_CARDS: {\n    SUCCESS: '4242424242424242',\n    DECLINED: '4000000000000002',\n    INSUFFICIENT_FUNDS: '4000000000009995',\n    EXPIRED: '4000000000000069',\n    CVC_FAIL: '4000000000000127'\n  },\n  \n  // Test amounts (in cents)\n  TEST_AMOUNTS: {\n    STARTER_MONTHLY: 1900,   // $19.00\n    STARTER_ANNUAL: 19000,   // $190.00\n    GROWTH_MONTHLY: 4900,    // $49.00\n    GROWTH_ANNUAL: 49000,    // $490.00\n    ENTERPRISE_MONTHLY: 14900, // $149.00\n    ENTERPRISE_ANNUAL: 149000  // $1490.00\n  },\n  \n  // Test timeouts\n  TIMEOUTS: {\n    WEBHOOK_PROCESSING: 3000,\n    API_RESPONSE: 10000,\n    SUBSCRIPTION_CREATION: 15000,\n    PAYMENT_PROCESSING: 20000\n  },\n  \n  // Test retry configuration\n  RETRY_CONFIG: {\n    MAX_RETRIES: 3,\n    INITIAL_DELAY: 100,\n    MAX_DELAY: 2000\n  }\n} as const"