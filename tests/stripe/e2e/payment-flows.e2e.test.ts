import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest'\nimport { Test, TestingModule } from '@nestjs/testing'\nimport { ConfigService } from '@nestjs/config'\nimport { StripeService } from '../../../apps/backend/src/stripe/stripe.service'\nimport { StripeBillingService } from '../../../apps/backend/src/stripe/stripe-billing.service'\nimport { WebhookService } from '../../../apps/backend/src/stripe/webhook.service'\nimport { SubscriptionsManagerService } from '../../../apps/backend/src/subscriptions/subscriptions-manager.service'\nimport { PrismaService } from '../../../apps/backend/src/prisma/prisma.service'\nimport { ErrorHandlerService } from '../../../apps/backend/src/common/errors/error-handler.service'\nimport { MCPStripeTestHelper, createMCPStripeHelper, waitForWebhookProcessing } from '../test-utilities/mcp-stripe-helpers'\nimport type { PlanType } from '@prisma/client'\nimport type Stripe from 'stripe'\n\n/**\n * End-to-End Stripe Payment Flow Tests\n * \n * These tests simulate complete user journeys through the payment system,\n * from signup to subscription management, using real Stripe API calls\n * through the MCP server.\n */\ndescribe('Stripe Payment Flows E2E Tests', () => {\n  let app: TestingModule\n  let stripeService: StripeService\n  let stripeBillingService: StripeBillingService\n  let webhookService: WebhookService\n  let subscriptionsManager: SubscriptionsManagerService\n  let prismaService: PrismaService\n  let mcpHelper: MCPStripeTestHelper\n  let cleanup: () => Promise<void>\n\n  // Test infrastructure\n  let testPrices: Record<string, { monthly: Stripe.Price; annual: Stripe.Price }>\n  let testProducts: Record<string, Stripe.Product>\n  let webhookSecret: string\n\n  beforeAll(async () => {\n    // Skip E2E tests if MCP Stripe is not configured\n    if (!process.env.STRIPE_TEST_SECRET_KEY) {\n      console.log('⚠️  Skipping Stripe E2E tests - STRIPE_TEST_SECRET_KEY not configured')\n      return\n    }\n\n    // Initialize MCP Stripe helper\n    const mcpSetup = createMCPStripeHelper()\n    mcpHelper = mcpSetup.helper\n    cleanup = mcpSetup.cleanup\n\n    webhookSecret = process.env.STRIPE_TEST_WEBHOOK_SECRET || 'whsec_test_secret'\n\n    // Create comprehensive test module\n    app = await Test.createTestingModule({\n      providers: [\n        StripeService,\n        StripeBillingService,\n        WebhookService,\n        SubscriptionsManagerService,\n        {\n          provide: ConfigService,\n          useValue: {\n            get: (key: string) => {\n              const config = {\n                'STRIPE_SECRET_KEY': process.env.STRIPE_TEST_SECRET_KEY,\n                'STRIPE_PUBLISHABLE_KEY': process.env.STRIPE_TEST_PUBLISHABLE_KEY,\n                'STRIPE_WEBHOOK_SECRET': webhookSecret\n              }\n              return config[key]\n            }\n          }\n        },\n        {\n          provide: PrismaService,\n          useValue: {\n            user: {\n              findUnique: vi.fn(),\n              create: vi.fn(),\n              update: vi.fn()\n            },\n            subscription: {\n              findFirst: vi.fn(),\n              findUnique: vi.fn(),\n              create: vi.fn(),\n              update: vi.fn(),\n              updateMany: vi.fn(),\n              upsert: vi.fn()\n            },\n            property: {\n              count: vi.fn().mockResolvedValue(0)\n            }\n          }\n        },\n        {\n          provide: ErrorHandlerService,\n          useValue: {\n            createValidationError: (message: string) => new Error(message),\n            createNotFoundError: (resource: string, id: string) => new Error(`${resource} ${id} not found`),\n            handleErrorEnhanced: (error: Error) => { throw error }\n          }\n        }\n      ]\n    }).compile()\n\n    // Get service instances\n    stripeService = app.get<StripeService>(StripeService)\n    stripeBillingService = app.get<StripeBillingService>(StripeBillingService)\n    webhookService = app.get<WebhookService>(WebhookService)\n    subscriptionsManager = app.get<SubscriptionsManagerService>(SubscriptionsManagerService)\n    prismaService = app.get<PrismaService>(PrismaService)\n\n    // Create test data infrastructure\n    const planSetup = await mcpHelper.createTestPlanPrices()\n    testPrices = planSetup.prices\n    testProducts = planSetup.products\n\n    console.log('✅ Stripe E2E test setup complete')\n  })\n\n  afterAll(async () => {\n    if (cleanup && mcpHelper) {\n      await cleanup()\n      console.log('✅ Stripe E2E test cleanup complete')\n    }\n    \n    if (app) {\n      await app.close()\n    }\n  })\n\n  beforeEach(() => {\n    // Reset all mocks between tests\n    vi.clearAllMocks()\n  })\n\n  describe('Complete New User Subscription Journey', () => {\n    it('should handle new user signup with free trial', async () => {\n      const userId = `e2e_user_${Date.now()}`\n      const userEmail = `e2e-test-${Date.now()}@example.com`\n      \n      // Mock user data\n      const mockUser = {\n        id: userId,\n        email: userEmail,\n        name: 'E2E Test User',\n        Subscription: []\n      }\n\n      vi.mocked(prismaService.user.findUnique).mockResolvedValue(mockUser as any)\n      vi.mocked(prismaService.subscription.upsert).mockResolvedValue({\n        id: 'sub_db_123',\n        userId,\n        planType: 'STARTER',\n        status: 'TRIALING'\n      } as any)\n\n      // Step 1: Create customer and subscription with trial\n      const subscriptionResult = await stripeBillingService.createSubscription({\n        userId,\n        planType: 'STARTER',\n        billingInterval: 'monthly',\n        trialDays: 14\n      })\n\n      expect(subscriptionResult.subscriptionId).toMatch(/^sub_/)\n      expect(subscriptionResult.status).toMatch(/^(trialing|active|incomplete)$/)\n\n      // Step 2: Verify subscription in Stripe\n      const stripeSubscription = await stripeService.getSubscription(\n        subscriptionResult.subscriptionId\n      )\n      \n      expect(stripeSubscription).toBeDefined()\n      expect(stripeSubscription!.status).toMatch(/^(trialing|active|incomplete)$/)\n      \n      if (stripeSubscription!.trial_end) {\n        const trialEndDate = new Date(stripeSubscription!.trial_end * 1000)\n        const now = new Date()\n        const daysDifference = Math.ceil((trialEndDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))\n        expect(daysDifference).toBeGreaterThanOrEqual(13) // Allow for timing differences\n        expect(daysDifference).toBeLessThanOrEqual(15)\n      }\n\n      // Step 3: Simulate trial ending - add payment method\n      const customer = await stripeService.getCustomer(subscriptionResult.customerId)\n      expect(customer).toBeDefined()\n\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: customer!.id\n      })\n\n      // Step 4: Update subscription with payment method before trial ends\n      await mcpHelper.getStripeClient().customers.update(customer!.id, {\n        invoice_settings: {\n          default_payment_method: paymentMethod.id\n        }\n      })\n\n      // Step 5: Simulate trial end by updating the subscription\n      const updatedSubscription = await mcpHelper.getStripeClient().subscriptions.update(\n        subscriptionResult.subscriptionId,\n        { trial_end: 'now' }\n      )\n\n      expect(updatedSubscription.status).toMatch(/^(active|past_due)$/)\n\n      console.log('✅ New user subscription journey completed successfully')\n    })\n\n    it('should handle new user checkout session flow', async () => {\n      const userId = `e2e_checkout_${Date.now()}`\n      const userEmail = `e2e-checkout-${Date.now()}@example.com`\n      \n      const mockUser = {\n        id: userId,\n        email: userEmail,\n        name: 'E2E Checkout User',\n        Subscription: []\n      }\n\n      vi.mocked(prismaService.user.findUnique).mockResolvedValue(mockUser as any)\n\n      // Step 1: Create checkout session\n      const checkoutResult = await stripeBillingService.createCheckoutSession({\n        userId,\n        planType: 'GROWTH',\n        billingInterval: 'annual',\n        successUrl: 'https://example.com/success',\n        cancelUrl: 'https://example.com/cancel'\n      })\n\n      expect(checkoutResult.sessionId).toMatch(/^cs_/)\n      expect(checkoutResult.url).toMatch(/^https:\\/\\/checkout\\.stripe\\.com/)\n\n      // Step 2: Verify checkout session details\n      const session = await mcpHelper.getStripeClient().checkout.sessions.retrieve(\n        checkoutResult.sessionId,\n        { expand: ['line_items', 'subscription_data'] }\n      )\n\n      expect(session.mode).toBe('subscription')\n      expect(session.line_items?.data?.[0]?.price).toBe(testPrices.GROWTH.annual.id)\n      expect(session.subscription_data?.trial_period_days).toBe(14)\n      expect(session.subscription_data?.metadata?.userId).toBe(userId)\n      expect(session.subscription_data?.metadata?.planType).toBe('GROWTH')\n\n      console.log('✅ Checkout session flow completed successfully')\n    })\n  })\n\n  describe('Subscription Management Journey', () => {\n    let testCustomer: Stripe.Customer\n    let testPaymentMethod: Stripe.PaymentMethod\n    let activeSubscription: Stripe.Subscription\n\n    beforeEach(async () => {\n      // Create test customer and payment method for each test\n      testCustomer = await mcpHelper.createTestCustomer({\n        email: `sub-mgmt-${Date.now()}@example.com`,\n        name: 'Subscription Management Test User'\n      })\n\n      testPaymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      activeSubscription = await mcpHelper.createTestSubscription({\n        customerId: testCustomer.id,\n        priceId: testPrices.STARTER.monthly.id,\n        paymentMethodId: testPaymentMethod.id,\n        trialPeriodDays: 0 // Start active immediately\n      })\n\n      // Wait for subscription to be processed\n      await waitForWebhookProcessing(1000)\n    })\n\n    it('should handle subscription upgrade flow', async () => {\n      const userId = `e2e_upgrade_${Date.now()}`\n      \n      vi.mocked(prismaService.subscription.updateMany).mockResolvedValue({ count: 1 })\n\n      // Step 1: Upgrade from STARTER to GROWTH\n      const upgradeResult = await stripeBillingService.updateSubscription({\n        subscriptionId: activeSubscription.id,\n        userId,\n        newPlanType: 'GROWTH',\n        billingInterval: 'monthly',\n        prorationBehavior: 'create_prorations'\n      })\n\n      expect(upgradeResult.subscriptionId).toBe(activeSubscription.id)\n      expect(upgradeResult.priceId).toBe(testPrices.GROWTH.monthly.id)\n      expect(upgradeResult.status).toMatch(/^(active|incomplete)$/)\n\n      // Step 2: Verify upgrade in Stripe\n      const upgradedSubscription = await stripeService.getSubscription(activeSubscription.id)\n      expect(upgradedSubscription!.items.data[0].price.id).toBe(testPrices.GROWTH.monthly.id)\n\n      // Step 3: Check for proration invoice\n      const invoices = await mcpHelper.getStripeClient().invoices.list({\n        customer: testCustomer.id,\n        subscription: activeSubscription.id,\n        limit: 3\n      })\n\n      expect(invoices.data.length).toBeGreaterThan(0)\n      \n      // Should have proration line items\n      const latestInvoice = invoices.data[0]\n      expect(latestInvoice.lines.data.length).toBeGreaterThan(1)\n\n      // Step 4: Upgrade to annual billing\n      const annualUpgrade = await stripeBillingService.updateSubscription({\n        subscriptionId: activeSubscription.id,\n        userId,\n        newPlanType: 'GROWTH',\n        billingInterval: 'annual',\n        prorationBehavior: 'create_prorations'\n      })\n\n      expect(annualUpgrade.priceId).toBe(testPrices.GROWTH.annual.id)\n\n      console.log('✅ Subscription upgrade flow completed successfully')\n    })\n\n    it('should handle subscription downgrade flow', async () => {\n      const userId = `e2e_downgrade_${Date.now()}`\n      \n      // Start with ENTERPRISE subscription\n      const enterpriseSubscription = await mcpHelper.createTestSubscription({\n        customerId: testCustomer.id,\n        priceId: testPrices.ENTERPRISE.monthly.id,\n        paymentMethodId: testPaymentMethod.id,\n        trialPeriodDays: 0\n      })\n\n      vi.mocked(prismaService.subscription.updateMany).mockResolvedValue({ count: 1 })\n\n      // Step 1: Downgrade to STARTER\n      const downgradeResult = await stripeBillingService.updateSubscription({\n        subscriptionId: enterpriseSubscription.id,\n        userId,\n        newPlanType: 'STARTER',\n        billingInterval: 'monthly',\n        prorationBehavior: 'create_prorations'\n      })\n\n      expect(downgradeResult.priceId).toBe(testPrices.STARTER.monthly.id)\n\n      // Step 2: Verify downgrade created credit for overpayment\n      const invoices = await mcpHelper.getStripeClient().invoices.list({\n        customer: testCustomer.id,\n        subscription: enterpriseSubscription.id,\n        limit: 3\n      })\n\n      const prorationInvoice = invoices.data.find(inv => \n        inv.lines.data.some(line => line.amount < 0) // Credit line item\n      )\n      \n      expect(prorationInvoice).toBeDefined()\n\n      console.log('✅ Subscription downgrade flow completed successfully')\n    })\n\n    it('should handle subscription cancellation flow', async () => {\n      const userId = `e2e_cancel_${Date.now()}`\n      \n      vi.mocked(prismaService.subscription.updateMany).mockResolvedValue({ count: 1 })\n\n      // Step 1: Cancel at period end\n      const cancelResult = await stripeBillingService.cancelSubscription({\n        subscriptionId: activeSubscription.id,\n        userId,\n        cancellationReason: 'user_requested'\n      })\n\n      expect(cancelResult.status).toBe('active') // Still active until period end\n      expect(cancelResult.canceledAt).toBeUndefined()\n\n      // Step 2: Verify cancellation scheduled in Stripe\n      const scheduledCancellation = await stripeService.getSubscription(activeSubscription.id)\n      expect(scheduledCancellation!.cancel_at_period_end).toBe(true)\n      expect(scheduledCancellation!.status).toBe('active')\n\n      // Step 3: Test immediate cancellation\n      const immediateCancelResult = await stripeBillingService.cancelSubscription({\n        subscriptionId: activeSubscription.id,\n        userId,\n        immediately: true,\n        cancellationReason: 'user_requested_immediate'\n      })\n\n      expect(immediateCancelResult.status).toBe('canceled')\n      expect(immediateCancelResult.canceledAt).toBeDefined()\n\n      // Step 4: Verify immediate cancellation in Stripe\n      const canceledSubscription = await stripeService.getSubscription(activeSubscription.id)\n      expect(canceledSubscription!.status).toBe('canceled')\n      expect(canceledSubscription!.canceled_at).toBeDefined()\n\n      console.log('✅ Subscription cancellation flow completed successfully')\n    })\n\n    it('should handle subscription reactivation flow', async () => {\n      const userId = `e2e_reactivate_${Date.now()}`\n      \n      // Step 1: Pause subscription (simulate trial ended without payment)\n      const pausedSubscription = await mcpHelper.getStripeClient().subscriptions.update(\n        activeSubscription.id,\n        {\n          pause_collection: {\n            behavior: 'void'\n          }\n        }\n      )\n\n      expect(pausedSubscription.pause_collection).toBeDefined()\n\n      // Step 2: Mock user lookup\n      vi.mocked(prismaService.user.findUnique).mockResolvedValue({\n        id: userId,\n        email: testCustomer.email,\n        name: testCustomer.name,\n        Subscription: [{ stripeCustomerId: testCustomer.id }]\n      } as any)\n\n      vi.mocked(prismaService.subscription.updateMany).mockResolvedValue({ count: 1 })\n\n      // Step 3: Reactivate with new payment method\n      const newPaymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      const reactivateResult = await stripeBillingService.reactivateSubscription({\n        userId,\n        subscriptionId: activeSubscription.id,\n        paymentMethodId: newPaymentMethod.id\n      })\n\n      expect(reactivateResult.status).toMatch(/^(active|incomplete)$/)\n\n      // Step 4: Verify reactivation in Stripe\n      const reactivatedSubscription = await stripeService.getSubscription(activeSubscription.id)\n      expect(reactivatedSubscription!.pause_collection).toBeNull()\n      expect(reactivatedSubscription!.default_payment_method).toBe(newPaymentMethod.id)\n\n      console.log('✅ Subscription reactivation flow completed successfully')\n    })\n  })\n\n  describe('Payment Processing Journey', () => {\n    let testCustomer: Stripe.Customer\n\n    beforeEach(async () => {\n      testCustomer = await mcpHelper.createTestCustomer({\n        email: `payment-${Date.now()}@example.com`,\n        name: 'Payment Test User'\n      })\n    })\n\n    it('should handle successful payment flow', async () => {\n      // Step 1: Create payment method\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      // Step 2: Create payment intent\n      const paymentIntent = await mcpHelper.createTestPaymentIntent({\n        amount: 2500, // $25.00\n        customerId: testCustomer.id,\n        paymentMethodId: paymentMethod.id,\n        confirmImmediately: true\n      })\n\n      expect(paymentIntent.id).toMatch(/^pi_/)\n      expect(paymentIntent.amount).toBe(2500)\n      expect(paymentIntent.status).toMatch(/^(succeeded|requires_payment_method|processing)$/)\n\n      console.log('✅ Successful payment flow completed')\n    })\n\n    it('should handle payment failure scenarios', async () => {\n      const failureScenarios = [\n        { type: 'CARD_DECLINED', expectedError: 'card_error' },\n        { type: 'INSUFFICIENT_FUNDS', expectedError: 'card_error' },\n        { type: 'EXPIRED_CARD', expectedError: 'card_error' }\n      ] as const\n\n      for (const scenario of failureScenarios) {\n        const { paymentResult } = await mcpHelper.createPaymentFailureScenario({\n          failureType: scenario.type,\n          amount: 1500\n        })\n\n        expect(paymentResult.error).toBeDefined()\n        expect(paymentResult.error.type).toMatch(/card_error|invalid_request_error/)\n      }\n\n      console.log('✅ Payment failure scenarios completed')\n    })\n\n    it('should handle recurring payment flow', async () => {\n      const userId = `e2e_recurring_${Date.now()}`\n      \n      // Mock user\n      vi.mocked(prismaService.user.findUnique).mockResolvedValue({\n        id: userId,\n        email: testCustomer.email,\n        name: testCustomer.name,\n        Subscription: []\n      } as any)\n\n      vi.mocked(prismaService.subscription.upsert).mockResolvedValue({\n        id: 'sub_db_123',\n        userId,\n        planType: 'GROWTH',\n        status: 'ACTIVE'\n      } as any)\n\n      // Step 1: Create subscription (sets up recurring billing)\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      const subscriptionResult = await stripeBillingService.createSubscription({\n        userId,\n        planType: 'GROWTH',\n        billingInterval: 'monthly',\n        paymentMethodId: paymentMethod.id,\n        trialDays: 0 // No trial for immediate billing\n      })\n\n      // Step 2: Verify initial invoice was created and paid\n      const invoices = await mcpHelper.getStripeClient().invoices.list({\n        customer: testCustomer.id,\n        subscription: subscriptionResult.subscriptionId,\n        limit: 5\n      })\n\n      expect(invoices.data.length).toBeGreaterThan(0)\n      \n      const initialInvoice = invoices.data[0]\n      expect(initialInvoice.status).toMatch(/^(paid|draft|open)$/)\n      expect(initialInvoice.amount_due).toBeGreaterThan(0)\n\n      console.log('✅ Recurring payment flow setup completed')\n    })\n  })\n\n  describe('Webhook Processing Journey', () => {\n    let testCustomer: Stripe.Customer\n    let testSubscription: Stripe.Subscription\n\n    beforeEach(async () => {\n      testCustomer = await mcpHelper.createTestCustomer({\n        email: `webhook-${Date.now()}@example.com`,\n        name: 'Webhook Test User'\n      })\n\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      testSubscription = await mcpHelper.createTestSubscription({\n        customerId: testCustomer.id,\n        priceId: testPrices.STARTER.monthly.id,\n        paymentMethodId: paymentMethod.id\n      })\n\n      // Mock database operations\n      vi.mocked(prismaService.subscription.findFirst).mockResolvedValue({\n        id: 'sub_db_123',\n        userId: 'webhook_user_123',\n        stripeCustomerId: testCustomer.id,\n        User: {\n          id: 'webhook_user_123',\n          email: testCustomer.email,\n          name: testCustomer.name\n        }\n      } as any)\n    })\n\n    it('should process complete subscription lifecycle webhooks', async () => {\n      // Step 1: Process subscription created webhook\n      const { event: createdEvent } = await mcpHelper.simulateWebhookEvent({\n        eventType: 'customer.subscription.created',\n        objectId: testSubscription.id,\n        objectType: 'subscription'\n      })\n\n      vi.spyOn(stripeService, 'constructWebhookEvent').mockReturnValue(createdEvent)\n      vi.mocked(prismaService.subscription.update).mockResolvedValue({ id: 'sub_db_123' } as any)\n\n      await webhookService.handleWebhookEvent(createdEvent)\n\n      expect(prismaService.subscription.findFirst).toHaveBeenCalledWith({\n        where: { stripeCustomerId: testCustomer.id }\n      })\n\n      // Step 2: Process subscription updated webhook (status change)\n      const { event: updatedEvent } = await mcpHelper.simulateWebhookEvent({\n        eventType: 'customer.subscription.updated',\n        objectId: testSubscription.id,\n        objectType: 'subscription',\n        additionalData: {\n          status: 'active',\n          previous_attributes: { status: 'trialing' }\n        }\n      })\n\n      vi.spyOn(stripeService, 'constructWebhookEvent').mockReturnValue(updatedEvent)\n\n      await webhookService.handleWebhookEvent(updatedEvent)\n\n      // Step 3: Process payment succeeded webhook\n      const invoice = await mcpHelper.createTestInvoice({\n        customerId: testCustomer.id,\n        subscriptionId: testSubscription.id\n      })\n\n      const { event: paymentSucceededEvent } = await mcpHelper.simulateWebhookEvent({\n        eventType: 'invoice.payment_succeeded',\n        objectId: invoice.id,\n        objectType: 'invoice',\n        additionalData: {\n          subscription: testSubscription.id\n        }\n      })\n\n      vi.spyOn(stripeService, 'constructWebhookEvent').mockReturnValue(paymentSucceededEvent)\n\n      await webhookService.handleWebhookEvent(paymentSucceededEvent)\n\n      expect(prismaService.subscription.update).toHaveBeenCalledWith({\n        where: { stripeSubscriptionId: testSubscription.id },\n        data: { status: 'ACTIVE' }\n      })\n\n      // Step 4: Process subscription deleted webhook\n      const { event: deletedEvent } = await mcpHelper.simulateWebhookEvent({\n        eventType: 'customer.subscription.deleted',\n        objectId: testSubscription.id,\n        objectType: 'subscription'\n      })\n\n      vi.spyOn(stripeService, 'constructWebhookEvent').mockReturnValue(deletedEvent)\n      vi.mocked(prismaService.subscription.updateMany).mockResolvedValue({ count: 1 })\n\n      await webhookService.handleWebhookEvent(deletedEvent)\n\n      expect(prismaService.subscription.updateMany).toHaveBeenCalledWith({\n        where: { stripeSubscriptionId: testSubscription.id },\n        data: {\n          status: 'CANCELED',\n          cancelAtPeriodEnd: false,\n          canceledAt: expect.any(Date)\n        }\n      })\n\n      console.log('✅ Complete webhook lifecycle processing completed')\n    })\n\n    it('should handle webhook event failures and retries', async () => {\n      // Simulate database error on first attempt\n      vi.mocked(prismaService.subscription.update)\n        .mockRejectedValueOnce(new Error('Database temporarily unavailable'))\n        .mockResolvedValueOnce({ id: 'sub_db_123' } as any)\n\n      const { event } = await mcpHelper.simulateWebhookEvent({\n        eventType: 'customer.subscription.updated',\n        objectId: testSubscription.id,\n        objectType: 'subscription'\n      })\n\n      vi.spyOn(stripeService, 'constructWebhookEvent').mockReturnValue(event)\n\n      // First attempt should fail\n      await expect(webhookService.handleWebhookEvent(event)).rejects.toThrow(\n        'Database temporarily unavailable'\n      )\n\n      // Second attempt should succeed\n      await webhookService.handleWebhookEvent(event)\n\n      expect(prismaService.subscription.update).toHaveBeenCalledTimes(2)\n\n      console.log('✅ Webhook failure and retry handling completed')\n    })\n  })\n\n  describe('Customer Portal Integration Journey', () => {\n    let testCustomer: Stripe.Customer\n    let activeSubscription: Stripe.Subscription\n\n    beforeEach(async () => {\n      testCustomer = await mcpHelper.createTestCustomer({\n        email: `portal-${Date.now()}@example.com`,\n        name: 'Portal Test User'\n      })\n\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      activeSubscription = await mcpHelper.createTestSubscription({\n        customerId: testCustomer.id,\n        priceId: testPrices.STARTER.monthly.id,\n        paymentMethodId: paymentMethod.id\n      })\n    })\n\n    it('should create customer portal session for subscription management', async () => {\n      const userId = `e2e_portal_${Date.now()}`\n      \n      // Mock user with subscription\n      vi.mocked(prismaService.user.findUnique).mockResolvedValue({\n        id: userId,\n        email: testCustomer.email,\n        name: testCustomer.name,\n        Subscription: [{ stripeCustomerId: testCustomer.id }]\n      } as any)\n\n      // Step 1: Create portal session\n      const portalResult = await stripeBillingService.createCustomerPortalSession({\n        userId,\n        returnUrl: 'https://example.com/account/billing'\n      })\n\n      expect(portalResult.url).toMatch(/^https:\\/\\/billing\\.stripe\\.com/)\n\n      // Step 2: Verify portal session is accessible (we can't actually navigate to it in tests)\n      // But we can verify the URL structure is correct\n      const urlParts = new URL(portalResult.url)\n      expect(urlParts.hostname).toBe('billing.stripe.com')\n      expect(urlParts.pathname).toMatch(/^\\/session\\/bps_/)\n\n      console.log('✅ Customer portal session creation completed')\n    })\n  })\n\n  describe('Error Recovery and Edge Cases Journey', () => {\n    it('should handle partial payment failures with recovery', async () => {\n      const testCustomer = await mcpHelper.createTestCustomer({\n        email: `recovery-${Date.now()}@example.com`,\n        name: 'Recovery Test User'\n      })\n\n      // Step 1: Attempt subscription with declined card\n      const declinedPaymentMethod = await mcpHelper.createDeclinedPaymentMethod('CARD_DECLINED')\n      \n      await mcpHelper.getStripeClient().paymentMethods.attach(declinedPaymentMethod.id, {\n        customer: testCustomer.id  \n      })\n\n      let subscription: Stripe.Subscription\n      try {\n        subscription = await mcpHelper.createTestSubscription({\n          customerId: testCustomer.id,\n          priceId: testPrices.STARTER.monthly.id,\n          paymentMethodId: declinedPaymentMethod.id,\n          trialPeriodDays: 0\n        })\n      } catch (error) {\n        // Create subscription without payment method to simulate incomplete state\n        subscription = await mcpHelper.createTestSubscription({\n          customerId: testCustomer.id,\n          priceId: testPrices.STARTER.monthly.id,\n          trialPeriodDays: 0\n        })\n      }\n\n      // Step 2: Verify subscription is in incomplete state\n      const incompleteSubscription = await stripeService.getSubscription(subscription.id)\n      expect(incompleteSubscription!.status).toMatch(/^(incomplete|past_due)$/)\n\n      // Step 3: Add valid payment method for recovery\n      const validPaymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      // Step 4: Update subscription with valid payment method\n      await mcpHelper.getStripeClient().subscriptions.update(subscription.id, {\n        default_payment_method: validPaymentMethod.id\n      })\n\n      // Step 5: Retry the latest invoice\n      const invoices = await mcpHelper.getStripeClient().invoices.list({\n        customer: testCustomer.id,\n        subscription: subscription.id,\n        limit: 1\n      })\n\n      if (invoices.data.length > 0) {\n        const latestInvoice = invoices.data[0]\n        if (latestInvoice.status === 'open') {\n          try {\n            await mcpHelper.getStripeClient().invoices.pay(latestInvoice.id)\n          } catch (error) {\n            // May still fail in test mode, but that's expected\n          }\n        }\n      }\n\n      // Step 6: Verify recovery attempt was made\n      const recoveredSubscription = await stripeService.getSubscription(subscription.id)\n      expect(recoveredSubscription!.default_payment_method).toBe(validPaymentMethod.id)\n\n      console.log('✅ Payment failure recovery flow completed')\n    })\n\n    it('should handle concurrent operations gracefully', async () => {\n      const testCustomer = await mcpHelper.createTestCustomer({\n        email: `concurrent-${Date.now()}@example.com`,\n        name: 'Concurrent Test User'\n      })\n\n      const paymentMethod = await mcpHelper.createTestPaymentMethod({\n        customerId: testCustomer.id\n      })\n\n      // Step 1: Create multiple subscriptions concurrently\n      const concurrentPromises = [\n        mcpHelper.createTestSubscription({\n          customerId: testCustomer.id,\n          priceId: testPrices.STARTER.monthly.id,\n          paymentMethodId: paymentMethod.id,\n          metadata: { test: 'concurrent-1' }\n        }),\n        mcpHelper.createTestSubscription({\n          customerId: testCustomer.id,\n          priceId: testPrices.GROWTH.monthly.id,\n          paymentMethodId: paymentMethod.id,\n          metadata: { test: 'concurrent-2' }\n        }),\n        mcpHelper.createTestSubscription({\n          customerId: testCustomer.id,\n          priceId: testPrices.ENTERPRISE.monthly.id,\n          paymentMethodId: paymentMethod.id,\n          metadata: { test: 'concurrent-3' }\n        })\n      ]\n\n      const subscriptions = await Promise.all(concurrentPromises)\n      \n      expect(subscriptions).toHaveLength(3)\n      subscriptions.forEach((sub, index) => {\n        expect(sub.id).toMatch(/^sub_/)\n        expect(sub.customer).toBe(testCustomer.id)\n        expect(sub.metadata?.test).toBe(`concurrent-${index + 1}`)\n      })\n\n      // Step 2: Cancel all subscriptions concurrently\n      const cancelPromises = subscriptions.map(sub =>\n        mcpHelper.getStripeClient().subscriptions.cancel(sub.id)\n      )\n\n      const canceledSubscriptions = await Promise.all(cancelPromises)\n      canceledSubscriptions.forEach(sub => {\n        expect(sub.status).toBe('canceled')\n      })\n\n      console.log('✅ Concurrent operations handling completed')\n    })\n  })\n})