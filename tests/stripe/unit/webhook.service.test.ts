import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { Logger } from '@nestjs/common'\nimport { EventEmitter2 } from '@nestjs/event-emitter'\nimport { WebhookService } from '../../../apps/backend/src/stripe/webhook.service'\nimport { StripeBillingService } from '../../../apps/backend/src/stripe/stripe-billing.service'\nimport { StripeService } from '../../../apps/backend/src/stripe/stripe.service'\nimport { PrismaService } from '../../../apps/backend/src/prisma/prisma.service'\nimport type Stripe from 'stripe'\nimport { createMockStripeSubscription, createMockStripeInvoice, createMockStripeCustomer } from '../test-data/stripe-factories'\n\n// Mock dependencies\nconst mockBillingService = {\n  syncSubscriptionFromStripe: vi.fn(),\n  handleSubscriptionDeleted: vi.fn()\n} as any\n\nconst mockStripeService = {\n  client: {\n    customers: {\n      retrieve: vi.fn()\n    },\n    subscriptions: {\n      retrieve: vi.fn()\n    }\n  }\n} as any\n\nconst mockPrismaService = {\n  subscription: {\n    findUnique: vi.fn(),\n    update: vi.fn(),\n    updateMany: vi.fn()\n  }\n} as any\n\nconst mockNotificationService = {\n  sendPaymentMethodRequired: vi.fn(),\n  sendPaymentFailed: vi.fn(),\n  sendUpcomingInvoice: vi.fn(),\n  sendSubscriptionActivated: vi.fn()\n} as any\n\nconst mockFeatureAccessService = {\n  restrictUserAccess: vi.fn(),\n  restoreUserAccess: vi.fn()\n} as any\n\ndescribe('WebhookService - Comprehensive Unit Tests', () => {\n  let webhookService: WebhookService\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    \n    webhookService = new WebhookService(\n      mockBillingService,\n      mockStripeService,\n      mockPrismaService,\n      mockNotificationService,\n      mockFeatureAccessService\n    )\n\n    // Mock Logger to prevent console output during tests\n    vi.spyOn(Logger.prototype, 'log').mockImplementation(() => {})\n    vi.spyOn(Logger.prototype, 'error').mockImplementation(() => {})\n    vi.spyOn(Logger.prototype, 'warn').mockImplementation(() => {})\n    vi.spyOn(Logger.prototype, 'debug').mockImplementation(() => {})\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Webhook Event Routing', () => {\n    it('should route subscription created events correctly', async () => {\n      const mockSubscription = createMockStripeSubscription({\n        id: 'sub_test123',\n        status: 'active'\n      })\n\n      const event: Stripe.Event = {\n        id: 'evt_test123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.created',\n        data: {\n          object: mockSubscription as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledWith(mockSubscription)\n    })\n\n    it('should route subscription updated events correctly', async () => {\n      const mockSubscription = createMockStripeSubscription({\n        id: 'sub_test123',\n        status: 'active'\n      })\n\n      const event: Stripe.Event = {\n        id: 'evt_test123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.updated',\n        data: {\n          object: mockSubscription as any,\n          previous_attributes: { status: 'trialing' }\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledWith(mockSubscription)\n    })\n\n    it('should route subscription deleted events correctly', async () => {\n      const mockSubscription = createMockStripeSubscription({\n        id: 'sub_test123',\n        status: 'canceled'\n      })\n\n      const event: Stripe.Event = {\n        id: 'evt_test123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.deleted',  \n        data: {\n          object: mockSubscription as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      expect(mockBillingService.handleSubscriptionDeleted).toHaveBeenCalledWith('sub_test123')\n    })\n\n    it('should ignore unsupported event types', async () => {\n      const event: Stripe.Event = {\n        id: 'evt_test123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'account.updated', // Unsupported event type\n        data: {\n          object: {} as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      // Should not call any service methods\n      expect(mockBillingService.syncSubscriptionFromStripe).not.toHaveBeenCalled()\n      expect(mockBillingService.handleSubscriptionDeleted).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Subscription Event Handling', () => {\n    describe('handleSubscriptionUpdated', () => {\n      it('should handle trial ended without payment method', async () => {\n        const mockSubscription = createMockStripeSubscription({\n          id: 'sub_test123',\n          status: 'incomplete',\n          pause_collection: {\n            behavior: 'void'\n          } as any\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          stripeSubscriptionId: 'sub_test123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com',\n            name: 'Test User'\n          },\n          planType: 'STARTER',\n          trialEnd: new Date(Date.now() + 24 * 60 * 60 * 1000) // Tomorrow\n        }\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n        mockPrismaService.subscription.update.mockResolvedValue(mockDbSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.subscription.updated',\n          data: {\n            object: mockSubscription as any,\n            previous_attributes: { status: 'trialing' }\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledWith(mockSubscription)\n        expect(mockPrismaService.subscription.update).toHaveBeenCalledWith({\n          where: { stripeSubscriptionId: 'sub_test123' },\n          data: {\n            status: 'INCOMPLETE',\n            updatedAt: expect.any(Date)\n          }\n        })\n        expect(mockNotificationService.sendPaymentMethodRequired).toHaveBeenCalled()\n        expect(mockFeatureAccessService.restrictUserAccess).toHaveBeenCalledWith('user123', 'TRIAL_ENDED')\n      })\n\n      it('should handle subscription reactivation', async () => {\n        const mockSubscription = createMockStripeSubscription({\n          id: 'sub_test123',\n          status: 'active'\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          stripeSubscriptionId: 'sub_test123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com',\n            name: 'Test User'\n          },\n          planType: 'GROWTH'\n        }\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.subscription.updated',\n          data: {\n            object: mockSubscription as any,\n            previous_attributes: { status: 'incomplete' }\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendSubscriptionActivated).toHaveBeenCalledWith({\n          userId: 'user123',\n          userEmail: 'user@example.com',\n          userName: 'Test User',\n          subscriptionId: 'sub_test123',\n          planType: 'GROWTH'\n        })\n        expect(mockFeatureAccessService.restoreUserAccess).toHaveBeenCalledWith('user123', 'GROWTH')\n      })\n    })\n\n    describe('handleTrialWillEnd', () => {\n      it('should send payment method required email when no payment method', async () => {\n        const mockSubscription = createMockStripeSubscription({\n          id: 'sub_test123',\n          customer: 'cus_test123',\n          status: 'trialing'\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          stripeSubscriptionId: 'sub_test123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com',\n            name: 'Test User'\n          },\n          planType: 'STARTER',\n          trialEnd: new Date(Date.now() + 24 * 60 * 60 * 1000)\n        }\n\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123',\n          default_source: null,\n          invoice_settings: { default_payment_method: null }\n        })\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n        mockStripeService.client.customers.retrieve.mockResolvedValue(mockCustomer)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.subscription.trial_will_end',\n          data: {\n            object: mockSubscription as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendPaymentMethodRequired).toHaveBeenCalledWith({\n          userId: 'user123',\n          userEmail: 'user@example.com',\n          userName: 'Test User',\n          subscriptionId: 'sub_test123',\n          planType: 'STARTER',\n          trialEndDate: mockDbSubscription.trialEnd\n        })\n      })\n\n      it('should not send email when customer has payment method', async () => {\n        const mockSubscription = createMockStripeSubscription({\n          id: 'sub_test123',\n          customer: 'cus_test123',\n          status: 'trialing'\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          stripeSubscriptionId: 'sub_test123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com'\n          },\n          planType: 'STARTER'\n        }\n\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123',\n          invoice_settings: { default_payment_method: 'pm_test123' }\n        })\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n        mockStripeService.client.customers.retrieve.mockResolvedValue(mockCustomer)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.subscription.trial_will_end',\n          data: {\n            object: mockSubscription as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendPaymentMethodRequired).not.toHaveBeenCalled()\n      })\n\n      it('should handle subscription not found in database', async () => {\n        const mockSubscription = createMockStripeSubscription({\n          id: 'sub_unknown123',\n          customer: 'cus_test123'\n        })\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(null)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.subscription.trial_will_end',\n          data: {\n            object: mockSubscription as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        // Should not throw error, just log warning\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendPaymentMethodRequired).not.toHaveBeenCalled()\n      })\n    })\n  })\n\n  describe('Invoice Event Handling', () => {\n    describe('handlePaymentSucceeded', () => {\n      it('should update subscription status to active', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: 'sub_test123'\n        })\n\n        mockPrismaService.subscription.update.mockResolvedValue({\n          id: 'sub_db_123',\n          status: 'ACTIVE'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.payment_succeeded',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockPrismaService.subscription.update).toHaveBeenCalledWith({\n          where: { stripeSubscriptionId: 'sub_test123' },\n          data: { status: 'ACTIVE' }\n        })\n      })\n\n      it('should handle invoice without subscription', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: null\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.payment_succeeded',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockPrismaService.subscription.update).not.toHaveBeenCalled()\n      })\n    })\n\n    describe('handlePaymentFailed', () => {\n      it('should handle payment failure with notification', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: 'sub_test123',\n          customer_email: 'user@example.com',\n          attempt_count: 2,\n          amount_due: 1900,\n          currency: 'usd'\n        })\n\n        const mockUpdatedSubscription = {\n          id: 'sub_db_123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com',\n            name: 'Test User'\n          },\n          planType: 'STARTER'\n        }\n\n        mockPrismaService.subscription.update.mockResolvedValue(mockUpdatedSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.payment_failed',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockPrismaService.subscription.update).toHaveBeenCalledWith({\n          where: { stripeSubscriptionId: 'sub_test123' },\n          data: { status: 'PAST_DUE' },\n          include: { User: true }\n        })\n\n        expect(mockNotificationService.sendPaymentFailed).toHaveBeenCalledWith({\n          userId: 'user123',\n          userEmail: 'user@example.com',\n          userName: 'Test User',\n          subscriptionId: 'sub_test123',\n          planType: 'STARTER',\n          attemptCount: 2,\n          amountDue: 1900,\n          currency: 'usd'\n        })\n      })\n\n      it('should restrict access after multiple failed attempts', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: 'sub_test123',\n          attempt_count: 3, // Third attempt\n          amount_due: 1900,\n          currency: 'usd'\n        })\n\n        const mockUpdatedSubscription = {\n          id: 'sub_db_123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com'\n          },\n          planType: 'STARTER'\n        }\n\n        mockPrismaService.subscription.update.mockResolvedValue(mockUpdatedSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.payment_failed',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockFeatureAccessService.restrictUserAccess).toHaveBeenCalledWith('user123', 'PAYMENT_FAILED')\n      })\n\n      it('should handle invoice without subscription gracefully', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: null,\n          customer_email: 'user@example.com'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.payment_failed',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockPrismaService.subscription.update).not.toHaveBeenCalled()\n      })\n    })\n\n    describe('handleInvoiceUpcoming', () => {\n      it('should send upcoming invoice notification', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: 'sub_test123',\n          amount_due: 4900,\n          currency: 'usd',\n          period_end: Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60, // 30 days from now\n          lines: {\n            data: [{\n              price: {\n                recurring: { interval: 'month' }\n              }\n            }]\n          } as any\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com',\n            name: 'Test User'\n          },\n          planType: 'GROWTH'\n        }\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.upcoming',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendUpcomingInvoice).toHaveBeenCalledWith({\n          userId: 'user123',\n          userEmail: 'user@example.com',\n          userName: 'Test User',\n          subscriptionId: 'sub_test123',\n          planType: 'GROWTH',\n          invoiceAmount: 4900,\n          currency: 'usd',\n          invoiceDate: expect.any(Date),\n          billingInterval: 'monthly'\n        })\n      })\n\n      it('should detect annual billing interval', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          subscription: 'sub_test123',\n          amount_due: 49000,\n          currency: 'usd',\n          period_end: Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60, // 365 days from now\n          lines: {\n            data: [{\n              price: {\n                recurring: { interval: 'year' }\n              }\n            }]\n          } as any\n        })\n\n        const mockDbSubscription = {\n          id: 'sub_db_123',\n          User: {\n            id: 'user123',\n            email: 'user@example.com'\n          },\n          planType: 'GROWTH'\n        }\n\n        mockPrismaService.subscription.findUnique.mockResolvedValue(mockDbSubscription)\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.upcoming',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockNotificationService.sendUpcomingInvoice).toHaveBeenCalledWith(\n          expect.objectContaining({\n            billingInterval: 'annual'\n          })\n        )\n      })\n    })\n  })\n\n  describe('Checkout Session Event Handling', () => {\n    describe('handleCheckoutCompleted', () => {\n      it('should process completed subscription checkout', async () => {\n        const mockSession: Partial<Stripe.Checkout.Session> = {\n          id: 'cs_test123',\n          mode: 'subscription',\n          subscription: 'sub_test123',\n          payment_status: 'paid',\n          metadata: {\n            userId: 'user123'\n          },\n          customer_details: {\n            email: 'user@example.com'\n          } as any\n        }\n\n        const mockStripeSubscription = createMockStripeSubscription({\n          id: 'sub_test123',\n          status: 'active'\n        })\n\n        mockStripeService.client.subscriptions.retrieve.mockResolvedValue(mockStripeSubscription)\n        mockPrismaService.user.findUnique.mockResolvedValue({\n          id: 'user123',\n          email: 'user@example.com',\n          Subscription: []\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'checkout.session.completed',\n          data: {\n            object: mockSession as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockStripeService.client.subscriptions.retrieve).toHaveBeenCalledWith('sub_test123')\n        expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledWith(mockStripeSubscription)\n      })\n\n      it('should ignore non-subscription checkout sessions', async () => {\n        const mockSession: Partial<Stripe.Checkout.Session> = {\n          id: 'cs_test123',\n          mode: 'payment', // One-time payment, not subscription\n          payment_status: 'paid'\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'checkout.session.completed',\n          data: {\n            object: mockSession as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockBillingService.syncSubscriptionFromStripe).not.toHaveBeenCalled()\n      })\n\n      it('should handle missing userId or subscriptionId', async () => {\n        const mockSession: Partial<Stripe.Checkout.Session> = {\n          id: 'cs_test123',\n          mode: 'subscription',\n          subscription: 'sub_test123',\n          metadata: {}, // Missing userId\n          customer_details: {\n            email: 'user@example.com'\n          } as any\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'checkout.session.completed',\n          data: {\n            object: mockSession as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockBillingService.syncSubscriptionFromStripe).not.toHaveBeenCalled()\n      })\n\n      it('should handle subscription retrieval errors gracefully', async () => {\n        const mockSession: Partial<Stripe.Checkout.Session> = {\n          id: 'cs_test123',\n          mode: 'subscription',\n          subscription: 'sub_test123',\n          metadata: {\n            userId: 'user123'\n          },\n          customer_details: {\n            email: 'user@example.com'\n          } as any\n        }\n\n        mockStripeService.client.subscriptions.retrieve.mockRejectedValue(\n          new Error('Subscription not found')\n        )\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'checkout.session.completed',\n          data: {\n            object: mockSession as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        // Should not throw error\n        await webhookService.handleWebhookEvent(event)\n\n        expect(mockBillingService.syncSubscriptionFromStripe).not.toHaveBeenCalled()\n      })\n    })\n  })\n\n  describe('Event Idempotency', () => {\n    it('should skip processing duplicate events', async () => {\n      const mockSubscription = createMockStripeSubscription({\n        id: 'sub_test123'\n      })\n\n      const event: Stripe.Event = {\n        id: 'evt_duplicate123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.created',\n        data: {\n          object: mockSubscription as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      // Process event first time\n      await webhookService.handleWebhookEvent(event)\n      expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledTimes(1)\n\n      // Process same event again (should be skipped)\n      await webhookService.handleWebhookEvent(event)\n      expect(mockBillingService.syncSubscriptionFromStripe).toHaveBeenCalledTimes(1)\n    })\n\n    it('should clean up old event IDs to prevent memory leak', async () => {\n      const webhookServiceInstance = webhookService as any\n      \n      // Fill up processed events set\n      for (let i = 0; i < 10001; i++) {\n        webhookServiceInstance.processedEvents.add(`evt_${i}`)\n      }\n\n      expect(webhookServiceInstance.processedEvents.size).toBe(10001)\n\n      const mockSubscription = createMockStripeSubscription()\n      const event: Stripe.Event = {\n        id: 'evt_cleanup_trigger',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.created',\n        data: {\n          object: mockSubscription as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      // Should have triggered cleanup\n      expect(webhookServiceInstance.processedEvents.size).toBeLessThan(10001)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('should handle and re-throw processing errors', async () => {\n      const mockSubscription = createMockStripeSubscription()\n      mockBillingService.syncSubscriptionFromStripe.mockRejectedValue(\n        new Error('Database connection failed')\n      )\n\n      const event: Stripe.Event = {\n        id: 'evt_error123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'customer.subscription.created',\n        data: {\n          object: mockSubscription as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await expect(webhookService.handleWebhookEvent(event))\n        .rejects.toThrow('Database connection failed')\n    })\n\n    it('should handle database update errors during payment failure', async () => {\n      const mockInvoice = createMockStripeInvoice({\n        subscription: 'sub_test123',\n        attempt_count: 1\n      })\n\n      mockPrismaService.subscription.update.mockRejectedValue(\n        new Error('Database update failed')\n      )\n\n      const event: Stripe.Event = {\n        id: 'evt_db_error123',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'invoice.payment_failed',\n        data: {\n          object: mockInvoice as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      // Should not throw (error is caught and logged)\n      await webhookService.handleWebhookEvent(event)\n\n      expect(mockPrismaService.subscription.update).toHaveBeenCalled()\n    })\n  })\n\n  describe('Helper Methods', () => {\n    it('should get billing interval from invoice correctly', async () => {\n      const webhookServiceInstance = webhookService as any\n      \n      const monthlyInvoice = {\n        lines: {\n          data: [{\n            price: {\n              recurring: { interval: 'month' }\n            }\n          }]\n        }\n      }\n\n      const annualInvoice = {\n        lines: {\n          data: [{\n            price: {\n              recurring: { interval: 'year' }\n            }\n          }]\n        }\n      }\n\n      const emptyInvoice = {\n        lines: {\n          data: []\n        }\n      }\n\n      expect(webhookServiceInstance.getBillingIntervalFromInvoice(monthlyInvoice))\n        .toBe('monthly')\n      expect(webhookServiceInstance.getBillingIntervalFromInvoice(annualInvoice))\n        .toBe('annual')\n      expect(webhookServiceInstance.getBillingIntervalFromInvoice(emptyInvoice))\n        .toBe('monthly') // Default\n    })\n  })\n\n  // ========================\n  // NEW EVENT HANDLER TESTS\n  // ========================\n\n  describe('Customer Event Handlers', () => {\n    describe('handleCustomerCreated', () => {\n      it('should log customer creation', async () => {\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123',\n          email: 'user@example.com'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.created',\n          data: {\n            object: mockCustomer as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        // Should complete without errors\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Customer created: cus_test123')\n        )\n      })\n    })\n\n    describe('handleCustomerUpdated', () => {\n      it('should log customer updates and email changes', async () => {\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123',\n          email: 'newemail@example.com'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.updated',\n          data: {\n            object: mockCustomer as any,\n            previous_attributes: {\n              email: 'oldemail@example.com'\n            }\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Customer updated: cus_test123')\n        )\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('email changed from oldemail@example.com to newemail@example.com')\n        )\n      })\n\n      it('should handle customer updates without email changes', async () => {\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123',\n          name: 'New Name'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.updated',\n          data: {\n            object: mockCustomer as any,\n            previous_attributes: {\n              name: 'Old Name'\n            }\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Customer updated: cus_test123')\n        )\n      })\n    })\n\n    describe('handleCustomerDeleted', () => {\n      it('should log customer deletion', async () => {\n        const mockCustomer = createMockStripeCustomer({\n          id: 'cus_test123'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'customer.deleted',\n          data: {\n            object: mockCustomer as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Customer deleted: cus_test123')\n        )\n      })\n    })\n  })\n\n  describe('Invoice Event Handlers', () => {\n    describe('handleInvoiceCreated', () => {\n      it('should log invoice creation', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          status: 'draft'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.created',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Invoice created: in_test123')\n        )\n      })\n    })\n\n    describe('handleInvoiceFinalized', () => {\n      it('should log invoice finalization', async () => {\n        const mockInvoice = createMockStripeInvoice({\n          id: 'in_test123',\n          status: 'open'\n        })\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'invoice.finalized',\n          data: {\n            object: mockInvoice as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Invoice finalized: in_test123')\n        )\n      })\n    })\n  })\n\n  describe('Payment Intent Event Handlers', () => {\n    describe('handlePaymentIntentCreated', () => {\n      it('should log payment intent creation', async () => {\n        const mockPaymentIntent: Partial<Stripe.PaymentIntent> = {\n          id: 'pi_test123',\n          status: 'requires_payment_method',\n          amount: 2000,\n          currency: 'usd'\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'payment_intent.created',\n          data: {\n            object: mockPaymentIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Payment intent created: pi_test123')\n        )\n      })\n    })\n\n    describe('handlePaymentIntentSucceeded', () => {\n      it('should log payment intent success', async () => {\n        const mockPaymentIntent: Partial<Stripe.PaymentIntent> = {\n          id: 'pi_test123',\n          status: 'succeeded',\n          amount: 2000,\n          currency: 'usd'\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'payment_intent.succeeded',\n          data: {\n            object: mockPaymentIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Payment intent succeeded: pi_test123')\n        )\n      })\n    })\n\n    describe('handlePaymentIntentPaymentFailed', () => {\n      it('should log payment intent failure with error details', async () => {\n        const mockPaymentIntent: Partial<Stripe.PaymentIntent> = {\n          id: 'pi_test123',\n          status: 'requires_payment_method',\n          last_payment_error: {\n            code: 'card_declined',\n            message: 'Your card was declined.',\n            type: 'card_error'\n          } as any\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'payment_intent.payment_failed',\n          data: {\n            object: mockPaymentIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          expect.stringContaining('Payment intent failed: pi_test123')\n        )\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          'Payment failure details:',\n          expect.objectContaining({\n            code: 'card_declined',\n            message: 'Your card was declined.',\n            type: 'card_error'\n          })\n        )\n      })\n\n      it('should handle payment intent failure without error details', async () => {\n        const mockPaymentIntent: Partial<Stripe.PaymentIntent> = {\n          id: 'pi_test123',\n          status: 'requires_payment_method',\n          last_payment_error: null\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'payment_intent.payment_failed',\n          data: {\n            object: mockPaymentIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          expect.stringContaining('Payment intent failed: pi_test123')\n        )\n      })\n    })\n  })\n\n  describe('Checkout Session Event Handlers', () => {\n    describe('handleCheckoutSessionExpired', () => {\n      it('should log checkout session expiration', async () => {\n        const mockSession: Partial<Stripe.Checkout.Session> = {\n          id: 'cs_test123',\n          mode: 'subscription',\n          status: 'expired'\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'checkout.session.expired',\n          data: {\n            object: mockSession as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Checkout session expired: cs_test123')\n        )\n      })\n    })\n  })\n\n  describe('Setup Intent Event Handlers', () => {\n    describe('handleSetupIntentSucceeded', () => {\n      it('should log setup intent success', async () => {\n        const mockSetupIntent: Partial<Stripe.SetupIntent> = {\n          id: 'seti_test123',\n          status: 'succeeded',\n          customer: 'cus_test123',\n          payment_method: 'pm_test123'\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'setup_intent.succeeded',\n          data: {\n            object: mockSetupIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.log).toHaveBeenCalledWith(\n          expect.stringContaining('Setup intent succeeded: seti_test123')\n        )\n      })\n    })\n\n    describe('handleSetupIntentSetupFailed', () => {\n      it('should log setup intent failure with error details', async () => {\n        const mockSetupIntent: Partial<Stripe.SetupIntent> = {\n          id: 'seti_test123',\n          status: 'requires_payment_method',\n          last_setup_error: {\n            code: 'card_declined',\n            message: 'Your card was declined.',\n            type: 'card_error'\n          } as any\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'setup_intent.setup_failed',\n          data: {\n            object: mockSetupIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          expect.stringContaining('Setup intent failed: seti_test123')\n        )\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          'Setup intent failure details:',\n          expect.objectContaining({\n            code: 'card_declined',\n            message: 'Your card was declined.',\n            type: 'card_error'\n          })\n        )\n      })\n\n      it('should handle setup intent failure without error details', async () => {\n        const mockSetupIntent: Partial<Stripe.SetupIntent> = {\n          id: 'seti_test123',\n          status: 'requires_payment_method',\n          last_setup_error: null\n        }\n\n        const event: Stripe.Event = {\n          id: 'evt_test123',\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: 'setup_intent.setup_failed',\n          data: {\n            object: mockSetupIntent as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        await webhookService.handleWebhookEvent(event)\n\n        expect(Logger.prototype.warn).toHaveBeenCalledWith(\n          expect.stringContaining('Setup intent failed: seti_test123')\n        )\n      })\n    })\n  })\n\n  describe('Event Type Coverage', () => {\n    it('should handle all defined webhook event types', async () => {\n      // Test that we have handlers for all event types defined in WEBHOOK_EVENT_TYPES\n      const eventTypes = [\n        'customer.created',\n        'customer.updated', \n        'customer.deleted',\n        'customer.subscription.created',\n        'customer.subscription.updated',\n        'customer.subscription.deleted',\n        'customer.subscription.trial_will_end',\n        'customer.subscription.paused',\n        'customer.subscription.resumed',\n        'invoice.created',\n        'invoice.finalized',\n        'invoice.payment_succeeded',\n        'invoice.payment_failed',\n        'invoice.payment_action_required',\n        'invoice.upcoming',\n        'payment_intent.created',\n        'payment_intent.succeeded',\n        'payment_intent.payment_failed',\n        'payment_intent.requires_action',\n        'charge.failed',\n        'checkout.session.completed',\n        'checkout.session.expired',\n        'setup_intent.succeeded',\n        'setup_intent.setup_failed'\n      ]\n\n      for (const eventType of eventTypes) {\n        const event: Stripe.Event = {\n          id: `evt_test_${eventType.replace(/\\./g, '_')}`,\n          object: 'event',\n          created: Math.floor(Date.now() / 1000),\n          type: eventType as any,\n          data: {\n            object: { id: 'test_object' } as any,\n            previous_attributes: {}\n          },\n          api_version: '2024-06-20',\n          livemode: false,\n          pending_webhooks: 1,\n          request: {\n            id: 'req_test123',\n            idempotency_key: null\n          }\n        }\n\n        // Should not throw for any supported event type\n        await expect(webhookService.handleWebhookEvent(event)).resolves.not.toThrow()\n      }\n    })\n\n    it('should log unsupported event types without throwing', async () => {\n      const event: Stripe.Event = {\n        id: 'evt_unsupported',\n        object: 'event',\n        created: Math.floor(Date.now() / 1000),\n        type: 'account.updated' as any, // Unsupported event type\n        data: {\n          object: { id: 'acct_test' } as any,\n          previous_attributes: {}\n        },\n        api_version: '2024-06-20',\n        livemode: false,\n        pending_webhooks: 1,\n        request: {\n          id: 'req_test123',\n          idempotency_key: null\n        }\n      }\n\n      await webhookService.handleWebhookEvent(event)\n\n      expect(Logger.prototype.log).toHaveBeenCalledWith(\n        expect.stringContaining('No handler for event type: account.updated')\n      )\n    })\n  })\n})"