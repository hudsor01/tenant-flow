---
phase: 01-critical-security
plan: 02
type: execute
---

<objective>
Fix RLS policy performance issues by wrapping bare `auth.uid()` calls in `(SELECT ...)` for query plan caching.

Purpose: Improve RLS query performance by ensuring `auth.uid()` is evaluated once per statement instead of per-row.
Output: New migration that updates policies in multiple files to use the `(SELECT auth.uid())` pattern.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/1-critical-security/1-RESEARCH.md

**Why this matters (from research):**
Bare `auth.uid()` calls in RLS policies are evaluated per-row. Wrapping in `(SELECT auth.uid())` creates an initPlan that caches the value per-statement, significantly improving performance on large tables.

**Files with bare auth.uid() calls:**
1. `20251216120000_notification_settings.sql` - 4 occurrences
2. `20251216123000_notifications_authenticated_policies.sql` - 2 occurrences
3. `20251220030000_fix_rls_policy_gaps.sql` - 6 occurrences
4. `20251110160000_create_lease_documents_bucket.sql` - 4 occurrences (storage policies)
5. `20251220060000_secure_stripe_schema_rls.sql` - 8 occurrences
6. `20251220061000_add_payment_methods_user_access.sql` - 2 occurrences
7. `20251220050000_add_error_monitoring.sql` - 1 occurrence

**Total: ~27 bare auth.uid() calls to fix**

**Approach:** Create a single consolidation migration that recreates all affected policies with the correct pattern. This is cleaner than modifying 7 existing migration files.

**Reference implementation:**
@supabase/migrations/20251225182240_fix_rls_policy_security_and_performance.sql (already uses correct pattern)
@supabase/migrations/20260103120000_fix_properties_rls_comprehensive.sql (already uses correct pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit current policies to identify exact fixes needed</name>
  <files>N/A - audit only</files>
  <action>
Run the following SQL query against the local Supabase database to identify policies still using bare `auth.uid()`:

```bash
# Start local Supabase if not running
supabase start

# Query for policies with bare auth.uid()
supabase db query --local "
SELECT
  schemaname,
  tablename,
  policyname,
  CASE
    WHEN qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(select auth.uid())%' THEN 'USING needs fix'
    ELSE 'USING OK'
  END as using_status,
  CASE
    WHEN with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(select auth.uid())%' THEN 'WITH CHECK needs fix'
    ELSE 'WITH CHECK OK'
  END as check_status
FROM pg_policies
WHERE
  (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(select auth.uid())%')
  OR (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(select auth.uid())%')
ORDER BY schemaname, tablename;
"
```

Save the output to determine exactly which policies need updating. Some policies may have already been fixed by later migrations.
  </action>
  <verify>Query executes successfully and produces a list of policies (may be empty if all already fixed)</verify>
  <done>Have a definitive list of policies that still need the `(SELECT auth.uid())` fix, or confirmation that none remain</done>
</task>

<task type="auto">
  <name>Task 2: Create consolidation migration for remaining bare auth.uid() fixes</name>
  <files>supabase/migrations/YYYYMMDDHHMMSS_optimize_auth_uid_performance.sql</files>
  <action>
Based on the audit results from Task 1, create a migration that fixes any remaining bare `auth.uid()` calls.

**If audit shows no remaining issues:** Create a minimal migration with a comment documenting that all policies already use the correct pattern.

**If audit shows issues:** Create a migration that recreates each affected policy. Use this template for each policy:

```sql
-- Migration: Optimize RLS performance by wrapping auth.uid() in (SELECT ...)
-- Impact: Queries will cache auth.uid() per-statement instead of per-row

-- ============================================================================
-- NOTIFICATION_SETTINGS POLICIES (if needed based on audit)
-- ============================================================================

DROP POLICY IF EXISTS "policy_name" ON schema.table;
CREATE POLICY "policy_name" ON schema.table
FOR [SELECT|INSERT|UPDATE|DELETE] TO authenticated
USING ((select auth.uid()) = user_id)
WITH CHECK ((select auth.uid()) = user_id);  -- Only for UPDATE policies
```

**Key patterns:**
- SELECT: `USING` only
- INSERT: `WITH CHECK` only
- UPDATE: Both `USING` and `WITH CHECK`
- DELETE: `USING` only

**Do NOT touch storage.objects policies** - those use a different pattern with `storage.foldername()` that works differently.
  </action>
  <verify>
Run `supabase db reset` to verify migration applies cleanly. Re-run the audit query from Task 1 to confirm no bare `auth.uid()` calls remain.
  </verify>
  <done>
Migration file exists, applies cleanly, and audit query returns no remaining bare `auth.uid()` calls (or returns only storage.objects policies which are acceptable).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Performance optimization migration for auth.uid() caching</what-built>
  <how-to-verify>
    1. Review the new migration file
    2. Run `supabase db reset` locally to verify it applies
    3. Re-run the audit query to confirm all policies are optimized
    4. Verify no functionality is broken by running `pnpm test:unit:backend`
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Audit query ran and identified remaining issues (or confirmed none)
- [ ] Migration file created (even if minimal)
- [ ] Migration applies cleanly during `supabase db reset`
- [ ] Re-audit confirms no bare `auth.uid()` calls remain in public schema
- [ ] Backend tests pass (`pnpm test:unit:backend`)
</verification>

<success_criteria>

- All RLS policies in public schema use `(SELECT auth.uid())` pattern
- Migration is idempotent (uses DROP IF EXISTS)
- No test regressions
- Human verification checkpoint passed
- Phase 1 complete, ready for next phase
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security/01-02-SUMMARY.md`
</output>
