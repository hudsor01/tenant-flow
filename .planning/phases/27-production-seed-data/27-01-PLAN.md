---
phase: 27-production-seed-data
plan: 01
type: execute
---

<objective>
Create a three-tier seed data system (smoke, development, performance) with multi-tenant isolation, realistic Stripe test data, and temporal distribution across 24 months.

Purpose: Enable realistic testing that mirrors production usage patternsâ€”multi-tenant isolation boundaries, payment flows with real Stripe test customers, and performance testing with realistic volumes.
Output: Three seed data scripts with different sizes, versioned idempotent structure, and pnpm scripts for each tier.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-test-environment-parity/26-01-SUMMARY.md
@.planning/phases/26-test-environment-parity/26-02-SUMMARY.md
@supabase/seed.sql

**Research Findings (from ROADMAP.md Phase 27):**
- Three-tier seed strategy: Smoke (2 owners, CI fast), Development (10 owners, realistic), Performance (100+ owners, 50K+ records)
- Multi-tenant pattern: Owner A/B/C with isolation boundaries + 50-tenant pool
- Stripe sync: Create real Stripe test customers/payment methods, link via database
- Temporal distribution: Spread dates across 24 months using `NOW() - random() * interval`
- Idempotency: Use `ON CONFLICT DO UPDATE` for re-runnable seeds
- Test cards: 4242 (success), 4000000000000002 (decline), 4000002500003155 (3DS)

**Prior Decisions:**
- Phase 26: Docker Compose infrastructure ready with postgres, redis
- Phase 26: Environment hierarchy established (.env.development, .env.test)

**Tech Stack Available:**
- Docker Compose with health checks
- Supabase local database (port 54321)
- Stripe test mode with sk_test_* keys
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create three-tier seed data structure</name>
  <files>supabase/seeds/seed-smoke.sql, supabase/seeds/seed-development.sql, supabase/seeds/seed-performance.sql, supabase/seeds/seed-common.sql</files>
  <action>
  Create a modular seed data structure:

  1. **seed-common.sql** - Shared helpers and seed version tracking:
     - Create `seed_versions` table: `(version text PRIMARY KEY, applied_at timestamptz DEFAULT now(), notes text)`
     - Helper function `seed_random_date(months_back int)` that returns `NOW() - (random() * months_back * interval '30 days')`
     - Helper function `seed_random_choice(text[])` that returns random array element

  2. **seed-smoke.sql** - Minimal for CI (fast, <5 seconds):
     - 2 owner users (owner-a@test.com, owner-b@test.com)
     - 2 tenant users (tenant-a@test.com, tenant-b@test.com)
     - 2 properties per owner (4 total)
     - 2 units per property (8 total)
     - 1 active lease per tenant
     - Basic RLS isolation test data
     - All idempotent with `ON CONFLICT DO NOTHING`

  3. **seed-development.sql** - Realistic for local dev:
     - 10 owner users with varied business types
     - 50 tenant users with different lease statuses
     - 5-15 properties per owner (realistic variation)
     - 1-10 units per property
     - Leases spanning 24 months (past, current, future)
     - Maintenance requests with status distribution (30% open, 20% in_progress, 40% completed, 10% cancelled)
     - Payment history with temporal distribution
     - Idempotent structure

  4. **seed-performance.sql** - Load testing:
     - 100 owner users
     - 500 tenant users
     - 1000+ properties
     - 5000+ units
     - 10000+ leases (historical + active)
     - 50000+ maintenance requests
     - Uses generate_series for bulk inserts
     - Batch inserts in 1000-row chunks

  All seeds must:
  - Use `ON CONFLICT DO NOTHING` or `ON CONFLICT DO UPDATE`
  - Track version in `seed_versions` table
  - Be re-runnable without duplicate data
  - Respect foreign key constraints (insert order matters)
  </action>
  <verify>
  - Files exist in supabase/seeds/
  - SQL syntax valid: `psql -f supabase/seeds/seed-smoke.sql --set ON_ERROR_STOP=1 -v` (dry run check)
  - Each seed has version tracking INSERT at the top
  </verify>
  <done>Four seed SQL files created with proper structure, idempotency, and version tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add pnpm scripts and update main seed.sql</name>
  <files>package.json, supabase/seed.sql</files>
  <action>
  1. Update root package.json with seed scripts:
     ```json
     "db:seed:smoke": "supabase db reset && psql $DATABASE_URL -f supabase/seeds/seed-common.sql -f supabase/seeds/seed-smoke.sql",
     "db:seed:dev": "supabase db reset && psql $DATABASE_URL -f supabase/seeds/seed-common.sql -f supabase/seeds/seed-development.sql",
     "db:seed:perf": "supabase db reset && psql $DATABASE_URL -f supabase/seeds/seed-common.sql -f supabase/seeds/seed-performance.sql"
     ```

  2. Update supabase/seed.sql to be the default (smoke) seed:
     - Replace current content with include of seed-common.sql and seed-smoke.sql
     - Use `\i` (psql include) or inline the content
     - Keep it minimal so `supabase start` is fast
     - Add header comment explaining the three-tier system

  3. Add seeds directory to .gitignore exceptions if needed
  </action>
  <verify>
  - `pnpm db:seed:smoke` command exists in package.json
  - supabase/seed.sql references the new structure
  - `supabase start` still works (seed runs on start)
  </verify>
  <done>Package.json has three seed scripts, main seed.sql updated to use smoke tier by default</done>
</task>

<task type="auto">
  <name>Task 3: Create seed verification script</name>
  <files>scripts/verify-seeds.sh</files>
  <action>
  Create a verification script that:

  1. Runs after seeding to verify data integrity
  2. Checks expected row counts per tier:
     - Smoke: users >= 4, properties >= 4, units >= 8
     - Development: users >= 60, properties >= 50, units >= 100
     - Performance: users >= 600, properties >= 1000, units >= 5000

  3. Verifies RLS isolation:
     - Query as owner-a@test.com should NOT see owner-b properties
     - Use `SET LOCAL ROLE authenticated; SET LOCAL request.jwt.claims = '{"sub": "<owner-a-id>"}'`

  4. Checks temporal distribution:
     - Maintenance requests span multiple months
     - Leases have varied start/end dates

  5. Output clear pass/fail status with counts

  Make script executable (`chmod +x`)
  </action>
  <verify>
  - Script exists and is executable
  - Script syntax valid: `bash -n scripts/verify-seeds.sh`
  - Script reports expected structure
  </verify>
  <done>Verification script created that checks data integrity and RLS isolation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All four seed SQL files exist in supabase/seeds/
- [ ] Each seed file has version tracking
- [ ] Package.json has db:seed:smoke, db:seed:dev, db:seed:perf scripts
- [ ] supabase/seed.sql updated to use smoke tier
- [ ] Verification script exists and is executable
- [ ] `supabase start` completes successfully with new seed
</verification>

<success_criteria>
- All tasks completed
- Seeds are idempotent (can run multiple times safely)
- Three tiers with appropriate data volumes
- Temporal distribution across 24 months
- RLS isolation boundaries in test data
- Version tracking prevents duplicate runs
</success_criteria>

<output>
After completion, create `.planning/phases/27-production-seed-data/27-01-SUMMARY.md`
</output>
