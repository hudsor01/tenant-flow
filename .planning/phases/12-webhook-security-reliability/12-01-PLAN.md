---
phase: 12-webhook-security-reliability
plan: 01
type: execute
---

<objective>
Create PostgreSQL RPC functions that wrap webhook-related database operations in transactions, ensuring atomicity.

Purpose: Prevent partial failures where one table updates but another fails, leaving inconsistent state.
Output: SQL migration with transaction-wrapped RPC functions for payment and subscription webhook handlers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-webhook-security-reliability/12-CONTEXT.md
@.planning/phases/12-webhook-security-reliability/12-RESEARCH.md

# Prior phase context
@.planning/phases/11-stripe-backend-hardening/11-04-SUMMARY.md

# Current webhook code
@apps/backend/src/modules/billing/webhooks/handlers/payment-webhook.handler.ts
@apps/backend/src/modules/billing/webhooks/handlers/subscription-webhook.handler.ts

**From RESEARCH.md:**
- Pattern 3: Transaction Wrapping (MISSING - NEEDS IMPLEMENTATION)
- PostgreSQL RPC functions run in implicit transaction
- Create dedicated RPC per handler type

**Current problem (payment-webhook.handler.ts:301-325):**
```typescript
const [updateResult, transactionResult] = await Promise.all([
  client.from('rent_payments').update(...),
  client.from('payment_transactions').upsert(...)
])
// If second operation fails, first already committed - inconsistent state
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment intent webhook transaction RPC</name>
  <files>supabase/migrations/YYYYMMDDHHmmss_add_webhook_transaction_rpcs.sql</files>
  <action>
Create a new migration file with PostgreSQL RPC function `process_payment_intent_failed`:

1. Function signature:
   - p_rent_payment_id UUID
   - p_payment_intent_id TEXT
   - p_amount INTEGER
   - p_failure_reason TEXT
   - Returns VOID

2. Function body (all in single transaction):
   - UPDATE rent_payments SET status='failed', updated_at=NOW() WHERE id=p_rent_payment_id
   - INSERT INTO payment_transactions (rent_payment_id, stripe_payment_intent_id, status, amount, failure_reason, attempted_at)
     ON CONFLICT (rent_payment_id, stripe_payment_intent_id, status) DO NOTHING
   - If any operation fails, entire transaction rolls back automatically

3. Security: SECURITY DEFINER with explicit search_path

Use timestamp format YYYYMMDDHHMMSS in UTC for migration filename.
  </action>
  <verify>
Run: npx supabase db push --dry-run
Confirm no syntax errors in migration output
  </verify>
  <done>Migration file exists with process_payment_intent_failed RPC that wraps both operations in implicit transaction</done>
</task>

<task type="auto">
  <name>Task 2: Create subscription webhook transaction RPC</name>
  <files>supabase/migrations/YYYYMMDDHHmmss_add_webhook_transaction_rpcs.sql</files>
  <action>
Add to the same migration file (append, don't create new file):

1. Create RPC function `process_subscription_status_change`:
   - p_subscription_id TEXT
   - p_new_status TEXT (maps to lease_status)
   - p_subscription_failure_reason TEXT (nullable)
   - Returns VOID

2. Function body:
   - SELECT id INTO v_lease_id FROM leases WHERE stripe_subscription_id = p_subscription_id
   - If not found, RETURN (no error, just skip)
   - UPDATE leases SET lease_status = p_new_status, subscription_failure_reason = p_subscription_failure_reason, updated_at = NOW() WHERE id = v_lease_id

3. Add second RPC `confirm_lease_subscription`:
   - p_lease_id UUID
   - p_subscription_id TEXT
   - Returns VOID

4. Function body:
   - UPDATE leases SET stripe_subscription_id = p_subscription_id, stripe_subscription_status = 'active', subscription_failure_reason = NULL, updated_at = NOW()
     WHERE id = p_lease_id AND stripe_subscription_status = 'pending'
   - Only updates if still pending (idempotent)

Both functions: SECURITY DEFINER with explicit search_path
  </action>
  <verify>
Run: npx supabase db push --dry-run
Confirm all 3 RPC functions defined without errors
  </verify>
  <done>Migration file contains process_payment_intent_failed, process_subscription_status_change, and confirm_lease_subscription RPCs</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Migration file exists in supabase/migrations/
- [ ] `npx supabase db push --dry-run` shows no errors
- [ ] All 3 RPC functions are defined
- [ ] Each function uses SECURITY DEFINER with search_path
- [ ] Function bodies use implicit transactions (no explicit BEGIN/COMMIT needed in plpgsql)
</verification>

<success_criteria>
- Migration file created with valid SQL
- 3 RPC functions: process_payment_intent_failed, process_subscription_status_change, confirm_lease_subscription
- Dry run push succeeds
- Ready for Plan 2 to wire handlers to these RPCs
</success_criteria>

<output>
After completion, create `.planning/phases/12-webhook-security-reliability/12-01-SUMMARY.md` with frontmatter:

```yaml
---
phase: 12-webhook-security-reliability
plan: 01
subsystem: database
tags: [postgres, rpc, transactions, webhooks]

requires:
  - phase: 11-04
    provides: Structured logging foundation

provides:
  - Atomic transaction RPCs for webhook handlers
  - process_payment_intent_failed RPC
  - process_subscription_status_change RPC
  - confirm_lease_subscription RPC

affects: [12-02-handler-refactor]

tech-stack:
  added: []
  patterns: [postgres-rpc-transactions]

key-files:
  created:
    - supabase/migrations/YYYYMMDDHHMMSS_add_webhook_transaction_rpcs.sql
  modified: []

key-decisions:
  - "SECURITY DEFINER for RPC security"
  - "Implicit transaction wrapping via plpgsql"
---
```

Include: accomplishments, files created, any issues encountered.
</output>
