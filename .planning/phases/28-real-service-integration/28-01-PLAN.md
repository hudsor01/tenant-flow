---
phase: 28-real-service-integration
plan: 01
type: execute
domain: testing
---

<objective>
Create Stripe test fixtures infrastructure for real API integration testing.

Purpose: Enable integration tests to create and clean up real Stripe resources (customers, payment methods, subscriptions) in test mode using idempotent patterns and automatic cleanup.
Output: StripeTestFixtures class with factory methods and cleanup tracking, test helpers for test clocks and webhook simulation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 27 complete - seed data ready
@.planning/phases/27-production-seed-data/27-01-SUMMARY.md

# Existing test infrastructure
@apps/backend/test/setup.ts
@apps/backend/test/integration/rls/setup.ts
@apps/backend/test/integration/stripe-webhook.integration.spec.ts

# ROADMAP Phase 28 Research Findings:
# - Stripe test mode: Use `sk_test_*` keys, never mock in integration tests
# - Test clocks: `stripe.testHelpers.testClocks.create()` for subscription lifecycle
# - Cleanup strategy: `StripeTestFixtures` class with `cleanup()` method tracking all created resources
# - Idempotency: Test with same idempotency key returns identical response
# - Rate limits: 100 req/sec in test mode, implement `StripeRateLimiter` for bulk operations

**Tech stack available:** Jest 30, Stripe SDK 20, existing RLS test setup with authenticateAs()
**Established patterns:** Test setup/teardown in beforeAll/afterAll, service role client for cleanup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StripeTestFixtures class with resource tracking</name>
  <files>apps/backend/test/fixtures/stripe-test-fixtures.ts</files>
  <action>
Create StripeTestFixtures class that:
1. Initializes real Stripe client with `sk_test_*` key from env
2. Tracks created resources in Sets: customers, paymentMethods, subscriptions, testClocks, prices, products
3. Provides factory methods:
   - `createCustomer(email: string, metadata?: Record<string, string>)` - creates test customer
   - `createPaymentMethod(customerId: string, type: 'card' = 'card')` - attaches pm_card_visa test card
   - `createTestClock(name: string)` - creates test clock for subscription testing
   - `createPrice(unitAmount: number, currency: string = 'usd')` - creates recurring price
   - `createSubscription(customerId: string, priceId: string, testClockId?: string)` - creates subscription
4. Provides `cleanup()` method that deletes all tracked resources in reverse dependency order
5. Implements rate limiting with 50ms delay between API calls to stay under 100 req/sec
6. All factory methods auto-track created resource IDs for cleanup

Use singleton pattern so cleanup can be called in Jest globalTeardown.
Do NOT mock Stripe - use real API calls in test mode.
  </action>
  <verify>npx tsc --noEmit apps/backend/test/fixtures/stripe-test-fixtures.ts</verify>
  <done>StripeTestFixtures class exists with factory methods and cleanup tracking, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe test helpers for common patterns</name>
  <files>apps/backend/test/fixtures/stripe-test-helpers.ts</files>
  <action>
Create helper functions that wrap StripeTestFixtures for common test scenarios:
1. `withStripeTestCustomer(email: string, fn: (customer: Stripe.Customer) => Promise<void>)` - creates customer, runs test, auto-cleans up
2. `withStripeSubscription(email: string, fn: (sub: Stripe.Subscription, testClock: Stripe.TestHelpers.TestClock) => Promise<void>)` - full subscription setup with test clock
3. `advanceTestClock(testClockId: string, toTimestamp: number)` - advances test clock and waits for Stripe processing
4. `simulateWebhookEvent(eventType: string, data: object)` - constructs signed webhook payload for testing handlers
5. `TEST_CARDS` constant with card numbers: success (4242424242424242), decline (4000000000000002), 3ds (4000002500003155)

Export StripeTestFixtures singleton instance as `stripeFixtures` for direct access.
Include JSDoc comments explaining rate limits and cleanup behavior.
  </action>
  <verify>npx tsc --noEmit apps/backend/test/fixtures/stripe-test-helpers.ts</verify>
  <done>Stripe test helpers exist with withStripeTestCustomer, withStripeSubscription, advanceTestClock, simulateWebhookEvent functions</done>
</task>

<task type="auto">
  <name>Task 3: Add Jest setup for Stripe fixtures cleanup</name>
  <files>apps/backend/test/stripe-setup.ts, apps/backend/jest.config.ts</files>
  <action>
1. Create apps/backend/test/stripe-setup.ts:
   - Import stripeFixtures singleton
   - Export globalTeardown function that calls stripeFixtures.cleanup()
   - Add console.log for cleanup stats (resources deleted count)
   - Handle cleanup errors gracefully (log but don't fail tests)

2. Update apps/backend/jest.config.ts:
   - Add globalTeardown pointing to stripe-setup.ts
   - Ensure setupFilesAfterEnv includes existing setup.ts
   - Add testTimeout of 30000 for integration tests (Stripe API can be slow)

Ensure cleanup runs even if tests fail. Log cleanup summary showing how many resources were cleaned up.
  </action>
  <verify>pnpm --filter @repo/backend test:unit -- --testPathPattern="env-check" --passWithNoTests</verify>
  <done>Jest config includes global teardown, stripe-setup.ts exports cleanup function</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @repo/backend typecheck` passes
- [ ] StripeTestFixtures class has createCustomer, createPaymentMethod, createTestClock, createSubscription methods
- [ ] All factory methods track resource IDs for cleanup
- [ ] cleanup() method exists and deletes resources in correct order
- [ ] Jest config includes globalTeardown for Stripe cleanup
- [ ] No Stripe mocks in the new files (real API calls only)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- StripeTestFixtures provides production-parity test infrastructure
- Resources are automatically cleaned up after test runs
</success_criteria>

<output>
After completion, create `.planning/phases/28-real-service-integration/28-01-SUMMARY.md`
</output>
