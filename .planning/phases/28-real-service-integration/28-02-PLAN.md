---
phase: 28-real-service-integration
plan: 02
type: execute
domain: testing
---

<objective>
Create real Stripe integration tests using the test fixtures infrastructure.

Purpose: Demonstrate production-parity testing by replacing mocked tests with real Stripe API calls, verifying actual webhook processing and database updates.
Output: Integration tests that create real Stripe resources, process real webhooks, and verify database state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 28-01 creates fixtures infrastructure
@.planning/phases/28-real-service-integration/28-01-PLAN.md

# Existing webhook integration test (uses mocked Stripe account)
@apps/backend/test/integration/stripe-webhook.integration.spec.ts

# Existing RLS test setup
@apps/backend/test/integration/rls/setup.ts

# ROADMAP Phase 28 Research Findings:
# - Test clocks: advance time to trigger subscription renewals without waiting 30 days
# - Connect testing: Create test connected accounts with stripe.accounts.create({ type: 'express' })
# - Webhook testing: Construct signed payloads using stripe.webhooks.generateTestHeaderString

**Depends on:** 28-01-PLAN.md (StripeTestFixtures must exist)
**Tech stack available:** Jest 30, Stripe SDK 20, StripeTestFixtures, authenticateAs() for RLS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe customer lifecycle integration test</name>
  <files>apps/backend/test/integration/stripe-customer-lifecycle.integration.spec.ts</files>
  <action>
Create integration test file that:
1. Uses stripeFixtures to create REAL Stripe customer in test mode
2. Tests customer.created webhook handler updates database
3. Tests adding payment method via stripeFixtures.createPaymentMethod()
4. Verifies payment_method.attached webhook updates tenant's stripe_customer_id
5. Uses authenticateAs(TEST_USERS.TENANT_A) to verify RLS allows tenant to see their own payment methods
6. Cleanup handled automatically by Jest globalTeardown

Test structure:
- describe('Stripe Customer Lifecycle')
  - it('creates customer and syncs to database')
  - it('attaches payment method and updates tenant record')
  - it('tenant can view their own payment methods via RLS')

Mark with describe.skipIf(shouldSkipIntegrationTests) for CI without Stripe keys.
Use real Stripe API - NO mocks.
  </action>
  <verify>pnpm --filter @repo/backend test:integration -- --testPathPattern="stripe-customer-lifecycle" --passWithNoTests</verify>
  <done>stripe-customer-lifecycle.integration.spec.ts exists with real Stripe API tests</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe subscription lifecycle integration test with test clocks</name>
  <files>apps/backend/test/integration/stripe-subscription-lifecycle.integration.spec.ts</files>
  <action>
Create integration test file that:
1. Uses stripeFixtures.createTestClock() to control time
2. Creates subscription attached to test clock
3. Uses advanceTestClock() to simulate billing cycles
4. Verifies subscription.updated webhook processes correctly
5. Tests invoice.paid webhook updates rent_payments table
6. Uses real Supabase queries to verify database state after webhook processing

Test structure:
- describe('Stripe Subscription Lifecycle with Test Clocks')
  - it('creates subscription with test clock')
  - it('advances clock to trigger renewal')
  - it('processes invoice.paid webhook and creates rent_payment record')
  - it('handles subscription.updated status changes')

Key: Test clocks allow testing 30-day cycles in seconds. Use stripe.testHelpers.testClocks.advance().
Include 2-second delay after advancing clock (Stripe needs time to process).
  </action>
  <verify>pnpm --filter @repo/backend test:integration -- --testPathPattern="stripe-subscription-lifecycle" --passWithNoTests</verify>
  <done>stripe-subscription-lifecycle.integration.spec.ts exists with test clock-based subscription tests</done>
</task>

<task type="auto">
  <name>Task 3: Create Stripe Connect integration test</name>
  <files>apps/backend/test/integration/stripe-connect.integration.spec.ts</files>
  <action>
Create integration test file that:
1. Creates test Express connected account via stripe.accounts.create({ type: 'express', country: 'US' })
2. Tracks account ID for cleanup in stripeFixtures
3. Simulates account.updated webhook with capabilities enabled
4. Verifies stripe_connected_accounts table is updated
5. Uses authenticateAs(TEST_USERS.OWNER_A) to verify owner can see their connect account via RLS

Test structure:
- describe('Stripe Connect Integration')
  - it('creates connected account and syncs to database')
  - it('processes account.updated webhook for onboarding completion')
  - it('owner can view their connect account status via RLS')

Add connected accounts to StripeTestFixtures tracking if not already there.
Real API calls - test mode connected accounts are safe to create/delete.
  </action>
  <verify>pnpm --filter @repo/backend test:integration -- --testPathPattern="stripe-connect" --passWithNoTests</verify>
  <done>stripe-connect.integration.spec.ts exists with real Connect account tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @repo/backend typecheck` passes
- [ ] All three integration test files exist
- [ ] Tests use stripeFixtures (no Stripe mocks)
- [ ] Tests include RLS verification with authenticateAs()
- [ ] Tests are skippable when Stripe keys not available
- [ ] Test clocks used for subscription lifecycle testing
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Integration tests demonstrate production-parity testing
- Tests pass against real Stripe test mode (when keys available)
- Phase 28 complete
</success_criteria>

<output>
After completion, create `.planning/phases/28-real-service-integration/28-02-SUMMARY.md`
</output>
