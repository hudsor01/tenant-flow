---
phase: 05-devops
plan: 02
type: execute
subsystem: backend
---

<objective>
Add Zod-based environment validation to NestJS backend.

Purpose: Validate env vars at startup, provide type-safe access, fail fast on misconfiguration.
Output: `apps/backend/src/config/env.config.ts` with validated environment schema.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan
@.planning/phases/05-devops/05-01-SUMMARY.md

# Current env usage (from grep)
Backend uses these env vars:
- PORT
- NODE_ENV
- SUPABASE_URL
- SUPABASE_SERVICE_ROLE_KEY
- SUPABASE_PUBLISHABLE_KEY
- SECRET_KEY_SUPABASE (legacy alias)
- DATABASE_URL
- STRIPE_SECRET_KEY
- N8N_WEBHOOK_SECRET
- N8N_CRON_MODE
- N8N_PDF_MODE
- BULLMQ_WORKERS_ENABLED
- REDIS_URL (for BullMQ)
- SLOW_QUERY_THRESHOLD_MS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create env validation schema</name>
  <files>
    apps/backend/src/config/env.schema.ts
  </files>
  <action>
1. Create `apps/backend/src/config/env.schema.ts`:

```typescript
import { z } from 'zod'

/**
 * Environment variable validation schema
 * Validates at startup, provides type-safe access
 */
export const envSchema = z.object({
  // Server
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),
  PORT: z.coerce.number().default(4650),

  // Supabase
  SUPABASE_URL: z.string().url(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
  SUPABASE_PUBLISHABLE_KEY: z.string().min(1),
  DATABASE_URL: z.string().url().optional(),

  // Stripe
  STRIPE_SECRET_KEY: z.string().startsWith('sk_'),
  STRIPE_WEBHOOK_SECRET: z.string().startsWith('whsec_').optional(),

  // n8n Integration
  N8N_WEBHOOK_SECRET: z.string().min(1).optional(),
  N8N_CRON_MODE: z.enum(['true', 'false']).default('false'),
  N8N_PDF_MODE: z.enum(['true', 'false']).default('false'),

  // BullMQ / Redis
  BULLMQ_WORKERS_ENABLED: z.enum(['true', 'false', '0', '1']).default('true'),
  REDIS_URL: z.string().url().optional(),

  // Performance
  SLOW_QUERY_THRESHOLD_MS: z.coerce.number().default(1000),
})

export type Env = z.infer<typeof envSchema>
```

2. Add validation function:

```typescript
export function validateEnv(): Env {
  const result = envSchema.safeParse(process.env)

  if (!result.success) {
    console.error('‚ùå Invalid environment variables:')
    console.error(result.error.flatten().fieldErrors)
    throw new Error('Invalid environment configuration')
  }

  return result.data
}
```
  </action>
  <verify>Schema file created</verify>
  <done>Env validation schema created</done>
</task>

<task type="auto">
  <name>Task 2: Create ConfigModule with Zod validation</name>
  <files>
    apps/backend/src/config/config.module.ts
    apps/backend/src/config/env.service.ts
  </files>
  <action>
1. Create `apps/backend/src/config/env.service.ts`:

```typescript
import { Injectable } from '@nestjs/common'
import { Env, validateEnv } from './env.schema'

@Injectable()
export class EnvService {
  private readonly env: Env

  constructor() {
    this.env = validateEnv()
  }

  get<K extends keyof Env>(key: K): Env[K] {
    return this.env[key]
  }

  get isProduction(): boolean {
    return this.env.NODE_ENV === 'production'
  }

  get isDevelopment(): boolean {
    return this.env.NODE_ENV === 'development'
  }

  get isTest(): boolean {
    return this.env.NODE_ENV === 'test'
  }
}
```

2. Create `apps/backend/src/config/config.module.ts`:

```typescript
import { Global, Module } from '@nestjs/common'
import { EnvService } from './env.service'

@Global()
@Module({
  providers: [EnvService],
  exports: [EnvService],
})
export class ConfigModule {}
```
  </action>
  <verify>ConfigModule and EnvService created</verify>
  <done>Config module with type-safe env access</done>
</task>

<task type="auto">
  <name>Task 3: Integrate ConfigModule into AppModule</name>
  <files>
    apps/backend/src/app.module.ts
  </files>
  <action>
1. Import ConfigModule as the FIRST module in imports:
   ```typescript
   import { ConfigModule } from './config/config.module'

   @Module({
     imports: [
       ConfigModule, // Must be first - validates env before other modules load
       // ... other modules
     ],
   })
   ```

2. This ensures env validation happens at startup before any module tries to use env vars
  </action>
  <verify>ConfigModule imported first in AppModule</verify>
  <done>ConfigModule integrated</done>
</task>

<task type="auto">
  <name>Task 4: Update critical services to use EnvService</name>
  <files>
    apps/backend/src/database/supabase.service.ts
    apps/backend/src/main.ts
  </files>
  <action>
1. Update SupabaseService to inject EnvService:
   ```typescript
   constructor(private readonly envService: EnvService) {
     this.supabaseUrl = this.envService.get('SUPABASE_URL')
     // ...
   }
   ```

2. Update main.ts to use validated port:
   - Can still use process.env.PORT since validation happens in ConfigModule
   - Or create a bootstrap helper that uses EnvService

3. Keep backward compatibility for now - don't refactor all process.env usage
   - ConfigModule validates at startup
   - Gradual migration to EnvService for type safety
  </action>
  <verify>SupabaseService uses EnvService</verify>
  <done>Critical services updated</done>
</task>

<task type="auto">
  <name>Task 5: Update tests</name>
  <files>
    apps/backend/src/test-utils/test.module.ts
    apps/backend/test/jest-setup.ts
  </files>
  <action>
1. Create test environment setup that provides mock env vars:
   ```typescript
   // In test setup
   process.env.NODE_ENV = 'test'
   process.env.SUPABASE_URL = 'https://test.supabase.co'
   process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-key'
   // ... etc
   ```

2. Ensure all required env vars are set before tests run

3. Run tests:
   ```bash
   pnpm --filter @repo/backend test:unit
   ```
  </action>
  <verify>Backend tests pass</verify>
  <done>Tests updated for env validation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] apps/backend/src/config/env.schema.ts exists
- [ ] apps/backend/src/config/env.service.ts exists
- [ ] apps/backend/src/config/config.module.ts exists
- [ ] ConfigModule imported first in AppModule
- [ ] `pnpm --filter @repo/backend typecheck` passes
- [ ] `pnpm --filter @repo/backend test:unit` passes
- [ ] Backend starts successfully with valid env vars
</verification>

<success_criteria>
- Backend fails fast on invalid env configuration
- Type-safe env access via EnvService
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-devops/05-02-SUMMARY.md` using summary template.
</output>
