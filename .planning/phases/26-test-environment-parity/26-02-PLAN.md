---
phase: 26-test-environment-parity
plan: 02
type: execute
---

<objective>
Establish environment variable hierarchy and verify Docker test environment works end-to-end.

Purpose: Ensure consistent environment structure across development, test, and production with clear precedence rules.
Output: Environment hierarchy templates, updated .gitignore, verified Docker test execution.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./26-02-SUMMARY.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-test-environment-parity/26-01-PLAN.md
@docker-compose.yml
@.env.docker
@apps/backend/src/config/config.schema.ts
@apps/backend/test/setup.ts

**Research findings (from ROADMAP.md Phase 26):**
- Environment variable parity: `.env.development`, `.env.test`, `.env.production` hierarchy
- JWT secret mismatch is a common gotcha between environments

**Current state:**
- .env.test and .env.test.local exist (gitignored)
- Backend test/setup.ts loads from .env.test.local
- Dockerfile expects env vars at runtime
- docker-compose.yml created in 26-01 with .env.docker

**Environment hierarchy pattern:**
1. .env.{environment}.local (gitignored, machine-specific secrets)
2. .env.{environment} (committed, shared defaults)
3. .env.local (gitignored, overrides all)
4. .env (committed, base defaults)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create environment template files with documented hierarchy</name>
  <files>.env.example, .env.development, .env.test, .gitignore</files>
  <action>
**1. Create/update .env.example** (comprehensive template for all environments):
Document every required environment variable from config.schema.ts with:
- Clear section headers (# Database, # Supabase, # Stripe, etc.)
- Placeholder values showing expected format
- Comments explaining which are required vs optional
- Note about .local files for secrets

**2. Create .env.development** (committed defaults for local dev):
- DATABASE_URL pointing to local Supabase (postgresql://postgres:postgres@127.0.0.1:54322/postgres)
- SUPABASE_URL=http://127.0.0.1:54321
- NODE_ENV=development
- PORT=4650
- Placeholder comments for secrets that go in .env.development.local

**3. Update .env.test** (committed defaults for test):
- DATABASE_URL pointing to test database
- NODE_ENV=test
- SUPABASE_URL=http://127.0.0.1:54321
- Include TEST_DATABASE_URL for isolation
- Placeholder comments for secrets in .env.test.local

**4. Update .gitignore** to ensure proper files are ignored:
```
# Environment files with secrets
.env.local
.env.*.local
.env.docker

# Keep templates committed
!.env.example
!.env.development
!.env.test
```

**Key patterns:**
- Secrets (API keys, passwords) go in .local files only
- Non-secret defaults (ports, URLs) can be committed
- Document the hierarchy in .env.example header comment
- Use consistent naming: SUPABASE_*, STRIPE_*, not mixed conventions
  </action>
  <verify>ls -la .env* | grep -v local (shows committed env files); cat .gitignore | grep -E "\.env"</verify>
  <done>.env.example comprehensive, .env.development and .env.test have non-secret defaults, .gitignore configured correctly</done>
</task>

<task type="auto">
  <name>Task 2: Verify Docker Compose starts and health checks pass</name>
  <files>scripts/docker-test.sh</files>
  <action>
**1. Create scripts/docker-test.sh** (executable test script):
```bash
#!/usr/bin/env bash
set -euo pipefail

echo "=== Docker Test Environment ==="

# Check Docker is running
if ! docker info > /dev/null 2>&1; then
  echo "ERROR: Docker is not running"
  exit 1
fi

# Start services
echo "Starting services..."
docker compose up -d postgres redis

# Wait for health checks
echo "Waiting for services to be healthy..."
timeout 60 bash -c 'until docker compose ps | grep -q "healthy"; do sleep 2; done' || {
  echo "ERROR: Services did not become healthy in 60s"
  docker compose logs
  exit 1
}

# Verify postgres
echo "Verifying PostgreSQL..."
docker compose exec -T postgres pg_isready -U postgres

# Verify redis
echo "Verifying Redis..."
docker compose exec -T redis redis-cli ping

echo "=== All services healthy ==="

# Cleanup
echo "Cleaning up..."
docker compose down -v
```

**2. Make script executable and add to package.json:**
Add to root package.json scripts:
```json
"docker:test": "bash scripts/docker-test.sh",
"docker:up": "docker compose up -d",
"docker:down": "docker compose down -v"
```

**3. Test the script:**
Run `pnpm docker:test` to verify:
- Docker Compose starts postgres and redis
- Health checks pass
- Services respond correctly
- Cleanup works

**Avoid:**
- Don't start backend service yet (needs Supabase running)
- Don't commit real secrets
- Don't use `docker-compose` (use `docker compose` v2 syntax)
  </action>
  <verify>pnpm docker:test exits 0 with "All services healthy" output</verify>
  <done>scripts/docker-test.sh exists and runs successfully, package.json has docker:* scripts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] .env.example documents all config.schema.ts variables
- [ ] .env.development has non-secret defaults for local dev
- [ ] .env.test has non-secret defaults for testing
- [ ] .gitignore excludes .local and .docker files
- [ ] scripts/docker-test.sh is executable
- [ ] `pnpm docker:test` starts/verifies/stops services successfully
- [ ] package.json has docker:test, docker:up, docker:down scripts
</verification>

<success_criteria>
- Environment hierarchy established and documented
- Docker services start with proper health checks
- Phase 26 complete: Test environment has production parity for postgres/redis
- Ready for Phase 27: Production-Like Seed Data
</success_criteria>

<output>
After completion, create `.planning/phases/26-test-environment-parity/26-02-SUMMARY.md` with:
- Environment files created
- Docker verification results
- Note: Supabase integration deferred to Phase 27 (requires seed data first)
</output>
