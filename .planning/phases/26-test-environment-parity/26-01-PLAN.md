---
phase: 26-test-environment-parity
plan: 01
type: execute
---

<objective>
Create Docker Compose infrastructure for test environment parityâ€”services match production topology with proper health checks and networking.

Purpose: Enable integration and E2E tests to run against production-equivalent infrastructure (real Postgres, Redis) rather than mocks.
Output: Working docker-compose.yml that spins up all backend dependencies with health checks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./26-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Dockerfile
@supabase/config.toml
@apps/backend/src/config/config.schema.ts

**Research findings (from ROADMAP.md Phase 26):**
- PostgreSQL 17 already pinned in `supabase/config.toml`
- Use `condition: service_healthy` for startup ordering
- Key gotchas: JWT secret mismatch, localhost vs 127.0.0.1, service startup race conditions
- Supabase local uses ports 54321-54327

**Current state:**
- Dockerfile exists for production backend (multi-stage, Node 24-alpine)
- No docker-compose.yml exists
- Backend port: 4650 (configurable via PORT env)
- Health endpoint: /health/ping

**Tech stack:**
- PostgreSQL 17 (matches supabase/config.toml)
- Redis (for BullMQ queues)
- Node.js 24 (matches Dockerfile)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml with all services</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml with the following services:

**postgres** (PostgreSQL 17):
- Image: postgres:17-alpine
- Port: 54322 (matches supabase/config.toml)
- Healthcheck: `pg_isready -U postgres`
- Volumes: postgres_data for persistence
- Environment: POSTGRES_USER=postgres, POSTGRES_PASSWORD=postgres, POSTGRES_DB=postgres

**redis** (for BullMQ):
- Image: redis:7-alpine
- Port: 6379
- Healthcheck: `redis-cli ping`
- Command: `--appendonly yes` for persistence

**backend** (NestJS API):
- Build from Dockerfile (target: runtime)
- Port: 4650
- depends_on: postgres and redis with `condition: service_healthy`
- Healthcheck: curl to /health/ping
- Environment: Load from .env.docker (created in 26-02)
- Networks: default

**Key patterns:**
- Use `healthcheck.interval: 5s, timeout: 3s, retries: 5` for all services
- Use named volumes for data persistence
- Do NOT include Supabase services (use `supabase start` separately for full Supabase stack)
- Backend should use environment variables for service discovery (not hardcoded localhost)

**Avoid:**
- Don't use `links:` (deprecated, use networks)
- Don't hardcode secrets in compose file (use env_file)
- Don't use `restart: always` for test environments (use `restart: unless-stopped`)
  </action>
  <verify>docker compose config (validates syntax without running)</verify>
  <done>docker-compose.yml exists, validates without errors, has postgres/redis/backend with health checks</done>
</task>

<task type="auto">
  <name>Task 2: Create .env.docker with service-aware configuration</name>
  <files>.env.docker</files>
  <action>
Create .env.docker with environment variables configured for Docker Compose networking:

**Database (Docker internal networking):**
- DATABASE_URL=postgresql://postgres:postgres@postgres:5432/postgres
- DIRECT_URL=postgresql://postgres:postgres@postgres:5432/postgres

**Redis:**
- REDIS_URL=redis://redis:6379

**Application:**
- NODE_ENV=test
- PORT=4650
- BACKEND_TIMEOUT_MS=30000
- API_BASE_URL=http://backend:4650
- FRONTEND_URL=http://localhost:3050

**Supabase (placeholder for local Supabase):**
- SUPABASE_URL=http://host.docker.internal:54321
- SUPABASE_SERVICE_ROLE_KEY=placeholder-update-from-supabase-start
- SUPABASE_PUBLISHABLE_KEY=placeholder-update-from-supabase-start
- JWT_SECRET=super-secret-jwt-token-with-at-least-32-characters-for-testing

**Stripe (test mode):**
- STRIPE_SECRET_KEY=sk_test_placeholder
- STRIPE_PUBLISHABLE_KEY=pk_test_placeholder
- STRIPE_WEBHOOK_SECRET=whsec_test_placeholder

**Other services:**
- RESEND_API_KEY=re_test_placeholder
- DOCUSEAL_API_KEY=test_placeholder

Add comment header explaining:
1. This file is for Docker Compose testing
2. Update Supabase keys after running `supabase start`
3. Update Stripe keys with real test mode keys

**Critical:** Use Docker service names (postgres, redis) not localhost for DATABASE_URL and REDIS_URL.
  </action>
  <verify>cat .env.docker | grep -E "DATABASE_URL|REDIS_URL" shows Docker service names (postgres, redis)</verify>
  <done>.env.docker exists with Docker-aware service URLs, placeholder secrets documented</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker compose config` validates without errors
- [ ] docker-compose.yml has postgres, redis, backend services
- [ ] All services have healthcheck configurations
- [ ] .env.docker uses Docker service names for DATABASE_URL/REDIS_URL
- [ ] Backend depends_on postgres and redis with service_healthy condition
</verification>

<success_criteria>
- docker-compose.yml created with all required services
- Health checks configured for startup ordering
- .env.docker has Docker-aware configuration
- Ready for 26-02 to add environment variable parity
</success_criteria>

<output>
After completion, create `.planning/phases/26-test-environment-parity/26-01-SUMMARY.md`
</output>
