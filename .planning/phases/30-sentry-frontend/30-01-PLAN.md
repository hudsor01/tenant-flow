---
phase: 30-sentry-frontend
plan: 01
type: implementation
subsystem: observability
depends-on: [29-sentry-backend]
provides: [sentry-user-context, sentry-query-error-capture, sentry-data-scrubbing]
affects: [providers/query-provider.tsx, providers/auth-provider.tsx, sentry.client.config.ts, sentry.server.config.ts]
tags: [sentry, observability, monitoring, frontend, react-query]
estimated-tasks: 4
estimated-scope: small
checkpoints: []
---

# Phase 30-01: Sentry Frontend Integration Enhancement

## Objective

Enhance the existing Sentry frontend integration with user context propagation, TanStack Query error capture, and consistent data scrubbing across client and server configs.

## Execution Context

**Current State (already working):**
- Three config files: `sentry.client.config.ts`, `sentry.server.config.ts`, `sentry.edge.config.ts` ✅
- Source maps with `withSentryConfig` in `next.config.ts` ✅
- Tunnel route at `/monitoring` to avoid ad-blockers ✅
- Session replay with `replayIntegration` ✅
- Web Vitals with INP enabled (`enableInp: true`) ✅
- Global error boundary with Sentry capture (`app/global-error.tsx`) ✅
- Query error handlers with retry logic ✅

**Enhancements needed:**
1. Set user context in client config when user is authenticated
2. Add TanStack Query error capture via cache subscription
3. Add data scrubbing to client/server beforeSend (mirror backend)
4. Set user context on server-side for SSR errors

## Context

### Research Findings (from ROADMAP.md Phase 30)

- User context limitation: `setUser()` on server doesn't propagate to client—call both places
- TanStack Query: Subscribe to `queryClient.getQueryCache()` and `getMutationCache()` for error capture
- Error boundaries: `app/global-error.tsx` + component-level `<Sentry.ErrorBoundary>` already exists

### Key Limitation

User context must be set in both places because:
- Server-side context doesn't persist to client hydration
- Auth state is available via `auth-provider.tsx` on client

## Tasks

### Task 1: Add Data Scrubbing to Client Config

Update `sentry.client.config.ts` to scrub sensitive data from events.

**File:** `apps/frontend/sentry.client.config.ts`

**Changes:**
```typescript
beforeSend(event) {
  if (process.env.NODE_ENV === 'development' && !process.env.SENTRY_DEBUG) {
    return null
  }

  // Scrub sensitive headers
  if (event.request?.headers) {
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key']
    for (const header of sensitiveHeaders) {
      if (event.request.headers[header]) {
        event.request.headers[header] = '[REDACTED]'
      }
    }
  }

  // Scrub card patterns from breadcrumbs
  if (event.breadcrumbs) {
    event.breadcrumbs = event.breadcrumbs.map(breadcrumb => {
      if (breadcrumb.data) {
        const scrubbed = { ...breadcrumb.data }
        for (const [key, value] of Object.entries(scrubbed)) {
          if (typeof value === 'string') {
            if (/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/.test(value)) {
              scrubbed[key] = '[CARD_REDACTED]'
            }
          }
        }
        return { ...breadcrumb, data: scrubbed }
      }
      return breadcrumb
    })
  }

  return event
}
```

**Verification:**
- [ ] Sensitive headers scrubbed
- [ ] Card patterns redacted

### Task 2: Add Data Scrubbing to Server Config

Update `sentry.server.config.ts` with same scrubbing logic.

**File:** `apps/frontend/sentry.server.config.ts`

**Changes:** Same beforeSend enhancement as Task 1.

**Verification:**
- [ ] Server config has consistent scrubbing
- [ ] NEXT_NOT_FOUND and NEXT_REDIRECT still ignored

### Task 3: Add TanStack Query Error Capture

Update `query-provider.tsx` to capture query/mutation errors to Sentry.

**File:** `apps/frontend/src/providers/query-provider.tsx`

**Changes:**
1. Import Sentry
2. Subscribe to query cache for error capture
3. Subscribe to mutation cache for error capture

```typescript
import * as Sentry from '@sentry/nextjs'

// In QueryProvider component, add useEffect:
useEffect(() => {
  // Capture query errors to Sentry
  const queryUnsubscribe = queryClient.getQueryCache().subscribe((event) => {
    if (event.type === 'updated' && event.query.state.status === 'error') {
      const error = event.query.state.error
      Sentry.captureException(error, {
        tags: { source: 'react-query' },
        contexts: {
          react_query: {
            queryKey: JSON.stringify(event.query.queryKey),
            queryHash: event.query.queryHash
          }
        }
      })
    }
  })

  // Capture mutation errors to Sentry
  const mutationUnsubscribe = queryClient.getMutationCache().subscribe((event) => {
    if (event.type === 'updated' && event.mutation.state.status === 'error') {
      const error = event.mutation.state.error
      Sentry.captureException(error, {
        tags: { source: 'react-query-mutation' },
        contexts: {
          react_query: {
            mutationKey: event.mutation.options.mutationKey
              ? JSON.stringify(event.mutation.options.mutationKey)
              : undefined
          }
        }
      })
    }
  })

  return () => {
    queryUnsubscribe()
    mutationUnsubscribe()
  }
}, [queryClient])
```

**Verification:**
- [ ] Query errors captured with queryKey context
- [ ] Mutation errors captured with mutationKey context
- [ ] Cleanup on unmount

### Task 4: Add User Context on Auth State Change

Update `auth-provider.tsx` to set Sentry user context when auth state changes.

**File:** `apps/frontend/src/providers/auth-provider.tsx`

**Changes:**
```typescript
import * as Sentry from '@sentry/nextjs'

// In auth state change handler:
useEffect(() => {
  // Set Sentry user context when auth state changes
  if (user) {
    Sentry.setUser({
      id: user.id,
      ...(user.email && { email: user.email })
    })
  } else {
    Sentry.setUser(null)
  }
}, [user])
```

**Verification:**
- [ ] User context set on login
- [ ] User context cleared on logout

## Verification

Run these commands to verify the implementation:

```bash
# Type check frontend
pnpm --filter @repo/frontend typecheck

# Unit tests
pnpm --filter @repo/frontend test:unit

# Build (tests source maps upload)
pnpm --filter @repo/frontend build
```

## Success Criteria

- [ ] Data scrubbing added to client and server configs
- [ ] TanStack Query errors captured to Sentry with context
- [ ] User context set on auth state change
- [ ] All existing tests pass
- [ ] No TypeScript errors
- [ ] Build succeeds

## Output

Files modified:
- `apps/frontend/sentry.client.config.ts` (MODIFIED)
- `apps/frontend/sentry.server.config.ts` (MODIFIED)
- `apps/frontend/src/providers/query-provider.tsx` (MODIFIED)
- `apps/frontend/src/providers/auth-provider.tsx` (MODIFIED)

## Notes

- Edge config (`sentry.edge.config.ts`) doesn't need data scrubbing as it's minimal
- Server-side user context is already handled by backend middleware
- The existing query-error-handler.ts already logs errors, now we also send to Sentry
