
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BlogArticle
 * 
 */
export type BlogArticle = $Result.DefaultSelection<Prisma.$BlogArticlePayload>
/**
 * Model BlogTag
 * 
 */
export type BlogTag = $Result.DefaultSelection<Prisma.$BlogTagPayload>
/**
 * Model CustomerInvoice
 * Separate from subscription invoices - these are customer invoices
 */
export type CustomerInvoice = $Result.DefaultSelection<Prisma.$CustomerInvoicePayload>
/**
 * Model CustomerInvoiceItem
 * 
 */
export type CustomerInvoiceItem = $Result.DefaultSelection<Prisma.$CustomerInvoiceItemPayload>
/**
 * Model Document
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Expense
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Inspection
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Inspection = $Result.DefaultSelection<Prisma.$InspectionPayload>
/**
 * Model Invoice
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLeadCapture
 * Lead capture tracking for marketing automation
 */
export type InvoiceLeadCapture = $Result.DefaultSelection<Prisma.$InvoiceLeadCapturePayload>
/**
 * Model Lease
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Lease = $Result.DefaultSelection<Prisma.$LeasePayload>
/**
 * Model LeaseGeneratorUsage
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type LeaseGeneratorUsage = $Result.DefaultSelection<Prisma.$LeaseGeneratorUsagePayload>
/**
 * Model MaintenanceRequest
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type MaintenanceRequest = $Result.DefaultSelection<Prisma.$MaintenanceRequestPayload>
/**
 * Model Message
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Property
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Subscription
 * SUBSCRIPTION MODEL - Uses String fields to match database reality
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Tenant
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Unit
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model User
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model SecurityAuditLog
 * 
 */
export type SecurityAuditLog = $Result.DefaultSelection<Prisma.$SecurityAuditLogPayload>
/**
 * Model wrappers_fdw_stats
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type wrappers_fdw_stats = $Result.DefaultSelection<Prisma.$wrappers_fdw_statsPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model ReminderLog
 * 
 */
export type ReminderLog = $Result.DefaultSelection<Prisma.$ReminderLogPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model UserFeatureAccess
 * 
 */
export type UserFeatureAccess = $Result.DefaultSelection<Prisma.$UserFeatureAccessPayload>
/**
 * Model UserAccessLog
 * 
 */
export type UserAccessLog = $Result.DefaultSelection<Prisma.$UserAccessLogPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model FailedWebhookEvent
 * 
 */
export type FailedWebhookEvent = $Result.DefaultSelection<Prisma.$FailedWebhookEventPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model PaymentFailure
 * 
 */
export type PaymentFailure = $Result.DefaultSelection<Prisma.$PaymentFailurePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BlogCategory: {
  PROPERTY_MANAGEMENT: 'PROPERTY_MANAGEMENT',
  LEGAL_COMPLIANCE: 'LEGAL_COMPLIANCE',
  FINANCIAL_MANAGEMENT: 'FINANCIAL_MANAGEMENT',
  PROPERTY_MAINTENANCE: 'PROPERTY_MAINTENANCE',
  SOFTWARE_REVIEWS: 'SOFTWARE_REVIEWS',
  TENANT_RELATIONS: 'TENANT_RELATIONS',
  MARKETING: 'MARKETING',
  REAL_ESTATE_INVESTMENT: 'REAL_ESTATE_INVESTMENT',
  TAX_PLANNING: 'TAX_PLANNING',
  AUTOMATION: 'AUTOMATION'
};

export type BlogCategory = (typeof BlogCategory)[keyof typeof BlogCategory]


export const BlogStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  SCHEDULED: 'SCHEDULED'
};

export type BlogStatus = (typeof BlogStatus)[keyof typeof BlogStatus]


export const CustomerInvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  VIEWED: 'VIEWED',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type CustomerInvoiceStatus = (typeof CustomerInvoiceStatus)[keyof typeof CustomerInvoiceStatus]


export const DocumentType: {
  LEASE: 'LEASE',
  INVOICE: 'INVOICE',
  RECEIPT: 'RECEIPT',
  PROPERTY_PHOTO: 'PROPERTY_PHOTO',
  INSPECTION: 'INSPECTION',
  MAINTENANCE: 'MAINTENANCE',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const LeaseStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  TERMINATED: 'TERMINATED'
};

export type LeaseStatus = (typeof LeaseStatus)[keyof typeof LeaseStatus]


export const PlanType: {
  FREE: 'FREE',
  STARTER: 'STARTER',
  GROWTH: 'GROWTH',
  BUSINESS: 'BUSINESS',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  EMERGENCY: 'EMERGENCY'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const PropertyType: {
  SINGLE_FAMILY: 'SINGLE_FAMILY',
  MULTI_UNIT: 'MULTI_UNIT',
  APARTMENT: 'APARTMENT',
  COMMERCIAL: 'COMMERCIAL'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const RequestStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  ON_HOLD: 'ON_HOLD'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const SubStatus: {
  ACTIVE: 'ACTIVE',
  TRIALING: 'TRIALING',
  PAST_DUE: 'PAST_DUE',
  CANCELED: 'CANCELED',
  UNPAID: 'UNPAID',
  INCOMPLETE: 'INCOMPLETE',
  INCOMPLETE_EXPIRED: 'INCOMPLETE_EXPIRED'
};

export type SubStatus = (typeof SubStatus)[keyof typeof SubStatus]


export const UnitStatus: {
  VACANT: 'VACANT',
  OCCUPIED: 'OCCUPIED',
  MAINTENANCE: 'MAINTENANCE',
  RESERVED: 'RESERVED'
};

export type UnitStatus = (typeof UnitStatus)[keyof typeof UnitStatus]


export const UserRole: {
  OWNER: 'OWNER',
  MANAGER: 'MANAGER',
  TENANT: 'TENANT',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ActivityEntityType: {
  property: 'property',
  tenant: 'tenant',
  maintenance: 'maintenance',
  payment: 'payment',
  lease: 'lease',
  unit: 'unit'
};

export type ActivityEntityType = (typeof ActivityEntityType)[keyof typeof ActivityEntityType]


export const ReminderType: {
  RENT_REMINDER: 'RENT_REMINDER',
  LEASE_EXPIRATION: 'LEASE_EXPIRATION',
  MAINTENANCE_DUE: 'MAINTENANCE_DUE',
  PAYMENT_OVERDUE: 'PAYMENT_OVERDUE'
};

export type ReminderType = (typeof ReminderType)[keyof typeof ReminderType]


export const ReminderStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  DELIVERED: 'DELIVERED',
  OPENED: 'OPENED'
};

export type ReminderStatus = (typeof ReminderStatus)[keyof typeof ReminderStatus]

}

export type BlogCategory = $Enums.BlogCategory

export const BlogCategory: typeof $Enums.BlogCategory

export type BlogStatus = $Enums.BlogStatus

export const BlogStatus: typeof $Enums.BlogStatus

export type CustomerInvoiceStatus = $Enums.CustomerInvoiceStatus

export const CustomerInvoiceStatus: typeof $Enums.CustomerInvoiceStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type LeaseStatus = $Enums.LeaseStatus

export const LeaseStatus: typeof $Enums.LeaseStatus

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type SubStatus = $Enums.SubStatus

export const SubStatus: typeof $Enums.SubStatus

export type UnitStatus = $Enums.UnitStatus

export const UnitStatus: typeof $Enums.UnitStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ActivityEntityType = $Enums.ActivityEntityType

export const ActivityEntityType: typeof $Enums.ActivityEntityType

export type ReminderType = $Enums.ReminderType

export const ReminderType: typeof $Enums.ReminderType

export type ReminderStatus = $Enums.ReminderStatus

export const ReminderStatus: typeof $Enums.ReminderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BlogArticles
 * const blogArticles = await prisma.blogArticle.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BlogArticles
   * const blogArticles = await prisma.blogArticle.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.blogArticle`: Exposes CRUD operations for the **BlogArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogArticles
    * const blogArticles = await prisma.blogArticle.findMany()
    * ```
    */
  get blogArticle(): Prisma.BlogArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogTag`: Exposes CRUD operations for the **BlogTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTags
    * const blogTags = await prisma.blogTag.findMany()
    * ```
    */
  get blogTag(): Prisma.BlogTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerInvoice`: Exposes CRUD operations for the **CustomerInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerInvoices
    * const customerInvoices = await prisma.customerInvoice.findMany()
    * ```
    */
  get customerInvoice(): Prisma.CustomerInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerInvoiceItem`: Exposes CRUD operations for the **CustomerInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerInvoiceItems
    * const customerInvoiceItems = await prisma.customerInvoiceItem.findMany()
    * ```
    */
  get customerInvoiceItem(): Prisma.CustomerInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inspection`: Exposes CRUD operations for the **Inspection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inspections
    * const inspections = await prisma.inspection.findMany()
    * ```
    */
  get inspection(): Prisma.InspectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLeadCapture`: Exposes CRUD operations for the **InvoiceLeadCapture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLeadCaptures
    * const invoiceLeadCaptures = await prisma.invoiceLeadCapture.findMany()
    * ```
    */
  get invoiceLeadCapture(): Prisma.InvoiceLeadCaptureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lease`: Exposes CRUD operations for the **Lease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leases
    * const leases = await prisma.lease.findMany()
    * ```
    */
  get lease(): Prisma.LeaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaseGeneratorUsage`: Exposes CRUD operations for the **LeaseGeneratorUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaseGeneratorUsages
    * const leaseGeneratorUsages = await prisma.leaseGeneratorUsage.findMany()
    * ```
    */
  get leaseGeneratorUsage(): Prisma.LeaseGeneratorUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceRequest`: Exposes CRUD operations for the **MaintenanceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRequests
    * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
    * ```
    */
  get maintenanceRequest(): Prisma.MaintenanceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityAuditLog`: Exposes CRUD operations for the **SecurityAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityAuditLogs
    * const securityAuditLogs = await prisma.securityAuditLog.findMany()
    * ```
    */
  get securityAuditLog(): Prisma.SecurityAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wrappers_fdw_stats`: Exposes CRUD operations for the **wrappers_fdw_stats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wrappers_fdw_stats
    * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findMany()
    * ```
    */
  get wrappers_fdw_stats(): Prisma.wrappers_fdw_statsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminderLog`: Exposes CRUD operations for the **ReminderLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReminderLogs
    * const reminderLogs = await prisma.reminderLog.findMany()
    * ```
    */
  get reminderLog(): Prisma.ReminderLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFeatureAccess`: Exposes CRUD operations for the **UserFeatureAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeatureAccesses
    * const userFeatureAccesses = await prisma.userFeatureAccess.findMany()
    * ```
    */
  get userFeatureAccess(): Prisma.UserFeatureAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAccessLog`: Exposes CRUD operations for the **UserAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccessLogs
    * const userAccessLogs = await prisma.userAccessLog.findMany()
    * ```
    */
  get userAccessLog(): Prisma.UserAccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.failedWebhookEvent`: Exposes CRUD operations for the **FailedWebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FailedWebhookEvents
    * const failedWebhookEvents = await prisma.failedWebhookEvent.findMany()
    * ```
    */
  get failedWebhookEvent(): Prisma.FailedWebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentFailure`: Exposes CRUD operations for the **PaymentFailure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentFailures
    * const paymentFailures = await prisma.paymentFailure.findMany()
    * ```
    */
  get paymentFailure(): Prisma.PaymentFailureDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BlogArticle: 'BlogArticle',
    BlogTag: 'BlogTag',
    CustomerInvoice: 'CustomerInvoice',
    CustomerInvoiceItem: 'CustomerInvoiceItem',
    Document: 'Document',
    Expense: 'Expense',
    Inspection: 'Inspection',
    Invoice: 'Invoice',
    InvoiceLeadCapture: 'InvoiceLeadCapture',
    Lease: 'Lease',
    LeaseGeneratorUsage: 'LeaseGeneratorUsage',
    MaintenanceRequest: 'MaintenanceRequest',
    Message: 'Message',
    Property: 'Property',
    Subscription: 'Subscription',
    Tenant: 'Tenant',
    Unit: 'Unit',
    User: 'User',
    UserSession: 'UserSession',
    SecurityAuditLog: 'SecurityAuditLog',
    wrappers_fdw_stats: 'wrappers_fdw_stats',
    Activity: 'Activity',
    WebhookEvent: 'WebhookEvent',
    ReminderLog: 'ReminderLog',
    UserPreferences: 'UserPreferences',
    UserFeatureAccess: 'UserFeatureAccess',
    UserAccessLog: 'UserAccessLog',
    NotificationLog: 'NotificationLog',
    FailedWebhookEvent: 'FailedWebhookEvent',
    File: 'File',
    PaymentFailure: 'PaymentFailure'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "blogArticle" | "blogTag" | "customerInvoice" | "customerInvoiceItem" | "document" | "expense" | "inspection" | "invoice" | "invoiceLeadCapture" | "lease" | "leaseGeneratorUsage" | "maintenanceRequest" | "message" | "property" | "subscription" | "tenant" | "unit" | "user" | "userSession" | "securityAuditLog" | "wrappers_fdw_stats" | "activity" | "webhookEvent" | "reminderLog" | "userPreferences" | "userFeatureAccess" | "userAccessLog" | "notificationLog" | "failedWebhookEvent" | "file" | "paymentFailure"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BlogArticle: {
        payload: Prisma.$BlogArticlePayload<ExtArgs>
        fields: Prisma.BlogArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          findFirst: {
            args: Prisma.BlogArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          findMany: {
            args: Prisma.BlogArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>[]
          }
          create: {
            args: Prisma.BlogArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          createMany: {
            args: Prisma.BlogArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>[]
          }
          delete: {
            args: Prisma.BlogArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          update: {
            args: Prisma.BlogArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          deleteMany: {
            args: Prisma.BlogArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>[]
          }
          upsert: {
            args: Prisma.BlogArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogArticlePayload>
          }
          aggregate: {
            args: Prisma.BlogArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogArticle>
          }
          groupBy: {
            args: Prisma.BlogArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogArticleCountArgs<ExtArgs>
            result: $Utils.Optional<BlogArticleCountAggregateOutputType> | number
          }
        }
      }
      BlogTag: {
        payload: Prisma.$BlogTagPayload<ExtArgs>
        fields: Prisma.BlogTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findFirst: {
            args: Prisma.BlogTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findMany: {
            args: Prisma.BlogTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          create: {
            args: Prisma.BlogTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          createMany: {
            args: Prisma.BlogTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          delete: {
            args: Prisma.BlogTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          update: {
            args: Prisma.BlogTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          upsert: {
            args: Prisma.BlogTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          aggregate: {
            args: Prisma.BlogTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTag>
          }
          groupBy: {
            args: Prisma.BlogTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTagCountAggregateOutputType> | number
          }
        }
      }
      CustomerInvoice: {
        payload: Prisma.$CustomerInvoicePayload<ExtArgs>
        fields: Prisma.CustomerInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          findFirst: {
            args: Prisma.CustomerInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          findMany: {
            args: Prisma.CustomerInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          create: {
            args: Prisma.CustomerInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          createMany: {
            args: Prisma.CustomerInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          delete: {
            args: Prisma.CustomerInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          update: {
            args: Prisma.CustomerInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          deleteMany: {
            args: Prisma.CustomerInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>[]
          }
          upsert: {
            args: Prisma.CustomerInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicePayload>
          }
          aggregate: {
            args: Prisma.CustomerInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerInvoice>
          }
          groupBy: {
            args: Prisma.CustomerInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceCountAggregateOutputType> | number
          }
        }
      }
      CustomerInvoiceItem: {
        payload: Prisma.$CustomerInvoiceItemPayload<ExtArgs>
        fields: Prisma.CustomerInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.CustomerInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.CustomerInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.CustomerInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.CustomerInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.CustomerInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          update: {
            args: Prisma.CustomerInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.CustomerInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.CustomerInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.CustomerInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerInvoiceItem>
          }
          groupBy: {
            args: Prisma.CustomerInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Inspection: {
        payload: Prisma.$InspectionPayload<ExtArgs>
        fields: Prisma.InspectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          findFirst: {
            args: Prisma.InspectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          findMany: {
            args: Prisma.InspectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          create: {
            args: Prisma.InspectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          createMany: {
            args: Prisma.InspectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          delete: {
            args: Prisma.InspectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          update: {
            args: Prisma.InspectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          deleteMany: {
            args: Prisma.InspectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InspectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          upsert: {
            args: Prisma.InspectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          aggregate: {
            args: Prisma.InspectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspection>
          }
          groupBy: {
            args: Prisma.InspectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLeadCapture: {
        payload: Prisma.$InvoiceLeadCapturePayload<ExtArgs>
        fields: Prisma.InvoiceLeadCaptureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLeadCaptureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLeadCaptureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLeadCaptureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLeadCaptureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          findMany: {
            args: Prisma.InvoiceLeadCaptureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>[]
          }
          create: {
            args: Prisma.InvoiceLeadCaptureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          createMany: {
            args: Prisma.InvoiceLeadCaptureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLeadCaptureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLeadCaptureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          update: {
            args: Prisma.InvoiceLeadCaptureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLeadCaptureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLeadCaptureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceLeadCaptureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceLeadCaptureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLeadCapturePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLeadCaptureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLeadCapture>
          }
          groupBy: {
            args: Prisma.InvoiceLeadCaptureGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLeadCaptureGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLeadCaptureCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLeadCaptureCountAggregateOutputType> | number
          }
        }
      }
      Lease: {
        payload: Prisma.$LeasePayload<ExtArgs>
        fields: Prisma.LeaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findFirst: {
            args: Prisma.LeaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          findMany: {
            args: Prisma.LeaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          create: {
            args: Prisma.LeaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          createMany: {
            args: Prisma.LeaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          delete: {
            args: Prisma.LeaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          update: {
            args: Prisma.LeaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          deleteMany: {
            args: Prisma.LeaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>[]
          }
          upsert: {
            args: Prisma.LeaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeasePayload>
          }
          aggregate: {
            args: Prisma.LeaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLease>
          }
          groupBy: {
            args: Prisma.LeaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseCountAggregateOutputType> | number
          }
        }
      }
      LeaseGeneratorUsage: {
        payload: Prisma.$LeaseGeneratorUsagePayload<ExtArgs>
        fields: Prisma.LeaseGeneratorUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaseGeneratorUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaseGeneratorUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          findFirst: {
            args: Prisma.LeaseGeneratorUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaseGeneratorUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          findMany: {
            args: Prisma.LeaseGeneratorUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>[]
          }
          create: {
            args: Prisma.LeaseGeneratorUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          createMany: {
            args: Prisma.LeaseGeneratorUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaseGeneratorUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>[]
          }
          delete: {
            args: Prisma.LeaseGeneratorUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          update: {
            args: Prisma.LeaseGeneratorUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          deleteMany: {
            args: Prisma.LeaseGeneratorUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaseGeneratorUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaseGeneratorUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>[]
          }
          upsert: {
            args: Prisma.LeaseGeneratorUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaseGeneratorUsagePayload>
          }
          aggregate: {
            args: Prisma.LeaseGeneratorUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaseGeneratorUsage>
          }
          groupBy: {
            args: Prisma.LeaseGeneratorUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaseGeneratorUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaseGeneratorUsageCountArgs<ExtArgs>
            result: $Utils.Optional<LeaseGeneratorUsageCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRequest: {
        payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      SecurityAuditLog: {
        payload: Prisma.$SecurityAuditLogPayload<ExtArgs>
        fields: Prisma.SecurityAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          findFirst: {
            args: Prisma.SecurityAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          findMany: {
            args: Prisma.SecurityAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          create: {
            args: Prisma.SecurityAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          createMany: {
            args: Prisma.SecurityAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          delete: {
            args: Prisma.SecurityAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          update: {
            args: Prisma.SecurityAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.SecurityAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.SecurityAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          aggregate: {
            args: Prisma.SecurityAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityAuditLog>
          }
          groupBy: {
            args: Prisma.SecurityAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityAuditLogCountAggregateOutputType> | number
          }
        }
      }
      wrappers_fdw_stats: {
        payload: Prisma.$wrappers_fdw_statsPayload<ExtArgs>
        fields: Prisma.wrappers_fdw_statsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wrappers_fdw_statsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wrappers_fdw_statsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          findFirst: {
            args: Prisma.wrappers_fdw_statsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wrappers_fdw_statsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          findMany: {
            args: Prisma.wrappers_fdw_statsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>[]
          }
          create: {
            args: Prisma.wrappers_fdw_statsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          createMany: {
            args: Prisma.wrappers_fdw_statsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wrappers_fdw_statsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>[]
          }
          delete: {
            args: Prisma.wrappers_fdw_statsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          update: {
            args: Prisma.wrappers_fdw_statsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          deleteMany: {
            args: Prisma.wrappers_fdw_statsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wrappers_fdw_statsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.wrappers_fdw_statsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>[]
          }
          upsert: {
            args: Prisma.wrappers_fdw_statsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wrappers_fdw_statsPayload>
          }
          aggregate: {
            args: Prisma.Wrappers_fdw_statsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWrappers_fdw_stats>
          }
          groupBy: {
            args: Prisma.wrappers_fdw_statsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wrappers_fdw_statsGroupByOutputType>[]
          }
          count: {
            args: Prisma.wrappers_fdw_statsCountArgs<ExtArgs>
            result: $Utils.Optional<Wrappers_fdw_statsCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      ReminderLog: {
        payload: Prisma.$ReminderLogPayload<ExtArgs>
        fields: Prisma.ReminderLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          findFirst: {
            args: Prisma.ReminderLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          findMany: {
            args: Prisma.ReminderLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>[]
          }
          create: {
            args: Prisma.ReminderLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          createMany: {
            args: Prisma.ReminderLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>[]
          }
          delete: {
            args: Prisma.ReminderLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          update: {
            args: Prisma.ReminderLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          deleteMany: {
            args: Prisma.ReminderLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReminderLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>[]
          }
          upsert: {
            args: Prisma.ReminderLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderLogPayload>
          }
          aggregate: {
            args: Prisma.ReminderLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminderLog>
          }
          groupBy: {
            args: Prisma.ReminderLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderLogCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderLogCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserFeatureAccess: {
        payload: Prisma.$UserFeatureAccessPayload<ExtArgs>
        fields: Prisma.UserFeatureAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeatureAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeatureAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          findFirst: {
            args: Prisma.UserFeatureAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeatureAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          findMany: {
            args: Prisma.UserFeatureAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>[]
          }
          create: {
            args: Prisma.UserFeatureAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          createMany: {
            args: Prisma.UserFeatureAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeatureAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>[]
          }
          delete: {
            args: Prisma.UserFeatureAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          update: {
            args: Prisma.UserFeatureAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          deleteMany: {
            args: Prisma.UserFeatureAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeatureAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFeatureAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>[]
          }
          upsert: {
            args: Prisma.UserFeatureAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureAccessPayload>
          }
          aggregate: {
            args: Prisma.UserFeatureAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeatureAccess>
          }
          groupBy: {
            args: Prisma.UserFeatureAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeatureAccessCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureAccessCountAggregateOutputType> | number
          }
        }
      }
      UserAccessLog: {
        payload: Prisma.$UserAccessLogPayload<ExtArgs>
        fields: Prisma.UserAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          findFirst: {
            args: Prisma.UserAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          findMany: {
            args: Prisma.UserAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          create: {
            args: Prisma.UserAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          createMany: {
            args: Prisma.UserAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          delete: {
            args: Prisma.UserAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          update: {
            args: Prisma.UserAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.UserAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAccessLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>[]
          }
          upsert: {
            args: Prisma.UserAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccessLogPayload>
          }
          aggregate: {
            args: Prisma.UserAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccessLog>
          }
          groupBy: {
            args: Prisma.UserAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccessLogCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      FailedWebhookEvent: {
        payload: Prisma.$FailedWebhookEventPayload<ExtArgs>
        fields: Prisma.FailedWebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FailedWebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FailedWebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          findFirst: {
            args: Prisma.FailedWebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FailedWebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          findMany: {
            args: Prisma.FailedWebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>[]
          }
          create: {
            args: Prisma.FailedWebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          createMany: {
            args: Prisma.FailedWebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FailedWebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>[]
          }
          delete: {
            args: Prisma.FailedWebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          update: {
            args: Prisma.FailedWebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.FailedWebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FailedWebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FailedWebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.FailedWebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedWebhookEventPayload>
          }
          aggregate: {
            args: Prisma.FailedWebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailedWebhookEvent>
          }
          groupBy: {
            args: Prisma.FailedWebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FailedWebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FailedWebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<FailedWebhookEventCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      PaymentFailure: {
        payload: Prisma.$PaymentFailurePayload<ExtArgs>
        fields: Prisma.PaymentFailureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFailureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFailureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          findFirst: {
            args: Prisma.PaymentFailureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFailureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          findMany: {
            args: Prisma.PaymentFailureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>[]
          }
          create: {
            args: Prisma.PaymentFailureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          createMany: {
            args: Prisma.PaymentFailureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentFailureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>[]
          }
          delete: {
            args: Prisma.PaymentFailureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          update: {
            args: Prisma.PaymentFailureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          deleteMany: {
            args: Prisma.PaymentFailureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentFailureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentFailureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>[]
          }
          upsert: {
            args: Prisma.PaymentFailureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentFailurePayload>
          }
          aggregate: {
            args: Prisma.PaymentFailureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentFailure>
          }
          groupBy: {
            args: Prisma.PaymentFailureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentFailureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentFailureCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentFailureCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    blogArticle?: BlogArticleOmit
    blogTag?: BlogTagOmit
    customerInvoice?: CustomerInvoiceOmit
    customerInvoiceItem?: CustomerInvoiceItemOmit
    document?: DocumentOmit
    expense?: ExpenseOmit
    inspection?: InspectionOmit
    invoice?: InvoiceOmit
    invoiceLeadCapture?: InvoiceLeadCaptureOmit
    lease?: LeaseOmit
    leaseGeneratorUsage?: LeaseGeneratorUsageOmit
    maintenanceRequest?: MaintenanceRequestOmit
    message?: MessageOmit
    property?: PropertyOmit
    subscription?: SubscriptionOmit
    tenant?: TenantOmit
    unit?: UnitOmit
    user?: UserOmit
    userSession?: UserSessionOmit
    securityAuditLog?: SecurityAuditLogOmit
    wrappers_fdw_stats?: wrappers_fdw_statsOmit
    activity?: ActivityOmit
    webhookEvent?: WebhookEventOmit
    reminderLog?: ReminderLogOmit
    userPreferences?: UserPreferencesOmit
    userFeatureAccess?: UserFeatureAccessOmit
    userAccessLog?: UserAccessLogOmit
    notificationLog?: NotificationLogOmit
    failedWebhookEvent?: FailedWebhookEventOmit
    file?: FileOmit
    paymentFailure?: PaymentFailureOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BlogArticleCountOutputType
   */

  export type BlogArticleCountOutputType = {
    tags: number
  }

  export type BlogArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | BlogArticleCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * BlogArticleCountOutputType without action
   */
  export type BlogArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticleCountOutputType
     */
    select?: BlogArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogArticleCountOutputType without action
   */
  export type BlogArticleCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
  }


  /**
   * Count Type BlogTagCountOutputType
   */

  export type BlogTagCountOutputType = {
    articles: number
  }

  export type BlogTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | BlogTagCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTagCountOutputType
     */
    select?: BlogTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogArticleWhereInput
  }


  /**
   * Count Type CustomerInvoiceCountOutputType
   */

  export type CustomerInvoiceCountOutputType = {
    items: number
  }

  export type CustomerInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CustomerInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CustomerInvoiceCountOutputType without action
   */
  export type CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceCountOutputType
     */
    select?: CustomerInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerInvoiceCountOutputType without action
   */
  export type CustomerInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceItemWhereInput
  }


  /**
   * Count Type LeaseCountOutputType
   */

  export type LeaseCountOutputType = {
    Document: number
    reminders: number
  }

  export type LeaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | LeaseCountOutputTypeCountDocumentArgs
    reminders?: boolean | LeaseCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes
  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseCountOutputType
     */
    select?: LeaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * LeaseCountOutputType without action
   */
  export type LeaseCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderLogWhereInput
  }


  /**
   * Count Type MaintenanceRequestCountOutputType
   */

  export type MaintenanceRequestCountOutputType = {
    Expense: number
    files: number
  }

  export type MaintenanceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Expense?: boolean | MaintenanceRequestCountOutputTypeCountExpenseArgs
    files?: boolean | MaintenanceRequestCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequestCountOutputType
     */
    select?: MaintenanceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeCountExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * MaintenanceRequestCountOutputType without action
   */
  export type MaintenanceRequestCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    Document: number
    Expense: number
    Inspection: number
    Unit: number
    files: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | PropertyCountOutputTypeCountDocumentArgs
    Expense?: boolean | PropertyCountOutputTypeCountExpenseArgs
    Inspection?: boolean | PropertyCountOutputTypeCountInspectionArgs
    Unit?: boolean | PropertyCountOutputTypeCountUnitArgs
    files?: boolean | PropertyCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountInspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    Invoice: number
    paymentFailures: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Invoice?: boolean | SubscriptionCountOutputTypeCountInvoiceArgs
    paymentFailures?: boolean | SubscriptionCountOutputTypeCountPaymentFailuresArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentFailureWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    Lease: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | TenantCountOutputTypeCountLeaseArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    Inspection: number
    Lease: number
    MaintenanceRequest: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inspection?: boolean | UnitCountOutputTypeCountInspectionArgs
    Lease?: boolean | UnitCountOutputTypeCountLeaseArgs
    MaintenanceRequest?: boolean | UnitCountOutputTypeCountMaintenanceRequestArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountInspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountLeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountMaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    BlogArticle: number
    Inspection: number
    Invoice: number
    LeaseGeneratorUsage: number
    Message_Message_receiverIdToUser: number
    Message_Message_senderIdToUser: number
    Property: number
    Subscription: number
    Tenant: number
    activities: number
    reminders: number
    sessions: number
    accessLogs: number
    notificationLogs: number
    uploadedFiles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogArticle?: boolean | UserCountOutputTypeCountBlogArticleArgs
    Inspection?: boolean | UserCountOutputTypeCountInspectionArgs
    Invoice?: boolean | UserCountOutputTypeCountInvoiceArgs
    LeaseGeneratorUsage?: boolean | UserCountOutputTypeCountLeaseGeneratorUsageArgs
    Message_Message_receiverIdToUser?: boolean | UserCountOutputTypeCountMessage_Message_receiverIdToUserArgs
    Message_Message_senderIdToUser?: boolean | UserCountOutputTypeCountMessage_Message_senderIdToUserArgs
    Property?: boolean | UserCountOutputTypeCountPropertyArgs
    Subscription?: boolean | UserCountOutputTypeCountSubscriptionArgs
    Tenant?: boolean | UserCountOutputTypeCountTenantArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    reminders?: boolean | UserCountOutputTypeCountRemindersArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accessLogs?: boolean | UserCountOutputTypeCountAccessLogsArgs
    notificationLogs?: boolean | UserCountOutputTypeCountNotificationLogsArgs
    uploadedFiles?: boolean | UserCountOutputTypeCountUploadedFilesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaseGeneratorUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseGeneratorUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_receiverIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_senderIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccessLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BlogArticle
   */

  export type AggregateBlogArticle = {
    _count: BlogArticleCountAggregateOutputType | null
    _avg: BlogArticleAvgAggregateOutputType | null
    _sum: BlogArticleSumAggregateOutputType | null
    _min: BlogArticleMinAggregateOutputType | null
    _max: BlogArticleMaxAggregateOutputType | null
  }

  export type BlogArticleAvgAggregateOutputType = {
    viewCount: number | null
    readTime: number | null
  }

  export type BlogArticleSumAggregateOutputType = {
    viewCount: number | null
    readTime: number | null
  }

  export type BlogArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    content: string | null
    excerpt: string | null
    authorId: string | null
    authorName: string | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    category: $Enums.BlogCategory | null
    status: $Enums.BlogStatus | null
    featured: boolean | null
    publishedAt: Date | null
    viewCount: number | null
    readTime: number | null
    lastIndexed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    content: string | null
    excerpt: string | null
    authorId: string | null
    authorName: string | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    category: $Enums.BlogCategory | null
    status: $Enums.BlogStatus | null
    featured: boolean | null
    publishedAt: Date | null
    viewCount: number | null
    readTime: number | null
    lastIndexed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogArticleCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    content: number
    excerpt: number
    authorId: number
    authorName: number
    metaTitle: number
    metaDescription: number
    ogImage: number
    category: number
    status: number
    featured: number
    publishedAt: number
    viewCount: number
    readTime: number
    searchKeywords: number
    lastIndexed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogArticleAvgAggregateInputType = {
    viewCount?: true
    readTime?: true
  }

  export type BlogArticleSumAggregateInputType = {
    viewCount?: true
    readTime?: true
  }

  export type BlogArticleMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    content?: true
    excerpt?: true
    authorId?: true
    authorName?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    category?: true
    status?: true
    featured?: true
    publishedAt?: true
    viewCount?: true
    readTime?: true
    lastIndexed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogArticleMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    content?: true
    excerpt?: true
    authorId?: true
    authorName?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    category?: true
    status?: true
    featured?: true
    publishedAt?: true
    viewCount?: true
    readTime?: true
    lastIndexed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogArticleCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    content?: true
    excerpt?: true
    authorId?: true
    authorName?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    category?: true
    status?: true
    featured?: true
    publishedAt?: true
    viewCount?: true
    readTime?: true
    searchKeywords?: true
    lastIndexed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogArticle to aggregate.
     */
    where?: BlogArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogArticles to fetch.
     */
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogArticles
    **/
    _count?: true | BlogArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogArticleMaxAggregateInputType
  }

  export type GetBlogArticleAggregateType<T extends BlogArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogArticle[P]>
      : GetScalarType<T[P], AggregateBlogArticle[P]>
  }




  export type BlogArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogArticleWhereInput
    orderBy?: BlogArticleOrderByWithAggregationInput | BlogArticleOrderByWithAggregationInput[]
    by: BlogArticleScalarFieldEnum[] | BlogArticleScalarFieldEnum
    having?: BlogArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogArticleCountAggregateInputType | true
    _avg?: BlogArticleAvgAggregateInputType
    _sum?: BlogArticleSumAggregateInputType
    _min?: BlogArticleMinAggregateInputType
    _max?: BlogArticleMaxAggregateInputType
  }

  export type BlogArticleGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string
    content: string
    excerpt: string | null
    authorId: string | null
    authorName: string
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    category: $Enums.BlogCategory
    status: $Enums.BlogStatus
    featured: boolean
    publishedAt: Date | null
    viewCount: number
    readTime: number | null
    searchKeywords: string[]
    lastIndexed: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BlogArticleCountAggregateOutputType | null
    _avg: BlogArticleAvgAggregateOutputType | null
    _sum: BlogArticleSumAggregateOutputType | null
    _min: BlogArticleMinAggregateOutputType | null
    _max: BlogArticleMaxAggregateOutputType | null
  }

  type GetBlogArticleGroupByPayload<T extends BlogArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogArticleGroupByOutputType[P]>
            : GetScalarType<T[P], BlogArticleGroupByOutputType[P]>
        }
      >
    >


  export type BlogArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    content?: boolean
    excerpt?: boolean
    authorId?: boolean
    authorName?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    ogImage?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    readTime?: boolean
    searchKeywords?: boolean
    lastIndexed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tags?: boolean | BlogArticle$tagsArgs<ExtArgs>
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
    _count?: boolean | BlogArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogArticle"]>

  export type BlogArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    content?: boolean
    excerpt?: boolean
    authorId?: boolean
    authorName?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    ogImage?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    readTime?: boolean
    searchKeywords?: boolean
    lastIndexed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogArticle"]>

  export type BlogArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    content?: boolean
    excerpt?: boolean
    authorId?: boolean
    authorName?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    ogImage?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    readTime?: boolean
    searchKeywords?: boolean
    lastIndexed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
  }, ExtArgs["result"]["blogArticle"]>

  export type BlogArticleSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    content?: boolean
    excerpt?: boolean
    authorId?: boolean
    authorName?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    ogImage?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    readTime?: boolean
    searchKeywords?: boolean
    lastIndexed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "content" | "excerpt" | "authorId" | "authorName" | "metaTitle" | "metaDescription" | "ogImage" | "category" | "status" | "featured" | "publishedAt" | "viewCount" | "readTime" | "searchKeywords" | "lastIndexed" | "createdAt" | "updatedAt", ExtArgs["result"]["blogArticle"]>
  export type BlogArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | BlogArticle$tagsArgs<ExtArgs>
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
    _count?: boolean | BlogArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
  }
  export type BlogArticleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | BlogArticle$authorArgs<ExtArgs>
  }

  export type $BlogArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogArticle"
    objects: {
      tags: Prisma.$BlogTagPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string
      content: string
      excerpt: string | null
      authorId: string | null
      authorName: string
      metaTitle: string | null
      metaDescription: string | null
      ogImage: string | null
      category: $Enums.BlogCategory
      status: $Enums.BlogStatus
      featured: boolean
      publishedAt: Date | null
      viewCount: number
      readTime: number | null
      searchKeywords: string[]
      lastIndexed: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogArticle"]>
    composites: {}
  }

  type BlogArticleGetPayload<S extends boolean | null | undefined | BlogArticleDefaultArgs> = $Result.GetResult<Prisma.$BlogArticlePayload, S>

  type BlogArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogArticleCountAggregateInputType | true
    }

  export interface BlogArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogArticle'], meta: { name: 'BlogArticle' } }
    /**
     * Find zero or one BlogArticle that matches the filter.
     * @param {BlogArticleFindUniqueArgs} args - Arguments to find a BlogArticle
     * @example
     * // Get one BlogArticle
     * const blogArticle = await prisma.blogArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogArticleFindUniqueArgs>(args: SelectSubset<T, BlogArticleFindUniqueArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogArticle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogArticleFindUniqueOrThrowArgs} args - Arguments to find a BlogArticle
     * @example
     * // Get one BlogArticle
     * const blogArticle = await prisma.blogArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleFindFirstArgs} args - Arguments to find a BlogArticle
     * @example
     * // Get one BlogArticle
     * const blogArticle = await prisma.blogArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogArticleFindFirstArgs>(args?: SelectSubset<T, BlogArticleFindFirstArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleFindFirstOrThrowArgs} args - Arguments to find a BlogArticle
     * @example
     * // Get one BlogArticle
     * const blogArticle = await prisma.blogArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogArticles
     * const blogArticles = await prisma.blogArticle.findMany()
     * 
     * // Get first 10 BlogArticles
     * const blogArticles = await prisma.blogArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogArticleWithIdOnly = await prisma.blogArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogArticleFindManyArgs>(args?: SelectSubset<T, BlogArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogArticle.
     * @param {BlogArticleCreateArgs} args - Arguments to create a BlogArticle.
     * @example
     * // Create one BlogArticle
     * const BlogArticle = await prisma.blogArticle.create({
     *   data: {
     *     // ... data to create a BlogArticle
     *   }
     * })
     * 
     */
    create<T extends BlogArticleCreateArgs>(args: SelectSubset<T, BlogArticleCreateArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogArticles.
     * @param {BlogArticleCreateManyArgs} args - Arguments to create many BlogArticles.
     * @example
     * // Create many BlogArticles
     * const blogArticle = await prisma.blogArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogArticleCreateManyArgs>(args?: SelectSubset<T, BlogArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogArticles and returns the data saved in the database.
     * @param {BlogArticleCreateManyAndReturnArgs} args - Arguments to create many BlogArticles.
     * @example
     * // Create many BlogArticles
     * const blogArticle = await prisma.blogArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogArticles and only return the `id`
     * const blogArticleWithIdOnly = await prisma.blogArticle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogArticle.
     * @param {BlogArticleDeleteArgs} args - Arguments to delete one BlogArticle.
     * @example
     * // Delete one BlogArticle
     * const BlogArticle = await prisma.blogArticle.delete({
     *   where: {
     *     // ... filter to delete one BlogArticle
     *   }
     * })
     * 
     */
    delete<T extends BlogArticleDeleteArgs>(args: SelectSubset<T, BlogArticleDeleteArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogArticle.
     * @param {BlogArticleUpdateArgs} args - Arguments to update one BlogArticle.
     * @example
     * // Update one BlogArticle
     * const blogArticle = await prisma.blogArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogArticleUpdateArgs>(args: SelectSubset<T, BlogArticleUpdateArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogArticles.
     * @param {BlogArticleDeleteManyArgs} args - Arguments to filter BlogArticles to delete.
     * @example
     * // Delete a few BlogArticles
     * const { count } = await prisma.blogArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogArticleDeleteManyArgs>(args?: SelectSubset<T, BlogArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogArticles
     * const blogArticle = await prisma.blogArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogArticleUpdateManyArgs>(args: SelectSubset<T, BlogArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogArticles and returns the data updated in the database.
     * @param {BlogArticleUpdateManyAndReturnArgs} args - Arguments to update many BlogArticles.
     * @example
     * // Update many BlogArticles
     * const blogArticle = await prisma.blogArticle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogArticles and only return the `id`
     * const blogArticleWithIdOnly = await prisma.blogArticle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogArticle.
     * @param {BlogArticleUpsertArgs} args - Arguments to update or create a BlogArticle.
     * @example
     * // Update or create a BlogArticle
     * const blogArticle = await prisma.blogArticle.upsert({
     *   create: {
     *     // ... data to create a BlogArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogArticle we want to update
     *   }
     * })
     */
    upsert<T extends BlogArticleUpsertArgs>(args: SelectSubset<T, BlogArticleUpsertArgs<ExtArgs>>): Prisma__BlogArticleClient<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleCountArgs} args - Arguments to filter BlogArticles to count.
     * @example
     * // Count the number of BlogArticles
     * const count = await prisma.blogArticle.count({
     *   where: {
     *     // ... the filter for the BlogArticles we want to count
     *   }
     * })
    **/
    count<T extends BlogArticleCountArgs>(
      args?: Subset<T, BlogArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogArticleAggregateArgs>(args: Subset<T, BlogArticleAggregateArgs>): Prisma.PrismaPromise<GetBlogArticleAggregateType<T>>

    /**
     * Group by BlogArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogArticleGroupByArgs['orderBy'] }
        : { orderBy?: BlogArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogArticle model
   */
  readonly fields: BlogArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends BlogArticle$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogArticle$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends BlogArticle$authorArgs<ExtArgs> = {}>(args?: Subset<T, BlogArticle$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogArticle model
   */
  interface BlogArticleFieldRefs {
    readonly id: FieldRef<"BlogArticle", 'String'>
    readonly title: FieldRef<"BlogArticle", 'String'>
    readonly slug: FieldRef<"BlogArticle", 'String'>
    readonly description: FieldRef<"BlogArticle", 'String'>
    readonly content: FieldRef<"BlogArticle", 'String'>
    readonly excerpt: FieldRef<"BlogArticle", 'String'>
    readonly authorId: FieldRef<"BlogArticle", 'String'>
    readonly authorName: FieldRef<"BlogArticle", 'String'>
    readonly metaTitle: FieldRef<"BlogArticle", 'String'>
    readonly metaDescription: FieldRef<"BlogArticle", 'String'>
    readonly ogImage: FieldRef<"BlogArticle", 'String'>
    readonly category: FieldRef<"BlogArticle", 'BlogCategory'>
    readonly status: FieldRef<"BlogArticle", 'BlogStatus'>
    readonly featured: FieldRef<"BlogArticle", 'Boolean'>
    readonly publishedAt: FieldRef<"BlogArticle", 'DateTime'>
    readonly viewCount: FieldRef<"BlogArticle", 'Int'>
    readonly readTime: FieldRef<"BlogArticle", 'Int'>
    readonly searchKeywords: FieldRef<"BlogArticle", 'String[]'>
    readonly lastIndexed: FieldRef<"BlogArticle", 'DateTime'>
    readonly createdAt: FieldRef<"BlogArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogArticle findUnique
   */
  export type BlogArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter, which BlogArticle to fetch.
     */
    where: BlogArticleWhereUniqueInput
  }

  /**
   * BlogArticle findUniqueOrThrow
   */
  export type BlogArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter, which BlogArticle to fetch.
     */
    where: BlogArticleWhereUniqueInput
  }

  /**
   * BlogArticle findFirst
   */
  export type BlogArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter, which BlogArticle to fetch.
     */
    where?: BlogArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogArticles to fetch.
     */
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogArticles.
     */
    cursor?: BlogArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogArticles.
     */
    distinct?: BlogArticleScalarFieldEnum | BlogArticleScalarFieldEnum[]
  }

  /**
   * BlogArticle findFirstOrThrow
   */
  export type BlogArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter, which BlogArticle to fetch.
     */
    where?: BlogArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogArticles to fetch.
     */
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogArticles.
     */
    cursor?: BlogArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogArticles.
     */
    distinct?: BlogArticleScalarFieldEnum | BlogArticleScalarFieldEnum[]
  }

  /**
   * BlogArticle findMany
   */
  export type BlogArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter, which BlogArticles to fetch.
     */
    where?: BlogArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogArticles to fetch.
     */
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogArticles.
     */
    cursor?: BlogArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogArticles.
     */
    skip?: number
    distinct?: BlogArticleScalarFieldEnum | BlogArticleScalarFieldEnum[]
  }

  /**
   * BlogArticle create
   */
  export type BlogArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogArticle.
     */
    data: XOR<BlogArticleCreateInput, BlogArticleUncheckedCreateInput>
  }

  /**
   * BlogArticle createMany
   */
  export type BlogArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogArticles.
     */
    data: BlogArticleCreateManyInput | BlogArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogArticle createManyAndReturn
   */
  export type BlogArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * The data used to create many BlogArticles.
     */
    data: BlogArticleCreateManyInput | BlogArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogArticle update
   */
  export type BlogArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogArticle.
     */
    data: XOR<BlogArticleUpdateInput, BlogArticleUncheckedUpdateInput>
    /**
     * Choose, which BlogArticle to update.
     */
    where: BlogArticleWhereUniqueInput
  }

  /**
   * BlogArticle updateMany
   */
  export type BlogArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogArticles.
     */
    data: XOR<BlogArticleUpdateManyMutationInput, BlogArticleUncheckedUpdateManyInput>
    /**
     * Filter which BlogArticles to update
     */
    where?: BlogArticleWhereInput
    /**
     * Limit how many BlogArticles to update.
     */
    limit?: number
  }

  /**
   * BlogArticle updateManyAndReturn
   */
  export type BlogArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * The data used to update BlogArticles.
     */
    data: XOR<BlogArticleUpdateManyMutationInput, BlogArticleUncheckedUpdateManyInput>
    /**
     * Filter which BlogArticles to update
     */
    where?: BlogArticleWhereInput
    /**
     * Limit how many BlogArticles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogArticle upsert
   */
  export type BlogArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogArticle to update in case it exists.
     */
    where: BlogArticleWhereUniqueInput
    /**
     * In case the BlogArticle found by the `where` argument doesn't exist, create a new BlogArticle with this data.
     */
    create: XOR<BlogArticleCreateInput, BlogArticleUncheckedCreateInput>
    /**
     * In case the BlogArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogArticleUpdateInput, BlogArticleUncheckedUpdateInput>
  }

  /**
   * BlogArticle delete
   */
  export type BlogArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    /**
     * Filter which BlogArticle to delete.
     */
    where: BlogArticleWhereUniqueInput
  }

  /**
   * BlogArticle deleteMany
   */
  export type BlogArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogArticles to delete
     */
    where?: BlogArticleWhereInput
    /**
     * Limit how many BlogArticles to delete.
     */
    limit?: number
  }

  /**
   * BlogArticle.tags
   */
  export type BlogArticle$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    cursor?: BlogTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogArticle.author
   */
  export type BlogArticle$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlogArticle without action
   */
  export type BlogArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
  }


  /**
   * Model BlogTag
   */

  export type AggregateBlogTag = {
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  export type BlogTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    color: string | null
    createdAt: Date | null
  }

  export type BlogTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    color: string | null
    createdAt: Date | null
  }

  export type BlogTagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    color: number
    createdAt: number
    _all: number
  }


  export type BlogTagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    color?: true
    createdAt?: true
  }

  export type BlogTagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    color?: true
    createdAt?: true
  }

  export type BlogTagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type BlogTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTag to aggregate.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTags
    **/
    _count?: true | BlogTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTagMaxAggregateInputType
  }

  export type GetBlogTagAggregateType<T extends BlogTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTag[P]>
      : GetScalarType<T[P], AggregateBlogTag[P]>
  }




  export type BlogTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithAggregationInput | BlogTagOrderByWithAggregationInput[]
    by: BlogTagScalarFieldEnum[] | BlogTagScalarFieldEnum
    having?: BlogTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTagCountAggregateInputType | true
    _min?: BlogTagMinAggregateInputType
    _max?: BlogTagMaxAggregateInputType
  }

  export type BlogTagGroupByOutputType = {
    id: string
    name: string
    slug: string
    color: string | null
    createdAt: Date
    _count: BlogTagCountAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  type GetBlogTagGroupByPayload<T extends BlogTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
    articles?: boolean | BlogTag$articlesArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type BlogTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "color" | "createdAt", ExtArgs["result"]["blogTag"]>
  export type BlogTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | BlogTag$articlesArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTag"
    objects: {
      articles: Prisma.$BlogArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["blogTag"]>
    composites: {}
  }

  type BlogTagGetPayload<S extends boolean | null | undefined | BlogTagDefaultArgs> = $Result.GetResult<Prisma.$BlogTagPayload, S>

  type BlogTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogTagCountAggregateInputType | true
    }

  export interface BlogTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTag'], meta: { name: 'BlogTag' } }
    /**
     * Find zero or one BlogTag that matches the filter.
     * @param {BlogTagFindUniqueArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTagFindUniqueArgs>(args: SelectSubset<T, BlogTagFindUniqueArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogTagFindUniqueOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTagFindFirstArgs>(args?: SelectSubset<T, BlogTagFindFirstArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTags
     * const blogTags = await prisma.blogTag.findMany()
     * 
     * // Get first 10 BlogTags
     * const blogTags = await prisma.blogTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogTagFindManyArgs>(args?: SelectSubset<T, BlogTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogTag.
     * @param {BlogTagCreateArgs} args - Arguments to create a BlogTag.
     * @example
     * // Create one BlogTag
     * const BlogTag = await prisma.blogTag.create({
     *   data: {
     *     // ... data to create a BlogTag
     *   }
     * })
     * 
     */
    create<T extends BlogTagCreateArgs>(args: SelectSubset<T, BlogTagCreateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogTags.
     * @param {BlogTagCreateManyArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTagCreateManyArgs>(args?: SelectSubset<T, BlogTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogTags and returns the data saved in the database.
     * @param {BlogTagCreateManyAndReturnArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogTag.
     * @param {BlogTagDeleteArgs} args - Arguments to delete one BlogTag.
     * @example
     * // Delete one BlogTag
     * const BlogTag = await prisma.blogTag.delete({
     *   where: {
     *     // ... filter to delete one BlogTag
     *   }
     * })
     * 
     */
    delete<T extends BlogTagDeleteArgs>(args: SelectSubset<T, BlogTagDeleteArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogTag.
     * @param {BlogTagUpdateArgs} args - Arguments to update one BlogTag.
     * @example
     * // Update one BlogTag
     * const blogTag = await prisma.blogTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTagUpdateArgs>(args: SelectSubset<T, BlogTagUpdateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogTags.
     * @param {BlogTagDeleteManyArgs} args - Arguments to filter BlogTags to delete.
     * @example
     * // Delete a few BlogTags
     * const { count } = await prisma.blogTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTagDeleteManyArgs>(args?: SelectSubset<T, BlogTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTagUpdateManyArgs>(args: SelectSubset<T, BlogTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags and returns the data updated in the database.
     * @param {BlogTagUpdateManyAndReturnArgs} args - Arguments to update many BlogTags.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogTag.
     * @param {BlogTagUpsertArgs} args - Arguments to update or create a BlogTag.
     * @example
     * // Update or create a BlogTag
     * const blogTag = await prisma.blogTag.upsert({
     *   create: {
     *     // ... data to create a BlogTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogTagUpsertArgs>(args: SelectSubset<T, BlogTagUpsertArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagCountArgs} args - Arguments to filter BlogTags to count.
     * @example
     * // Count the number of BlogTags
     * const count = await prisma.blogTag.count({
     *   where: {
     *     // ... the filter for the BlogTags we want to count
     *   }
     * })
    **/
    count<T extends BlogTagCountArgs>(
      args?: Subset<T, BlogTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTagAggregateArgs>(args: Subset<T, BlogTagAggregateArgs>): Prisma.PrismaPromise<GetBlogTagAggregateType<T>>

    /**
     * Group by BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTag model
   */
  readonly fields: BlogTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends BlogTag$articlesArgs<ExtArgs> = {}>(args?: Subset<T, BlogTag$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTag model
   */
  interface BlogTagFieldRefs {
    readonly id: FieldRef<"BlogTag", 'String'>
    readonly name: FieldRef<"BlogTag", 'String'>
    readonly slug: FieldRef<"BlogTag", 'String'>
    readonly color: FieldRef<"BlogTag", 'String'>
    readonly createdAt: FieldRef<"BlogTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogTag findUnique
   */
  export type BlogTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findUniqueOrThrow
   */
  export type BlogTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findFirst
   */
  export type BlogTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findFirstOrThrow
   */
  export type BlogTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findMany
   */
  export type BlogTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTags to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag create
   */
  export type BlogTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogTag.
     */
    data: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
  }

  /**
   * BlogTag createMany
   */
  export type BlogTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag createManyAndReturn
   */
  export type BlogTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag update
   */
  export type BlogTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogTag.
     */
    data: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
    /**
     * Choose, which BlogTag to update.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag updateMany
   */
  export type BlogTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag updateManyAndReturn
   */
  export type BlogTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag upsert
   */
  export type BlogTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogTag to update in case it exists.
     */
    where: BlogTagWhereUniqueInput
    /**
     * In case the BlogTag found by the `where` argument doesn't exist, create a new BlogTag with this data.
     */
    create: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
    /**
     * In case the BlogTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
  }

  /**
   * BlogTag delete
   */
  export type BlogTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter which BlogTag to delete.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag deleteMany
   */
  export type BlogTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTags to delete
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to delete.
     */
    limit?: number
  }

  /**
   * BlogTag.articles
   */
  export type BlogTag$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    where?: BlogArticleWhereInput
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    cursor?: BlogArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogArticleScalarFieldEnum | BlogArticleScalarFieldEnum[]
  }

  /**
   * BlogTag without action
   */
  export type BlogTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
  }


  /**
   * Model CustomerInvoice
   */

  export type AggregateCustomerInvoice = {
    _count: CustomerInvoiceCountAggregateOutputType | null
    _avg: CustomerInvoiceAvgAggregateOutputType | null
    _sum: CustomerInvoiceSumAggregateOutputType | null
    _min: CustomerInvoiceMinAggregateOutputType | null
    _max: CustomerInvoiceMaxAggregateOutputType | null
  }

  export type CustomerInvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    downloadCount: number | null
  }

  export type CustomerInvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    downloadCount: number | null
  }

  export type CustomerInvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: $Enums.CustomerInvoiceStatus | null
    businessName: string | null
    businessEmail: string | null
    businessAddress: string | null
    businessCity: string | null
    businessState: string | null
    businessZip: string | null
    businessPhone: string | null
    businessLogo: string | null
    clientName: string | null
    clientEmail: string | null
    clientAddress: string | null
    clientCity: string | null
    clientState: string | null
    clientZip: string | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    notes: string | null
    terms: string | null
    emailCaptured: string | null
    downloadCount: number | null
    isProVersion: boolean | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerInvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: $Enums.CustomerInvoiceStatus | null
    businessName: string | null
    businessEmail: string | null
    businessAddress: string | null
    businessCity: string | null
    businessState: string | null
    businessZip: string | null
    businessPhone: string | null
    businessLogo: string | null
    clientName: string | null
    clientEmail: string | null
    clientAddress: string | null
    clientCity: string | null
    clientState: string | null
    clientZip: string | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    notes: string | null
    terms: string | null
    emailCaptured: string | null
    downloadCount: number | null
    isProVersion: boolean | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    status: number
    businessName: number
    businessEmail: number
    businessAddress: number
    businessCity: number
    businessState: number
    businessZip: number
    businessPhone: number
    businessLogo: number
    clientName: number
    clientEmail: number
    clientAddress: number
    clientCity: number
    clientState: number
    clientZip: number
    issueDate: number
    dueDate: number
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    notes: number
    terms: number
    emailCaptured: number
    downloadCount: number
    isProVersion: number
    userAgent: number
    ipAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerInvoiceAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    downloadCount?: true
  }

  export type CustomerInvoiceSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    downloadCount?: true
  }

  export type CustomerInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    businessName?: true
    businessEmail?: true
    businessAddress?: true
    businessCity?: true
    businessState?: true
    businessZip?: true
    businessPhone?: true
    businessLogo?: true
    clientName?: true
    clientEmail?: true
    clientAddress?: true
    clientCity?: true
    clientState?: true
    clientZip?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    terms?: true
    emailCaptured?: true
    downloadCount?: true
    isProVersion?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    businessName?: true
    businessEmail?: true
    businessAddress?: true
    businessCity?: true
    businessState?: true
    businessZip?: true
    businessPhone?: true
    businessLogo?: true
    clientName?: true
    clientEmail?: true
    clientAddress?: true
    clientCity?: true
    clientState?: true
    clientZip?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    terms?: true
    emailCaptured?: true
    downloadCount?: true
    isProVersion?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    businessName?: true
    businessEmail?: true
    businessAddress?: true
    businessCity?: true
    businessState?: true
    businessZip?: true
    businessPhone?: true
    businessLogo?: true
    clientName?: true
    clientEmail?: true
    clientAddress?: true
    clientCity?: true
    clientState?: true
    clientZip?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    terms?: true
    emailCaptured?: true
    downloadCount?: true
    isProVersion?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoice to aggregate.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerInvoices
    **/
    _count?: true | CustomerInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerInvoiceMaxAggregateInputType
  }

  export type GetCustomerInvoiceAggregateType<T extends CustomerInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerInvoice[P]>
      : GetScalarType<T[P], AggregateCustomerInvoice[P]>
  }




  export type CustomerInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceWhereInput
    orderBy?: CustomerInvoiceOrderByWithAggregationInput | CustomerInvoiceOrderByWithAggregationInput[]
    by: CustomerInvoiceScalarFieldEnum[] | CustomerInvoiceScalarFieldEnum
    having?: CustomerInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerInvoiceCountAggregateInputType | true
    _avg?: CustomerInvoiceAvgAggregateInputType
    _sum?: CustomerInvoiceSumAggregateInputType
    _min?: CustomerInvoiceMinAggregateInputType
    _max?: CustomerInvoiceMaxAggregateInputType
  }

  export type CustomerInvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    status: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress: string | null
    businessCity: string | null
    businessState: string | null
    businessZip: string | null
    businessPhone: string | null
    businessLogo: string | null
    clientName: string
    clientEmail: string
    clientAddress: string | null
    clientCity: string | null
    clientState: string | null
    clientZip: string | null
    issueDate: Date
    dueDate: Date
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    notes: string | null
    terms: string | null
    emailCaptured: string | null
    downloadCount: number
    isProVersion: boolean
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerInvoiceCountAggregateOutputType | null
    _avg: CustomerInvoiceAvgAggregateOutputType | null
    _sum: CustomerInvoiceSumAggregateOutputType | null
    _min: CustomerInvoiceMinAggregateOutputType | null
    _max: CustomerInvoiceMaxAggregateOutputType | null
  }

  type GetCustomerInvoiceGroupByPayload<T extends CustomerInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    businessName?: boolean
    businessEmail?: boolean
    businessAddress?: boolean
    businessCity?: boolean
    businessState?: boolean
    businessZip?: boolean
    businessPhone?: boolean
    businessLogo?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientAddress?: boolean
    clientCity?: boolean
    clientState?: boolean
    clientZip?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    terms?: boolean
    emailCaptured?: boolean
    downloadCount?: boolean
    isProVersion?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | CustomerInvoice$itemsArgs<ExtArgs>
    _count?: boolean | CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    businessName?: boolean
    businessEmail?: boolean
    businessAddress?: boolean
    businessCity?: boolean
    businessState?: boolean
    businessZip?: boolean
    businessPhone?: boolean
    businessLogo?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientAddress?: boolean
    clientCity?: boolean
    clientState?: boolean
    clientZip?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    terms?: boolean
    emailCaptured?: boolean
    downloadCount?: boolean
    isProVersion?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    businessName?: boolean
    businessEmail?: boolean
    businessAddress?: boolean
    businessCity?: boolean
    businessState?: boolean
    businessZip?: boolean
    businessPhone?: boolean
    businessLogo?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientAddress?: boolean
    clientCity?: boolean
    clientState?: boolean
    clientZip?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    terms?: boolean
    emailCaptured?: boolean
    downloadCount?: boolean
    isProVersion?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerInvoice"]>

  export type CustomerInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    businessName?: boolean
    businessEmail?: boolean
    businessAddress?: boolean
    businessCity?: boolean
    businessState?: boolean
    businessZip?: boolean
    businessPhone?: boolean
    businessLogo?: boolean
    clientName?: boolean
    clientEmail?: boolean
    clientAddress?: boolean
    clientCity?: boolean
    clientState?: boolean
    clientZip?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    terms?: boolean
    emailCaptured?: boolean
    downloadCount?: boolean
    isProVersion?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "status" | "businessName" | "businessEmail" | "businessAddress" | "businessCity" | "businessState" | "businessZip" | "businessPhone" | "businessLogo" | "clientName" | "clientEmail" | "clientAddress" | "clientCity" | "clientState" | "clientZip" | "issueDate" | "dueDate" | "subtotal" | "taxRate" | "taxAmount" | "total" | "notes" | "terms" | "emailCaptured" | "downloadCount" | "isProVersion" | "userAgent" | "ipAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["customerInvoice"]>
  export type CustomerInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CustomerInvoice$itemsArgs<ExtArgs>
    _count?: boolean | CustomerInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerInvoice"
    objects: {
      items: Prisma.$CustomerInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      status: $Enums.CustomerInvoiceStatus
      businessName: string
      businessEmail: string
      businessAddress: string | null
      businessCity: string | null
      businessState: string | null
      businessZip: string | null
      businessPhone: string | null
      businessLogo: string | null
      clientName: string
      clientEmail: string
      clientAddress: string | null
      clientCity: string | null
      clientState: string | null
      clientZip: string | null
      issueDate: Date
      dueDate: Date
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      notes: string | null
      terms: string | null
      emailCaptured: string | null
      downloadCount: number
      isProVersion: boolean
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerInvoice"]>
    composites: {}
  }

  type CustomerInvoiceGetPayload<S extends boolean | null | undefined | CustomerInvoiceDefaultArgs> = $Result.GetResult<Prisma.$CustomerInvoicePayload, S>

  type CustomerInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerInvoiceCountAggregateInputType | true
    }

  export interface CustomerInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerInvoice'], meta: { name: 'CustomerInvoice' } }
    /**
     * Find zero or one CustomerInvoice that matches the filter.
     * @param {CustomerInvoiceFindUniqueArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerInvoiceFindUniqueArgs>(args: SelectSubset<T, CustomerInvoiceFindUniqueArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerInvoiceFindUniqueOrThrowArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindFirstArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerInvoiceFindFirstArgs>(args?: SelectSubset<T, CustomerInvoiceFindFirstArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindFirstOrThrowArgs} args - Arguments to find a CustomerInvoice
     * @example
     * // Get one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerInvoices
     * const customerInvoices = await prisma.customerInvoice.findMany()
     * 
     * // Get first 10 CustomerInvoices
     * const customerInvoices = await prisma.customerInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerInvoiceFindManyArgs>(args?: SelectSubset<T, CustomerInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerInvoice.
     * @param {CustomerInvoiceCreateArgs} args - Arguments to create a CustomerInvoice.
     * @example
     * // Create one CustomerInvoice
     * const CustomerInvoice = await prisma.customerInvoice.create({
     *   data: {
     *     // ... data to create a CustomerInvoice
     *   }
     * })
     * 
     */
    create<T extends CustomerInvoiceCreateArgs>(args: SelectSubset<T, CustomerInvoiceCreateArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerInvoices.
     * @param {CustomerInvoiceCreateManyArgs} args - Arguments to create many CustomerInvoices.
     * @example
     * // Create many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerInvoiceCreateManyArgs>(args?: SelectSubset<T, CustomerInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerInvoices and returns the data saved in the database.
     * @param {CustomerInvoiceCreateManyAndReturnArgs} args - Arguments to create many CustomerInvoices.
     * @example
     * // Create many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerInvoices and only return the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerInvoice.
     * @param {CustomerInvoiceDeleteArgs} args - Arguments to delete one CustomerInvoice.
     * @example
     * // Delete one CustomerInvoice
     * const CustomerInvoice = await prisma.customerInvoice.delete({
     *   where: {
     *     // ... filter to delete one CustomerInvoice
     *   }
     * })
     * 
     */
    delete<T extends CustomerInvoiceDeleteArgs>(args: SelectSubset<T, CustomerInvoiceDeleteArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerInvoice.
     * @param {CustomerInvoiceUpdateArgs} args - Arguments to update one CustomerInvoice.
     * @example
     * // Update one CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerInvoiceUpdateArgs>(args: SelectSubset<T, CustomerInvoiceUpdateArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerInvoices.
     * @param {CustomerInvoiceDeleteManyArgs} args - Arguments to filter CustomerInvoices to delete.
     * @example
     * // Delete a few CustomerInvoices
     * const { count } = await prisma.customerInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerInvoiceDeleteManyArgs>(args?: SelectSubset<T, CustomerInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerInvoiceUpdateManyArgs>(args: SelectSubset<T, CustomerInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoices and returns the data updated in the database.
     * @param {CustomerInvoiceUpdateManyAndReturnArgs} args - Arguments to update many CustomerInvoices.
     * @example
     * // Update many CustomerInvoices
     * const customerInvoice = await prisma.customerInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerInvoices and only return the `id`
     * const customerInvoiceWithIdOnly = await prisma.customerInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerInvoice.
     * @param {CustomerInvoiceUpsertArgs} args - Arguments to update or create a CustomerInvoice.
     * @example
     * // Update or create a CustomerInvoice
     * const customerInvoice = await prisma.customerInvoice.upsert({
     *   create: {
     *     // ... data to create a CustomerInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerInvoice we want to update
     *   }
     * })
     */
    upsert<T extends CustomerInvoiceUpsertArgs>(args: SelectSubset<T, CustomerInvoiceUpsertArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceCountArgs} args - Arguments to filter CustomerInvoices to count.
     * @example
     * // Count the number of CustomerInvoices
     * const count = await prisma.customerInvoice.count({
     *   where: {
     *     // ... the filter for the CustomerInvoices we want to count
     *   }
     * })
    **/
    count<T extends CustomerInvoiceCountArgs>(
      args?: Subset<T, CustomerInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerInvoiceAggregateArgs>(args: Subset<T, CustomerInvoiceAggregateArgs>): Prisma.PrismaPromise<GetCustomerInvoiceAggregateType<T>>

    /**
     * Group by CustomerInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerInvoice model
   */
  readonly fields: CustomerInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends CustomerInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerInvoice model
   */
  interface CustomerInvoiceFieldRefs {
    readonly id: FieldRef<"CustomerInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"CustomerInvoice", 'String'>
    readonly status: FieldRef<"CustomerInvoice", 'CustomerInvoiceStatus'>
    readonly businessName: FieldRef<"CustomerInvoice", 'String'>
    readonly businessEmail: FieldRef<"CustomerInvoice", 'String'>
    readonly businessAddress: FieldRef<"CustomerInvoice", 'String'>
    readonly businessCity: FieldRef<"CustomerInvoice", 'String'>
    readonly businessState: FieldRef<"CustomerInvoice", 'String'>
    readonly businessZip: FieldRef<"CustomerInvoice", 'String'>
    readonly businessPhone: FieldRef<"CustomerInvoice", 'String'>
    readonly businessLogo: FieldRef<"CustomerInvoice", 'String'>
    readonly clientName: FieldRef<"CustomerInvoice", 'String'>
    readonly clientEmail: FieldRef<"CustomerInvoice", 'String'>
    readonly clientAddress: FieldRef<"CustomerInvoice", 'String'>
    readonly clientCity: FieldRef<"CustomerInvoice", 'String'>
    readonly clientState: FieldRef<"CustomerInvoice", 'String'>
    readonly clientZip: FieldRef<"CustomerInvoice", 'String'>
    readonly issueDate: FieldRef<"CustomerInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"CustomerInvoice", 'DateTime'>
    readonly subtotal: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly taxRate: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly taxAmount: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly total: FieldRef<"CustomerInvoice", 'Decimal'>
    readonly notes: FieldRef<"CustomerInvoice", 'String'>
    readonly terms: FieldRef<"CustomerInvoice", 'String'>
    readonly emailCaptured: FieldRef<"CustomerInvoice", 'String'>
    readonly downloadCount: FieldRef<"CustomerInvoice", 'Int'>
    readonly isProVersion: FieldRef<"CustomerInvoice", 'Boolean'>
    readonly userAgent: FieldRef<"CustomerInvoice", 'String'>
    readonly ipAddress: FieldRef<"CustomerInvoice", 'String'>
    readonly createdAt: FieldRef<"CustomerInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerInvoice findUnique
   */
  export type CustomerInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice findUniqueOrThrow
   */
  export type CustomerInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice findFirst
   */
  export type CustomerInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice findFirstOrThrow
   */
  export type CustomerInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoice to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice findMany
   */
  export type CustomerInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where?: CustomerInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoiceOrderByWithRelationInput | CustomerInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerInvoices.
     */
    cursor?: CustomerInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    distinct?: CustomerInvoiceScalarFieldEnum | CustomerInvoiceScalarFieldEnum[]
  }

  /**
   * CustomerInvoice create
   */
  export type CustomerInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerInvoice.
     */
    data: XOR<CustomerInvoiceCreateInput, CustomerInvoiceUncheckedCreateInput>
  }

  /**
   * CustomerInvoice createMany
   */
  export type CustomerInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerInvoices.
     */
    data: CustomerInvoiceCreateManyInput | CustomerInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerInvoice createManyAndReturn
   */
  export type CustomerInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerInvoices.
     */
    data: CustomerInvoiceCreateManyInput | CustomerInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerInvoice update
   */
  export type CustomerInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerInvoice.
     */
    data: XOR<CustomerInvoiceUpdateInput, CustomerInvoiceUncheckedUpdateInput>
    /**
     * Choose, which CustomerInvoice to update.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice updateMany
   */
  export type CustomerInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerInvoices.
     */
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoices to update
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to update.
     */
    limit?: number
  }

  /**
   * CustomerInvoice updateManyAndReturn
   */
  export type CustomerInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update CustomerInvoices.
     */
    data: XOR<CustomerInvoiceUpdateManyMutationInput, CustomerInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoices to update
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to update.
     */
    limit?: number
  }

  /**
   * CustomerInvoice upsert
   */
  export type CustomerInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerInvoice to update in case it exists.
     */
    where: CustomerInvoiceWhereUniqueInput
    /**
     * In case the CustomerInvoice found by the `where` argument doesn't exist, create a new CustomerInvoice with this data.
     */
    create: XOR<CustomerInvoiceCreateInput, CustomerInvoiceUncheckedCreateInput>
    /**
     * In case the CustomerInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerInvoiceUpdateInput, CustomerInvoiceUncheckedUpdateInput>
  }

  /**
   * CustomerInvoice delete
   */
  export type CustomerInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
    /**
     * Filter which CustomerInvoice to delete.
     */
    where: CustomerInvoiceWhereUniqueInput
  }

  /**
   * CustomerInvoice deleteMany
   */
  export type CustomerInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoices to delete
     */
    where?: CustomerInvoiceWhereInput
    /**
     * Limit how many CustomerInvoices to delete.
     */
    limit?: number
  }

  /**
   * CustomerInvoice.items
   */
  export type CustomerInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    where?: CustomerInvoiceItemWhereInput
    orderBy?: CustomerInvoiceItemOrderByWithRelationInput | CustomerInvoiceItemOrderByWithRelationInput[]
    cursor?: CustomerInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoiceItemScalarFieldEnum | CustomerInvoiceItemScalarFieldEnum[]
  }

  /**
   * CustomerInvoice without action
   */
  export type CustomerInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoice
     */
    select?: CustomerInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoice
     */
    omit?: CustomerInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model CustomerInvoiceItem
   */

  export type AggregateCustomerInvoiceItem = {
    _count: CustomerInvoiceItemCountAggregateOutputType | null
    _avg: CustomerInvoiceItemAvgAggregateOutputType | null
    _sum: CustomerInvoiceItemSumAggregateOutputType | null
    _min: CustomerInvoiceItemMinAggregateOutputType | null
    _max: CustomerInvoiceItemMaxAggregateOutputType | null
  }

  export type CustomerInvoiceItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type CustomerInvoiceItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type CustomerInvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type CustomerInvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
    createdAt: Date | null
  }

  export type CustomerInvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    total: number
    createdAt: number
    _all: number
  }


  export type CustomerInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type CustomerInvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type CustomerInvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    createdAt?: true
  }

  export type CustomerInvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    createdAt?: true
  }

  export type CustomerInvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoiceItem to aggregate.
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceItems to fetch.
     */
    orderBy?: CustomerInvoiceItemOrderByWithRelationInput | CustomerInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerInvoiceItems
    **/
    _count?: true | CustomerInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerInvoiceItemMaxAggregateInputType
  }

  export type GetCustomerInvoiceItemAggregateType<T extends CustomerInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerInvoiceItem[P]>
      : GetScalarType<T[P], AggregateCustomerInvoiceItem[P]>
  }




  export type CustomerInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoiceItemWhereInput
    orderBy?: CustomerInvoiceItemOrderByWithAggregationInput | CustomerInvoiceItemOrderByWithAggregationInput[]
    by: CustomerInvoiceItemScalarFieldEnum[] | CustomerInvoiceItemScalarFieldEnum
    having?: CustomerInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerInvoiceItemCountAggregateInputType | true
    _avg?: CustomerInvoiceItemAvgAggregateInputType
    _sum?: CustomerInvoiceItemSumAggregateInputType
    _min?: CustomerInvoiceItemMinAggregateInputType
    _max?: CustomerInvoiceItemMaxAggregateInputType
  }

  export type CustomerInvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: Decimal
    unitPrice: Decimal
    total: Decimal
    createdAt: Date
    _count: CustomerInvoiceItemCountAggregateOutputType | null
    _avg: CustomerInvoiceItemAvgAggregateOutputType | null
    _sum: CustomerInvoiceItemSumAggregateOutputType | null
    _min: CustomerInvoiceItemMinAggregateOutputType | null
    _max: CustomerInvoiceItemMaxAggregateOutputType | null
  }

  type GetCustomerInvoiceItemGroupByPayload<T extends CustomerInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type CustomerInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    createdAt?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceItem"]>

  export type CustomerInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    createdAt?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceItem"]>

  export type CustomerInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    createdAt?: boolean
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoiceItem"]>

  export type CustomerInvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    createdAt?: boolean
  }

  export type CustomerInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "unitPrice" | "total" | "createdAt", ExtArgs["result"]["customerInvoiceItem"]>
  export type CustomerInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }
  export type CustomerInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }
  export type CustomerInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoiceDefaultArgs<ExtArgs>
  }

  export type $CustomerInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerInvoiceItem"
    objects: {
      invoice: Prisma.$CustomerInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      total: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["customerInvoiceItem"]>
    composites: {}
  }

  type CustomerInvoiceItemGetPayload<S extends boolean | null | undefined | CustomerInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$CustomerInvoiceItemPayload, S>

  type CustomerInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerInvoiceItemCountAggregateInputType | true
    }

  export interface CustomerInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerInvoiceItem'], meta: { name: 'CustomerInvoiceItem' } }
    /**
     * Find zero or one CustomerInvoiceItem that matches the filter.
     * @param {CustomerInvoiceItemFindUniqueArgs} args - Arguments to find a CustomerInvoiceItem
     * @example
     * // Get one CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerInvoiceItemFindUniqueArgs>(args: SelectSubset<T, CustomerInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a CustomerInvoiceItem
     * @example
     * // Get one CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemFindFirstArgs} args - Arguments to find a CustomerInvoiceItem
     * @example
     * // Get one CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerInvoiceItemFindFirstArgs>(args?: SelectSubset<T, CustomerInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a CustomerInvoiceItem
     * @example
     * // Get one CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerInvoiceItems
     * const customerInvoiceItems = await prisma.customerInvoiceItem.findMany()
     * 
     * // Get first 10 CustomerInvoiceItems
     * const customerInvoiceItems = await prisma.customerInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerInvoiceItemWithIdOnly = await prisma.customerInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerInvoiceItemFindManyArgs>(args?: SelectSubset<T, CustomerInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerInvoiceItem.
     * @param {CustomerInvoiceItemCreateArgs} args - Arguments to create a CustomerInvoiceItem.
     * @example
     * // Create one CustomerInvoiceItem
     * const CustomerInvoiceItem = await prisma.customerInvoiceItem.create({
     *   data: {
     *     // ... data to create a CustomerInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends CustomerInvoiceItemCreateArgs>(args: SelectSubset<T, CustomerInvoiceItemCreateArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerInvoiceItems.
     * @param {CustomerInvoiceItemCreateManyArgs} args - Arguments to create many CustomerInvoiceItems.
     * @example
     * // Create many CustomerInvoiceItems
     * const customerInvoiceItem = await prisma.customerInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerInvoiceItemCreateManyArgs>(args?: SelectSubset<T, CustomerInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerInvoiceItems and returns the data saved in the database.
     * @param {CustomerInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many CustomerInvoiceItems.
     * @example
     * // Create many CustomerInvoiceItems
     * const customerInvoiceItem = await prisma.customerInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerInvoiceItems and only return the `id`
     * const customerInvoiceItemWithIdOnly = await prisma.customerInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerInvoiceItem.
     * @param {CustomerInvoiceItemDeleteArgs} args - Arguments to delete one CustomerInvoiceItem.
     * @example
     * // Delete one CustomerInvoiceItem
     * const CustomerInvoiceItem = await prisma.customerInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one CustomerInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends CustomerInvoiceItemDeleteArgs>(args: SelectSubset<T, CustomerInvoiceItemDeleteArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerInvoiceItem.
     * @param {CustomerInvoiceItemUpdateArgs} args - Arguments to update one CustomerInvoiceItem.
     * @example
     * // Update one CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerInvoiceItemUpdateArgs>(args: SelectSubset<T, CustomerInvoiceItemUpdateArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerInvoiceItems.
     * @param {CustomerInvoiceItemDeleteManyArgs} args - Arguments to filter CustomerInvoiceItems to delete.
     * @example
     * // Delete a few CustomerInvoiceItems
     * const { count } = await prisma.customerInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, CustomerInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerInvoiceItems
     * const customerInvoiceItem = await prisma.customerInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerInvoiceItemUpdateManyArgs>(args: SelectSubset<T, CustomerInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoiceItems and returns the data updated in the database.
     * @param {CustomerInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many CustomerInvoiceItems.
     * @example
     * // Update many CustomerInvoiceItems
     * const customerInvoiceItem = await prisma.customerInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerInvoiceItems and only return the `id`
     * const customerInvoiceItemWithIdOnly = await prisma.customerInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerInvoiceItem.
     * @param {CustomerInvoiceItemUpsertArgs} args - Arguments to update or create a CustomerInvoiceItem.
     * @example
     * // Update or create a CustomerInvoiceItem
     * const customerInvoiceItem = await prisma.customerInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a CustomerInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends CustomerInvoiceItemUpsertArgs>(args: SelectSubset<T, CustomerInvoiceItemUpsertArgs<ExtArgs>>): Prisma__CustomerInvoiceItemClient<$Result.GetResult<Prisma.$CustomerInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemCountArgs} args - Arguments to filter CustomerInvoiceItems to count.
     * @example
     * // Count the number of CustomerInvoiceItems
     * const count = await prisma.customerInvoiceItem.count({
     *   where: {
     *     // ... the filter for the CustomerInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends CustomerInvoiceItemCountArgs>(
      args?: Subset<T, CustomerInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerInvoiceItemAggregateArgs>(args: Subset<T, CustomerInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetCustomerInvoiceItemAggregateType<T>>

    /**
     * Group by CustomerInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: CustomerInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerInvoiceItem model
   */
  readonly fields: CustomerInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends CustomerInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoiceDefaultArgs<ExtArgs>>): Prisma__CustomerInvoiceClient<$Result.GetResult<Prisma.$CustomerInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerInvoiceItem model
   */
  interface CustomerInvoiceItemFieldRefs {
    readonly id: FieldRef<"CustomerInvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"CustomerInvoiceItem", 'String'>
    readonly description: FieldRef<"CustomerInvoiceItem", 'String'>
    readonly quantity: FieldRef<"CustomerInvoiceItem", 'Decimal'>
    readonly unitPrice: FieldRef<"CustomerInvoiceItem", 'Decimal'>
    readonly total: FieldRef<"CustomerInvoiceItem", 'Decimal'>
    readonly createdAt: FieldRef<"CustomerInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerInvoiceItem findUnique
   */
  export type CustomerInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceItem to fetch.
     */
    where: CustomerInvoiceItemWhereUniqueInput
  }

  /**
   * CustomerInvoiceItem findUniqueOrThrow
   */
  export type CustomerInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceItem to fetch.
     */
    where: CustomerInvoiceItemWhereUniqueInput
  }

  /**
   * CustomerInvoiceItem findFirst
   */
  export type CustomerInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceItem to fetch.
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceItems to fetch.
     */
    orderBy?: CustomerInvoiceItemOrderByWithRelationInput | CustomerInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoiceItems.
     */
    cursor?: CustomerInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoiceItems.
     */
    distinct?: CustomerInvoiceItemScalarFieldEnum | CustomerInvoiceItemScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceItem findFirstOrThrow
   */
  export type CustomerInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceItem to fetch.
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceItems to fetch.
     */
    orderBy?: CustomerInvoiceItemOrderByWithRelationInput | CustomerInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoiceItems.
     */
    cursor?: CustomerInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoiceItems.
     */
    distinct?: CustomerInvoiceItemScalarFieldEnum | CustomerInvoiceItemScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceItem findMany
   */
  export type CustomerInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoiceItems to fetch.
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoiceItems to fetch.
     */
    orderBy?: CustomerInvoiceItemOrderByWithRelationInput | CustomerInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerInvoiceItems.
     */
    cursor?: CustomerInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoiceItems.
     */
    skip?: number
    distinct?: CustomerInvoiceItemScalarFieldEnum | CustomerInvoiceItemScalarFieldEnum[]
  }

  /**
   * CustomerInvoiceItem create
   */
  export type CustomerInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerInvoiceItem.
     */
    data: XOR<CustomerInvoiceItemCreateInput, CustomerInvoiceItemUncheckedCreateInput>
  }

  /**
   * CustomerInvoiceItem createMany
   */
  export type CustomerInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerInvoiceItems.
     */
    data: CustomerInvoiceItemCreateManyInput | CustomerInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerInvoiceItem createManyAndReturn
   */
  export type CustomerInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerInvoiceItems.
     */
    data: CustomerInvoiceItemCreateManyInput | CustomerInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoiceItem update
   */
  export type CustomerInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerInvoiceItem.
     */
    data: XOR<CustomerInvoiceItemUpdateInput, CustomerInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which CustomerInvoiceItem to update.
     */
    where: CustomerInvoiceItemWhereUniqueInput
  }

  /**
   * CustomerInvoiceItem updateMany
   */
  export type CustomerInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerInvoiceItems.
     */
    data: XOR<CustomerInvoiceItemUpdateManyMutationInput, CustomerInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoiceItems to update
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * Limit how many CustomerInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * CustomerInvoiceItem updateManyAndReturn
   */
  export type CustomerInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update CustomerInvoiceItems.
     */
    data: XOR<CustomerInvoiceItemUpdateManyMutationInput, CustomerInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoiceItems to update
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * Limit how many CustomerInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerInvoiceItem upsert
   */
  export type CustomerInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerInvoiceItem to update in case it exists.
     */
    where: CustomerInvoiceItemWhereUniqueInput
    /**
     * In case the CustomerInvoiceItem found by the `where` argument doesn't exist, create a new CustomerInvoiceItem with this data.
     */
    create: XOR<CustomerInvoiceItemCreateInput, CustomerInvoiceItemUncheckedCreateInput>
    /**
     * In case the CustomerInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerInvoiceItemUpdateInput, CustomerInvoiceItemUncheckedUpdateInput>
  }

  /**
   * CustomerInvoiceItem delete
   */
  export type CustomerInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which CustomerInvoiceItem to delete.
     */
    where: CustomerInvoiceItemWhereUniqueInput
  }

  /**
   * CustomerInvoiceItem deleteMany
   */
  export type CustomerInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoiceItems to delete
     */
    where?: CustomerInvoiceItemWhereInput
    /**
     * Limit how many CustomerInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * CustomerInvoiceItem without action
   */
  export type CustomerInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoiceItem
     */
    select?: CustomerInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerInvoiceItem
     */
    omit?: CustomerInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
    fileSizeBytes: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: bigint | null
    fileSizeBytes: bigint | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    filename: string | null
    url: string | null
    type: $Enums.DocumentType | null
    mimeType: string | null
    size: bigint | null
    propertyId: string | null
    leaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileSizeBytes: bigint | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    filename: string | null
    url: string | null
    type: $Enums.DocumentType | null
    mimeType: string | null
    size: bigint | null
    propertyId: string | null
    leaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileSizeBytes: bigint | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    filename: number
    url: number
    type: number
    mimeType: number
    size: number
    propertyId: number
    leaseId: number
    createdAt: number
    updatedAt: number
    fileSizeBytes: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
    fileSizeBytes?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
    fileSizeBytes?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    filename?: true
    url?: true
    type?: true
    mimeType?: true
    size?: true
    propertyId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
    fileSizeBytes?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    filename?: true
    url?: true
    type?: true
    mimeType?: true
    size?: true
    propertyId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
    fileSizeBytes?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    filename?: true
    url?: true
    type?: true
    mimeType?: true
    size?: true
    propertyId?: true
    leaseId?: true
    createdAt?: true
    updatedAt?: true
    fileSizeBytes?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    filename: string | null
    url: string
    type: $Enums.DocumentType
    mimeType: string | null
    size: bigint | null
    propertyId: string | null
    leaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileSizeBytes: bigint
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    filename?: boolean
    url?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    propertyId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileSizeBytes?: boolean
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    filename?: boolean
    url?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    propertyId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileSizeBytes?: boolean
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    filename?: boolean
    url?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    propertyId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileSizeBytes?: boolean
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    filename?: boolean
    url?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    propertyId?: boolean
    leaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileSizeBytes?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "filename" | "url" | "type" | "mimeType" | "size" | "propertyId" | "leaseId" | "createdAt" | "updatedAt" | "fileSizeBytes", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | Document$LeaseArgs<ExtArgs>
    Property?: boolean | Document$PropertyArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      Lease: Prisma.$LeasePayload<ExtArgs> | null
      Property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      filename: string | null
      url: string
      type: $Enums.DocumentType
      mimeType: string | null
      size: bigint | null
      propertyId: string | null
      leaseId: string | null
      createdAt: Date | null
      updatedAt: Date | null
      fileSizeBytes: bigint
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lease<T extends Document$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, Document$LeaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Property<T extends Document$PropertyArgs<ExtArgs> = {}>(args?: Subset<T, Document$PropertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'BigInt'>
    readonly propertyId: FieldRef<"Document", 'String'>
    readonly leaseId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly fileSizeBytes: FieldRef<"Document", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.Lease
   */
  export type Document$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * Document.Property
   */
  export type Document$PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    maintenanceId: string | null
    amount: number | null
    category: string | null
    description: string | null
    date: Date | null
    receiptUrl: string | null
    vendorName: string | null
    vendorContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    maintenanceId: string | null
    amount: number | null
    category: string | null
    description: string | null
    date: Date | null
    receiptUrl: string | null
    vendorName: string | null
    vendorContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    propertyId: number
    maintenanceId: number
    amount: number
    category: number
    description: number
    date: number
    receiptUrl: number
    vendorName: number
    vendorContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    propertyId?: true
    maintenanceId?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    receiptUrl?: true
    vendorName?: true
    vendorContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    propertyId?: true
    maintenanceId?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    receiptUrl?: true
    vendorName?: true
    vendorContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    propertyId?: true
    maintenanceId?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    receiptUrl?: true
    vendorName?: true
    vendorContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    propertyId: string
    maintenanceId: string | null
    amount: number
    category: string
    description: string
    date: Date
    receiptUrl: string | null
    vendorName: string | null
    vendorContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    maintenanceId?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    receiptUrl?: boolean
    vendorName?: boolean
    vendorContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    maintenanceId?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    receiptUrl?: boolean
    vendorName?: boolean
    vendorContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    maintenanceId?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    receiptUrl?: boolean
    vendorName?: boolean
    vendorContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    propertyId?: boolean
    maintenanceId?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    receiptUrl?: boolean
    vendorName?: boolean
    vendorContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "maintenanceId" | "amount" | "category" | "description" | "date" | "receiptUrl" | "vendorName" | "vendorContact" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaintenanceRequest?: boolean | Expense$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      MaintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs> | null
      Property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      maintenanceId: string | null
      amount: number
      category: string
      description: string
      date: Date
      receiptUrl: string | null
      vendorName: string | null
      vendorContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaintenanceRequest<T extends Expense$MaintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, Expense$MaintenanceRequestArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly propertyId: FieldRef<"Expense", 'String'>
    readonly maintenanceId: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly vendorName: FieldRef<"Expense", 'String'>
    readonly vendorContact: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.MaintenanceRequest
   */
  export type Expense$MaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Inspection
   */

  export type AggregateInspection = {
    _count: InspectionCountAggregateOutputType | null
    _min: InspectionMinAggregateOutputType | null
    _max: InspectionMaxAggregateOutputType | null
  }

  export type InspectionMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    unitId: string | null
    inspectorId: string | null
    type: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    status: string | null
    notes: string | null
    reportUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    unitId: string | null
    inspectorId: string | null
    type: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    status: string | null
    notes: string | null
    reportUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionCountAggregateOutputType = {
    id: number
    propertyId: number
    unitId: number
    inspectorId: number
    type: number
    scheduledDate: number
    completedDate: number
    status: number
    notes: number
    reportUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InspectionMinAggregateInputType = {
    id?: true
    propertyId?: true
    unitId?: true
    inspectorId?: true
    type?: true
    scheduledDate?: true
    completedDate?: true
    status?: true
    notes?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionMaxAggregateInputType = {
    id?: true
    propertyId?: true
    unitId?: true
    inspectorId?: true
    type?: true
    scheduledDate?: true
    completedDate?: true
    status?: true
    notes?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionCountAggregateInputType = {
    id?: true
    propertyId?: true
    unitId?: true
    inspectorId?: true
    type?: true
    scheduledDate?: true
    completedDate?: true
    status?: true
    notes?: true
    reportUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InspectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspection to aggregate.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inspections
    **/
    _count?: true | InspectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionMaxAggregateInputType
  }

  export type GetInspectionAggregateType<T extends InspectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInspection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspection[P]>
      : GetScalarType<T[P], AggregateInspection[P]>
  }




  export type InspectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithAggregationInput | InspectionOrderByWithAggregationInput[]
    by: InspectionScalarFieldEnum[] | InspectionScalarFieldEnum
    having?: InspectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionCountAggregateInputType | true
    _min?: InspectionMinAggregateInputType
    _max?: InspectionMaxAggregateInputType
  }

  export type InspectionGroupByOutputType = {
    id: string
    propertyId: string
    unitId: string | null
    inspectorId: string
    type: string
    scheduledDate: Date
    completedDate: Date | null
    status: string
    notes: string | null
    reportUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: InspectionCountAggregateOutputType | null
    _min: InspectionMinAggregateOutputType | null
    _max: InspectionMaxAggregateOutputType | null
  }

  type GetInspectionGroupByPayload<T extends InspectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionGroupByOutputType[P]>
        }
      >
    >


  export type InspectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    unitId?: boolean
    inspectorId?: boolean
    type?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    status?: boolean
    notes?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    unitId?: boolean
    inspectorId?: boolean
    type?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    status?: boolean
    notes?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    unitId?: boolean
    inspectorId?: boolean
    type?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    status?: boolean
    notes?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectScalar = {
    id?: boolean
    propertyId?: boolean
    unitId?: boolean
    inspectorId?: boolean
    type?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    status?: boolean
    notes?: boolean
    reportUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InspectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "unitId" | "inspectorId" | "type" | "scheduledDate" | "completedDate" | "status" | "notes" | "reportUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["inspection"]>
  export type InspectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }
  export type InspectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }
  export type InspectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    Unit?: boolean | Inspection$UnitArgs<ExtArgs>
  }

  export type $InspectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inspection"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Property: Prisma.$PropertyPayload<ExtArgs>
      Unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      unitId: string | null
      inspectorId: string
      type: string
      scheduledDate: Date
      completedDate: Date | null
      status: string
      notes: string | null
      reportUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inspection"]>
    composites: {}
  }

  type InspectionGetPayload<S extends boolean | null | undefined | InspectionDefaultArgs> = $Result.GetResult<Prisma.$InspectionPayload, S>

  type InspectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InspectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InspectionCountAggregateInputType | true
    }

  export interface InspectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inspection'], meta: { name: 'Inspection' } }
    /**
     * Find zero or one Inspection that matches the filter.
     * @param {InspectionFindUniqueArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionFindUniqueArgs>(args: SelectSubset<T, InspectionFindUniqueArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inspection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InspectionFindUniqueOrThrowArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inspection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindFirstArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionFindFirstArgs>(args?: SelectSubset<T, InspectionFindFirstArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inspection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindFirstOrThrowArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inspections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inspections
     * const inspections = await prisma.inspection.findMany()
     * 
     * // Get first 10 Inspections
     * const inspections = await prisma.inspection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionWithIdOnly = await prisma.inspection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionFindManyArgs>(args?: SelectSubset<T, InspectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inspection.
     * @param {InspectionCreateArgs} args - Arguments to create a Inspection.
     * @example
     * // Create one Inspection
     * const Inspection = await prisma.inspection.create({
     *   data: {
     *     // ... data to create a Inspection
     *   }
     * })
     * 
     */
    create<T extends InspectionCreateArgs>(args: SelectSubset<T, InspectionCreateArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inspections.
     * @param {InspectionCreateManyArgs} args - Arguments to create many Inspections.
     * @example
     * // Create many Inspections
     * const inspection = await prisma.inspection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionCreateManyArgs>(args?: SelectSubset<T, InspectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inspections and returns the data saved in the database.
     * @param {InspectionCreateManyAndReturnArgs} args - Arguments to create many Inspections.
     * @example
     * // Create many Inspections
     * const inspection = await prisma.inspection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inspections and only return the `id`
     * const inspectionWithIdOnly = await prisma.inspection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inspection.
     * @param {InspectionDeleteArgs} args - Arguments to delete one Inspection.
     * @example
     * // Delete one Inspection
     * const Inspection = await prisma.inspection.delete({
     *   where: {
     *     // ... filter to delete one Inspection
     *   }
     * })
     * 
     */
    delete<T extends InspectionDeleteArgs>(args: SelectSubset<T, InspectionDeleteArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inspection.
     * @param {InspectionUpdateArgs} args - Arguments to update one Inspection.
     * @example
     * // Update one Inspection
     * const inspection = await prisma.inspection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionUpdateArgs>(args: SelectSubset<T, InspectionUpdateArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inspections.
     * @param {InspectionDeleteManyArgs} args - Arguments to filter Inspections to delete.
     * @example
     * // Delete a few Inspections
     * const { count } = await prisma.inspection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionDeleteManyArgs>(args?: SelectSubset<T, InspectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inspections
     * const inspection = await prisma.inspection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionUpdateManyArgs>(args: SelectSubset<T, InspectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inspections and returns the data updated in the database.
     * @param {InspectionUpdateManyAndReturnArgs} args - Arguments to update many Inspections.
     * @example
     * // Update many Inspections
     * const inspection = await prisma.inspection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inspections and only return the `id`
     * const inspectionWithIdOnly = await prisma.inspection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InspectionUpdateManyAndReturnArgs>(args: SelectSubset<T, InspectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inspection.
     * @param {InspectionUpsertArgs} args - Arguments to update or create a Inspection.
     * @example
     * // Update or create a Inspection
     * const inspection = await prisma.inspection.upsert({
     *   create: {
     *     // ... data to create a Inspection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inspection we want to update
     *   }
     * })
     */
    upsert<T extends InspectionUpsertArgs>(args: SelectSubset<T, InspectionUpsertArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionCountArgs} args - Arguments to filter Inspections to count.
     * @example
     * // Count the number of Inspections
     * const count = await prisma.inspection.count({
     *   where: {
     *     // ... the filter for the Inspections we want to count
     *   }
     * })
    **/
    count<T extends InspectionCountArgs>(
      args?: Subset<T, InspectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionAggregateArgs>(args: Subset<T, InspectionAggregateArgs>): Prisma.PrismaPromise<GetInspectionAggregateType<T>>

    /**
     * Group by Inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionGroupByArgs['orderBy'] }
        : { orderBy?: InspectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inspection model
   */
  readonly fields: InspectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inspection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Unit<T extends Inspection$UnitArgs<ExtArgs> = {}>(args?: Subset<T, Inspection$UnitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inspection model
   */
  interface InspectionFieldRefs {
    readonly id: FieldRef<"Inspection", 'String'>
    readonly propertyId: FieldRef<"Inspection", 'String'>
    readonly unitId: FieldRef<"Inspection", 'String'>
    readonly inspectorId: FieldRef<"Inspection", 'String'>
    readonly type: FieldRef<"Inspection", 'String'>
    readonly scheduledDate: FieldRef<"Inspection", 'DateTime'>
    readonly completedDate: FieldRef<"Inspection", 'DateTime'>
    readonly status: FieldRef<"Inspection", 'String'>
    readonly notes: FieldRef<"Inspection", 'String'>
    readonly reportUrl: FieldRef<"Inspection", 'String'>
    readonly createdAt: FieldRef<"Inspection", 'DateTime'>
    readonly updatedAt: FieldRef<"Inspection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inspection findUnique
   */
  export type InspectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection findUniqueOrThrow
   */
  export type InspectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection findFirst
   */
  export type InspectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspections.
     */
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection findFirstOrThrow
   */
  export type InspectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspections.
     */
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection findMany
   */
  export type InspectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspections to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection create
   */
  export type InspectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Inspection.
     */
    data: XOR<InspectionCreateInput, InspectionUncheckedCreateInput>
  }

  /**
   * Inspection createMany
   */
  export type InspectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inspections.
     */
    data: InspectionCreateManyInput | InspectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inspection createManyAndReturn
   */
  export type InspectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * The data used to create many Inspections.
     */
    data: InspectionCreateManyInput | InspectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inspection update
   */
  export type InspectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Inspection.
     */
    data: XOR<InspectionUpdateInput, InspectionUncheckedUpdateInput>
    /**
     * Choose, which Inspection to update.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection updateMany
   */
  export type InspectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inspections.
     */
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyInput>
    /**
     * Filter which Inspections to update
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to update.
     */
    limit?: number
  }

  /**
   * Inspection updateManyAndReturn
   */
  export type InspectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * The data used to update Inspections.
     */
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyInput>
    /**
     * Filter which Inspections to update
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inspection upsert
   */
  export type InspectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Inspection to update in case it exists.
     */
    where: InspectionWhereUniqueInput
    /**
     * In case the Inspection found by the `where` argument doesn't exist, create a new Inspection with this data.
     */
    create: XOR<InspectionCreateInput, InspectionUncheckedCreateInput>
    /**
     * In case the Inspection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionUpdateInput, InspectionUncheckedUpdateInput>
  }

  /**
   * Inspection delete
   */
  export type InspectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter which Inspection to delete.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection deleteMany
   */
  export type InspectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspections to delete
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to delete.
     */
    limit?: number
  }

  /**
   * Inspection.Unit
   */
  export type Inspection$UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Inspection without action
   */
  export type InspectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amountPaid: number | null
    amountDue: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amountPaid: number | null
    amountDue: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amountPaid: number | null
    amountDue: number | null
    currency: string | null
    status: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    invoiceUrl: string | null
    invoicePdf: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amountPaid: number | null
    amountDue: number | null
    currency: string | null
    status: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    invoiceUrl: string | null
    invoicePdf: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    stripeInvoiceId: number
    amountPaid: number
    amountDue: number
    currency: number
    status: number
    invoiceDate: number
    dueDate: number
    paidAt: number
    invoiceUrl: number
    invoicePdf: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amountPaid?: true
    amountDue?: true
  }

  export type InvoiceSumAggregateInputType = {
    amountPaid?: true
    amountDue?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amountPaid?: true
    amountDue?: true
    currency?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    invoiceUrl?: true
    invoicePdf?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amountPaid?: true
    amountDue?: true
    currency?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    invoiceUrl?: true
    invoicePdf?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amountPaid?: true
    amountDue?: true
    currency?: true
    status?: true
    invoiceDate?: true
    dueDate?: true
    paidAt?: true
    invoiceUrl?: true
    invoicePdf?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    userId: string
    subscriptionId: string | null
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency: string
    status: string
    invoiceDate: Date
    dueDate: Date | null
    paidAt: Date | null
    invoiceUrl: string | null
    invoicePdf: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amountPaid?: boolean
    amountDue?: boolean
    currency?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    invoicePdf?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amountPaid?: boolean
    amountDue?: boolean
    currency?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    invoicePdf?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amountPaid?: boolean
    amountDue?: boolean
    currency?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    invoicePdf?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amountPaid?: boolean
    amountDue?: boolean
    currency?: boolean
    status?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    invoiceUrl?: boolean
    invoicePdf?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subscriptionId" | "stripeInvoiceId" | "amountPaid" | "amountDue" | "currency" | "status" | "invoiceDate" | "dueDate" | "paidAt" | "invoiceUrl" | "invoicePdf" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | Invoice$SubscriptionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      Subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subscriptionId: string | null
      stripeInvoiceId: string
      amountPaid: number
      amountDue: number
      currency: string
      status: string
      invoiceDate: Date
      dueDate: Date | null
      paidAt: Date | null
      invoiceUrl: string | null
      invoicePdf: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Subscription<T extends Invoice$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$SubscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly subscriptionId: FieldRef<"Invoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly amountPaid: FieldRef<"Invoice", 'Int'>
    readonly amountDue: FieldRef<"Invoice", 'Int'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly invoiceUrl: FieldRef<"Invoice", 'String'>
    readonly invoicePdf: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.Subscription
   */
  export type Invoice$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLeadCapture
   */

  export type AggregateInvoiceLeadCapture = {
    _count: InvoiceLeadCaptureCountAggregateOutputType | null
    _min: InvoiceLeadCaptureMinAggregateOutputType | null
    _max: InvoiceLeadCaptureMaxAggregateOutputType | null
  }

  export type InvoiceLeadCaptureMinAggregateOutputType = {
    id: string | null
    email: string | null
    invoiceId: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    source: string | null
    medium: string | null
    campaign: string | null
    emailSent: boolean | null
    emailOpened: boolean | null
    linkClicked: boolean | null
    converted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLeadCaptureMaxAggregateOutputType = {
    id: string | null
    email: string | null
    invoiceId: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    source: string | null
    medium: string | null
    campaign: string | null
    emailSent: boolean | null
    emailOpened: boolean | null
    linkClicked: boolean | null
    converted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLeadCaptureCountAggregateOutputType = {
    id: number
    email: number
    invoiceId: number
    firstName: number
    lastName: number
    company: number
    source: number
    medium: number
    campaign: number
    emailSent: number
    emailOpened: number
    linkClicked: number
    converted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceLeadCaptureMinAggregateInputType = {
    id?: true
    email?: true
    invoiceId?: true
    firstName?: true
    lastName?: true
    company?: true
    source?: true
    medium?: true
    campaign?: true
    emailSent?: true
    emailOpened?: true
    linkClicked?: true
    converted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLeadCaptureMaxAggregateInputType = {
    id?: true
    email?: true
    invoiceId?: true
    firstName?: true
    lastName?: true
    company?: true
    source?: true
    medium?: true
    campaign?: true
    emailSent?: true
    emailOpened?: true
    linkClicked?: true
    converted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLeadCaptureCountAggregateInputType = {
    id?: true
    email?: true
    invoiceId?: true
    firstName?: true
    lastName?: true
    company?: true
    source?: true
    medium?: true
    campaign?: true
    emailSent?: true
    emailOpened?: true
    linkClicked?: true
    converted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceLeadCaptureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLeadCapture to aggregate.
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLeadCaptures to fetch.
     */
    orderBy?: InvoiceLeadCaptureOrderByWithRelationInput | InvoiceLeadCaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLeadCaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLeadCaptures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLeadCaptures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLeadCaptures
    **/
    _count?: true | InvoiceLeadCaptureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLeadCaptureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLeadCaptureMaxAggregateInputType
  }

  export type GetInvoiceLeadCaptureAggregateType<T extends InvoiceLeadCaptureAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLeadCapture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLeadCapture[P]>
      : GetScalarType<T[P], AggregateInvoiceLeadCapture[P]>
  }




  export type InvoiceLeadCaptureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLeadCaptureWhereInput
    orderBy?: InvoiceLeadCaptureOrderByWithAggregationInput | InvoiceLeadCaptureOrderByWithAggregationInput[]
    by: InvoiceLeadCaptureScalarFieldEnum[] | InvoiceLeadCaptureScalarFieldEnum
    having?: InvoiceLeadCaptureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLeadCaptureCountAggregateInputType | true
    _min?: InvoiceLeadCaptureMinAggregateInputType
    _max?: InvoiceLeadCaptureMaxAggregateInputType
  }

  export type InvoiceLeadCaptureGroupByOutputType = {
    id: string
    email: string
    invoiceId: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    source: string | null
    medium: string | null
    campaign: string | null
    emailSent: boolean
    emailOpened: boolean
    linkClicked: boolean
    converted: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvoiceLeadCaptureCountAggregateOutputType | null
    _min: InvoiceLeadCaptureMinAggregateOutputType | null
    _max: InvoiceLeadCaptureMaxAggregateOutputType | null
  }

  type GetInvoiceLeadCaptureGroupByPayload<T extends InvoiceLeadCaptureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLeadCaptureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLeadCaptureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLeadCaptureGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLeadCaptureGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLeadCaptureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    invoiceId?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoiceLeadCapture"]>

  export type InvoiceLeadCaptureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    invoiceId?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoiceLeadCapture"]>

  export type InvoiceLeadCaptureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    invoiceId?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoiceLeadCapture"]>

  export type InvoiceLeadCaptureSelectScalar = {
    id?: boolean
    email?: boolean
    invoiceId?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceLeadCaptureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "invoiceId" | "firstName" | "lastName" | "company" | "source" | "medium" | "campaign" | "emailSent" | "emailOpened" | "linkClicked" | "converted" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceLeadCapture"]>

  export type $InvoiceLeadCapturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLeadCapture"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      invoiceId: string | null
      firstName: string | null
      lastName: string | null
      company: string | null
      source: string | null
      medium: string | null
      campaign: string | null
      emailSent: boolean
      emailOpened: boolean
      linkClicked: boolean
      converted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceLeadCapture"]>
    composites: {}
  }

  type InvoiceLeadCaptureGetPayload<S extends boolean | null | undefined | InvoiceLeadCaptureDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLeadCapturePayload, S>

  type InvoiceLeadCaptureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLeadCaptureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLeadCaptureCountAggregateInputType | true
    }

  export interface InvoiceLeadCaptureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLeadCapture'], meta: { name: 'InvoiceLeadCapture' } }
    /**
     * Find zero or one InvoiceLeadCapture that matches the filter.
     * @param {InvoiceLeadCaptureFindUniqueArgs} args - Arguments to find a InvoiceLeadCapture
     * @example
     * // Get one InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLeadCaptureFindUniqueArgs>(args: SelectSubset<T, InvoiceLeadCaptureFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLeadCapture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLeadCaptureFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLeadCapture
     * @example
     * // Get one InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLeadCaptureFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLeadCaptureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLeadCapture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureFindFirstArgs} args - Arguments to find a InvoiceLeadCapture
     * @example
     * // Get one InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLeadCaptureFindFirstArgs>(args?: SelectSubset<T, InvoiceLeadCaptureFindFirstArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLeadCapture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureFindFirstOrThrowArgs} args - Arguments to find a InvoiceLeadCapture
     * @example
     * // Get one InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLeadCaptureFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLeadCaptureFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLeadCaptures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLeadCaptures
     * const invoiceLeadCaptures = await prisma.invoiceLeadCapture.findMany()
     * 
     * // Get first 10 InvoiceLeadCaptures
     * const invoiceLeadCaptures = await prisma.invoiceLeadCapture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLeadCaptureWithIdOnly = await prisma.invoiceLeadCapture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLeadCaptureFindManyArgs>(args?: SelectSubset<T, InvoiceLeadCaptureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLeadCapture.
     * @param {InvoiceLeadCaptureCreateArgs} args - Arguments to create a InvoiceLeadCapture.
     * @example
     * // Create one InvoiceLeadCapture
     * const InvoiceLeadCapture = await prisma.invoiceLeadCapture.create({
     *   data: {
     *     // ... data to create a InvoiceLeadCapture
     *   }
     * })
     * 
     */
    create<T extends InvoiceLeadCaptureCreateArgs>(args: SelectSubset<T, InvoiceLeadCaptureCreateArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLeadCaptures.
     * @param {InvoiceLeadCaptureCreateManyArgs} args - Arguments to create many InvoiceLeadCaptures.
     * @example
     * // Create many InvoiceLeadCaptures
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLeadCaptureCreateManyArgs>(args?: SelectSubset<T, InvoiceLeadCaptureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLeadCaptures and returns the data saved in the database.
     * @param {InvoiceLeadCaptureCreateManyAndReturnArgs} args - Arguments to create many InvoiceLeadCaptures.
     * @example
     * // Create many InvoiceLeadCaptures
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLeadCaptures and only return the `id`
     * const invoiceLeadCaptureWithIdOnly = await prisma.invoiceLeadCapture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLeadCaptureCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLeadCaptureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceLeadCapture.
     * @param {InvoiceLeadCaptureDeleteArgs} args - Arguments to delete one InvoiceLeadCapture.
     * @example
     * // Delete one InvoiceLeadCapture
     * const InvoiceLeadCapture = await prisma.invoiceLeadCapture.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLeadCapture
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLeadCaptureDeleteArgs>(args: SelectSubset<T, InvoiceLeadCaptureDeleteArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLeadCapture.
     * @param {InvoiceLeadCaptureUpdateArgs} args - Arguments to update one InvoiceLeadCapture.
     * @example
     * // Update one InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLeadCaptureUpdateArgs>(args: SelectSubset<T, InvoiceLeadCaptureUpdateArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLeadCaptures.
     * @param {InvoiceLeadCaptureDeleteManyArgs} args - Arguments to filter InvoiceLeadCaptures to delete.
     * @example
     * // Delete a few InvoiceLeadCaptures
     * const { count } = await prisma.invoiceLeadCapture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLeadCaptureDeleteManyArgs>(args?: SelectSubset<T, InvoiceLeadCaptureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLeadCaptures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLeadCaptures
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLeadCaptureUpdateManyArgs>(args: SelectSubset<T, InvoiceLeadCaptureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLeadCaptures and returns the data updated in the database.
     * @param {InvoiceLeadCaptureUpdateManyAndReturnArgs} args - Arguments to update many InvoiceLeadCaptures.
     * @example
     * // Update many InvoiceLeadCaptures
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceLeadCaptures and only return the `id`
     * const invoiceLeadCaptureWithIdOnly = await prisma.invoiceLeadCapture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceLeadCaptureUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceLeadCaptureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceLeadCapture.
     * @param {InvoiceLeadCaptureUpsertArgs} args - Arguments to update or create a InvoiceLeadCapture.
     * @example
     * // Update or create a InvoiceLeadCapture
     * const invoiceLeadCapture = await prisma.invoiceLeadCapture.upsert({
     *   create: {
     *     // ... data to create a InvoiceLeadCapture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLeadCapture we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLeadCaptureUpsertArgs>(args: SelectSubset<T, InvoiceLeadCaptureUpsertArgs<ExtArgs>>): Prisma__InvoiceLeadCaptureClient<$Result.GetResult<Prisma.$InvoiceLeadCapturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLeadCaptures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureCountArgs} args - Arguments to filter InvoiceLeadCaptures to count.
     * @example
     * // Count the number of InvoiceLeadCaptures
     * const count = await prisma.invoiceLeadCapture.count({
     *   where: {
     *     // ... the filter for the InvoiceLeadCaptures we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLeadCaptureCountArgs>(
      args?: Subset<T, InvoiceLeadCaptureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLeadCaptureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLeadCapture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLeadCaptureAggregateArgs>(args: Subset<T, InvoiceLeadCaptureAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLeadCaptureAggregateType<T>>

    /**
     * Group by InvoiceLeadCapture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLeadCaptureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLeadCaptureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLeadCaptureGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLeadCaptureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLeadCaptureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLeadCaptureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLeadCapture model
   */
  readonly fields: InvoiceLeadCaptureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLeadCapture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLeadCaptureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLeadCapture model
   */
  interface InvoiceLeadCaptureFieldRefs {
    readonly id: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly email: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly firstName: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly lastName: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly company: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly source: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly medium: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly campaign: FieldRef<"InvoiceLeadCapture", 'String'>
    readonly emailSent: FieldRef<"InvoiceLeadCapture", 'Boolean'>
    readonly emailOpened: FieldRef<"InvoiceLeadCapture", 'Boolean'>
    readonly linkClicked: FieldRef<"InvoiceLeadCapture", 'Boolean'>
    readonly converted: FieldRef<"InvoiceLeadCapture", 'Boolean'>
    readonly createdAt: FieldRef<"InvoiceLeadCapture", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceLeadCapture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLeadCapture findUnique
   */
  export type InvoiceLeadCaptureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter, which InvoiceLeadCapture to fetch.
     */
    where: InvoiceLeadCaptureWhereUniqueInput
  }

  /**
   * InvoiceLeadCapture findUniqueOrThrow
   */
  export type InvoiceLeadCaptureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter, which InvoiceLeadCapture to fetch.
     */
    where: InvoiceLeadCaptureWhereUniqueInput
  }

  /**
   * InvoiceLeadCapture findFirst
   */
  export type InvoiceLeadCaptureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter, which InvoiceLeadCapture to fetch.
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLeadCaptures to fetch.
     */
    orderBy?: InvoiceLeadCaptureOrderByWithRelationInput | InvoiceLeadCaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLeadCaptures.
     */
    cursor?: InvoiceLeadCaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLeadCaptures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLeadCaptures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLeadCaptures.
     */
    distinct?: InvoiceLeadCaptureScalarFieldEnum | InvoiceLeadCaptureScalarFieldEnum[]
  }

  /**
   * InvoiceLeadCapture findFirstOrThrow
   */
  export type InvoiceLeadCaptureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter, which InvoiceLeadCapture to fetch.
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLeadCaptures to fetch.
     */
    orderBy?: InvoiceLeadCaptureOrderByWithRelationInput | InvoiceLeadCaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLeadCaptures.
     */
    cursor?: InvoiceLeadCaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLeadCaptures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLeadCaptures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLeadCaptures.
     */
    distinct?: InvoiceLeadCaptureScalarFieldEnum | InvoiceLeadCaptureScalarFieldEnum[]
  }

  /**
   * InvoiceLeadCapture findMany
   */
  export type InvoiceLeadCaptureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter, which InvoiceLeadCaptures to fetch.
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLeadCaptures to fetch.
     */
    orderBy?: InvoiceLeadCaptureOrderByWithRelationInput | InvoiceLeadCaptureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLeadCaptures.
     */
    cursor?: InvoiceLeadCaptureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLeadCaptures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLeadCaptures.
     */
    skip?: number
    distinct?: InvoiceLeadCaptureScalarFieldEnum | InvoiceLeadCaptureScalarFieldEnum[]
  }

  /**
   * InvoiceLeadCapture create
   */
  export type InvoiceLeadCaptureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLeadCapture.
     */
    data: XOR<InvoiceLeadCaptureCreateInput, InvoiceLeadCaptureUncheckedCreateInput>
  }

  /**
   * InvoiceLeadCapture createMany
   */
  export type InvoiceLeadCaptureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLeadCaptures.
     */
    data: InvoiceLeadCaptureCreateManyInput | InvoiceLeadCaptureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLeadCapture createManyAndReturn
   */
  export type InvoiceLeadCaptureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceLeadCaptures.
     */
    data: InvoiceLeadCaptureCreateManyInput | InvoiceLeadCaptureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLeadCapture update
   */
  export type InvoiceLeadCaptureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLeadCapture.
     */
    data: XOR<InvoiceLeadCaptureUpdateInput, InvoiceLeadCaptureUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLeadCapture to update.
     */
    where: InvoiceLeadCaptureWhereUniqueInput
  }

  /**
   * InvoiceLeadCapture updateMany
   */
  export type InvoiceLeadCaptureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLeadCaptures.
     */
    data: XOR<InvoiceLeadCaptureUpdateManyMutationInput, InvoiceLeadCaptureUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLeadCaptures to update
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * Limit how many InvoiceLeadCaptures to update.
     */
    limit?: number
  }

  /**
   * InvoiceLeadCapture updateManyAndReturn
   */
  export type InvoiceLeadCaptureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceLeadCaptures.
     */
    data: XOR<InvoiceLeadCaptureUpdateManyMutationInput, InvoiceLeadCaptureUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLeadCaptures to update
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * Limit how many InvoiceLeadCaptures to update.
     */
    limit?: number
  }

  /**
   * InvoiceLeadCapture upsert
   */
  export type InvoiceLeadCaptureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLeadCapture to update in case it exists.
     */
    where: InvoiceLeadCaptureWhereUniqueInput
    /**
     * In case the InvoiceLeadCapture found by the `where` argument doesn't exist, create a new InvoiceLeadCapture with this data.
     */
    create: XOR<InvoiceLeadCaptureCreateInput, InvoiceLeadCaptureUncheckedCreateInput>
    /**
     * In case the InvoiceLeadCapture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLeadCaptureUpdateInput, InvoiceLeadCaptureUncheckedUpdateInput>
  }

  /**
   * InvoiceLeadCapture delete
   */
  export type InvoiceLeadCaptureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
    /**
     * Filter which InvoiceLeadCapture to delete.
     */
    where: InvoiceLeadCaptureWhereUniqueInput
  }

  /**
   * InvoiceLeadCapture deleteMany
   */
  export type InvoiceLeadCaptureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLeadCaptures to delete
     */
    where?: InvoiceLeadCaptureWhereInput
    /**
     * Limit how many InvoiceLeadCaptures to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLeadCapture without action
   */
  export type InvoiceLeadCaptureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLeadCapture
     */
    select?: InvoiceLeadCaptureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLeadCapture
     */
    omit?: InvoiceLeadCaptureOmit<ExtArgs> | null
  }


  /**
   * Model Lease
   */

  export type AggregateLease = {
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  export type LeaseAvgAggregateOutputType = {
    rentAmount: number | null
    securityDeposit: number | null
  }

  export type LeaseSumAggregateOutputType = {
    rentAmount: number | null
    securityDeposit: number | null
  }

  export type LeaseMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rentAmount: number | null
    securityDeposit: number | null
    terms: string | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    tenantId: string | null
    startDate: Date | null
    endDate: Date | null
    rentAmount: number | null
    securityDeposit: number | null
    terms: string | null
    status: $Enums.LeaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseCountAggregateOutputType = {
    id: number
    unitId: number
    tenantId: number
    startDate: number
    endDate: number
    rentAmount: number
    securityDeposit: number
    terms: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaseAvgAggregateInputType = {
    rentAmount?: true
    securityDeposit?: true
  }

  export type LeaseSumAggregateInputType = {
    rentAmount?: true
    securityDeposit?: true
  }

  export type LeaseMinAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    securityDeposit?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseMaxAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    securityDeposit?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseCountAggregateInputType = {
    id?: true
    unitId?: true
    tenantId?: true
    startDate?: true
    endDate?: true
    rentAmount?: true
    securityDeposit?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lease to aggregate.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leases
    **/
    _count?: true | LeaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseMaxAggregateInputType
  }

  export type GetLeaseAggregateType<T extends LeaseAggregateArgs> = {
        [P in keyof T & keyof AggregateLease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLease[P]>
      : GetScalarType<T[P], AggregateLease[P]>
  }




  export type LeaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithAggregationInput | LeaseOrderByWithAggregationInput[]
    by: LeaseScalarFieldEnum[] | LeaseScalarFieldEnum
    having?: LeaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseCountAggregateInputType | true
    _avg?: LeaseAvgAggregateInputType
    _sum?: LeaseSumAggregateInputType
    _min?: LeaseMinAggregateInputType
    _max?: LeaseMaxAggregateInputType
  }

  export type LeaseGroupByOutputType = {
    id: string
    unitId: string
    tenantId: string
    startDate: Date
    endDate: Date
    rentAmount: number
    securityDeposit: number
    terms: string | null
    status: $Enums.LeaseStatus
    createdAt: Date
    updatedAt: Date
    _count: LeaseCountAggregateOutputType | null
    _avg: LeaseAvgAggregateOutputType | null
    _sum: LeaseSumAggregateOutputType | null
    _min: LeaseMinAggregateOutputType | null
    _max: LeaseMaxAggregateOutputType | null
  }

  type GetLeaseGroupByPayload<T extends LeaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseGroupByOutputType[P]>
        }
      >
    >


  export type LeaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    securityDeposit?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Document?: boolean | Lease$DocumentArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
    reminders?: boolean | Lease$remindersArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    securityDeposit?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    securityDeposit?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lease"]>

  export type LeaseSelectScalar = {
    id?: boolean
    unitId?: boolean
    tenantId?: boolean
    startDate?: boolean
    endDate?: boolean
    rentAmount?: boolean
    securityDeposit?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "tenantId" | "startDate" | "endDate" | "rentAmount" | "securityDeposit" | "terms" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["lease"]>
  export type LeaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | Lease$DocumentArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
    reminders?: boolean | Lease$remindersArgs<ExtArgs>
    _count?: boolean | LeaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type LeaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $LeasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lease"
    objects: {
      Document: Prisma.$DocumentPayload<ExtArgs>[]
      Tenant: Prisma.$TenantPayload<ExtArgs>
      Unit: Prisma.$UnitPayload<ExtArgs>
      reminders: Prisma.$ReminderLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      tenantId: string
      startDate: Date
      endDate: Date
      rentAmount: number
      securityDeposit: number
      terms: string | null
      status: $Enums.LeaseStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lease"]>
    composites: {}
  }

  type LeaseGetPayload<S extends boolean | null | undefined | LeaseDefaultArgs> = $Result.GetResult<Prisma.$LeasePayload, S>

  type LeaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseCountAggregateInputType | true
    }

  export interface LeaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lease'], meta: { name: 'Lease' } }
    /**
     * Find zero or one Lease that matches the filter.
     * @param {LeaseFindUniqueArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseFindUniqueArgs>(args: SelectSubset<T, LeaseFindUniqueArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseFindUniqueOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseFindFirstArgs>(args?: SelectSubset<T, LeaseFindFirstArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindFirstOrThrowArgs} args - Arguments to find a Lease
     * @example
     * // Get one Lease
     * const lease = await prisma.lease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leases
     * const leases = await prisma.lease.findMany()
     * 
     * // Get first 10 Leases
     * const leases = await prisma.lease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseWithIdOnly = await prisma.lease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseFindManyArgs>(args?: SelectSubset<T, LeaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lease.
     * @param {LeaseCreateArgs} args - Arguments to create a Lease.
     * @example
     * // Create one Lease
     * const Lease = await prisma.lease.create({
     *   data: {
     *     // ... data to create a Lease
     *   }
     * })
     * 
     */
    create<T extends LeaseCreateArgs>(args: SelectSubset<T, LeaseCreateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leases.
     * @param {LeaseCreateManyArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseCreateManyArgs>(args?: SelectSubset<T, LeaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leases and returns the data saved in the database.
     * @param {LeaseCreateManyAndReturnArgs} args - Arguments to create many Leases.
     * @example
     * // Create many Leases
     * const lease = await prisma.lease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lease.
     * @param {LeaseDeleteArgs} args - Arguments to delete one Lease.
     * @example
     * // Delete one Lease
     * const Lease = await prisma.lease.delete({
     *   where: {
     *     // ... filter to delete one Lease
     *   }
     * })
     * 
     */
    delete<T extends LeaseDeleteArgs>(args: SelectSubset<T, LeaseDeleteArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lease.
     * @param {LeaseUpdateArgs} args - Arguments to update one Lease.
     * @example
     * // Update one Lease
     * const lease = await prisma.lease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseUpdateArgs>(args: SelectSubset<T, LeaseUpdateArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leases.
     * @param {LeaseDeleteManyArgs} args - Arguments to filter Leases to delete.
     * @example
     * // Delete a few Leases
     * const { count } = await prisma.lease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseDeleteManyArgs>(args?: SelectSubset<T, LeaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseUpdateManyArgs>(args: SelectSubset<T, LeaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leases and returns the data updated in the database.
     * @param {LeaseUpdateManyAndReturnArgs} args - Arguments to update many Leases.
     * @example
     * // Update many Leases
     * const lease = await prisma.lease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leases and only return the `id`
     * const leaseWithIdOnly = await prisma.lease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lease.
     * @param {LeaseUpsertArgs} args - Arguments to update or create a Lease.
     * @example
     * // Update or create a Lease
     * const lease = await prisma.lease.upsert({
     *   create: {
     *     // ... data to create a Lease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lease we want to update
     *   }
     * })
     */
    upsert<T extends LeaseUpsertArgs>(args: SelectSubset<T, LeaseUpsertArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseCountArgs} args - Arguments to filter Leases to count.
     * @example
     * // Count the number of Leases
     * const count = await prisma.lease.count({
     *   where: {
     *     // ... the filter for the Leases we want to count
     *   }
     * })
    **/
    count<T extends LeaseCountArgs>(
      args?: Subset<T, LeaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseAggregateArgs>(args: Subset<T, LeaseAggregateArgs>): Prisma.PrismaPromise<GetLeaseAggregateType<T>>

    /**
     * Group by Lease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseGroupByArgs['orderBy'] }
        : { orderBy?: LeaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lease model
   */
  readonly fields: LeaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Document<T extends Lease$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, Lease$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reminders<T extends Lease$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Lease$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lease model
   */
  interface LeaseFieldRefs {
    readonly id: FieldRef<"Lease", 'String'>
    readonly unitId: FieldRef<"Lease", 'String'>
    readonly tenantId: FieldRef<"Lease", 'String'>
    readonly startDate: FieldRef<"Lease", 'DateTime'>
    readonly endDate: FieldRef<"Lease", 'DateTime'>
    readonly rentAmount: FieldRef<"Lease", 'Float'>
    readonly securityDeposit: FieldRef<"Lease", 'Float'>
    readonly terms: FieldRef<"Lease", 'String'>
    readonly status: FieldRef<"Lease", 'LeaseStatus'>
    readonly createdAt: FieldRef<"Lease", 'DateTime'>
    readonly updatedAt: FieldRef<"Lease", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lease findUnique
   */
  export type LeaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findUniqueOrThrow
   */
  export type LeaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease findFirst
   */
  export type LeaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findFirstOrThrow
   */
  export type LeaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Lease to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leases.
     */
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease findMany
   */
  export type LeaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter, which Leases to fetch.
     */
    where?: LeaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leases to fetch.
     */
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leases.
     */
    cursor?: LeaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leases.
     */
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Lease create
   */
  export type LeaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Lease.
     */
    data: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
  }

  /**
   * Lease createMany
   */
  export type LeaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lease createManyAndReturn
   */
  export type LeaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to create many Leases.
     */
    data: LeaseCreateManyInput | LeaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease update
   */
  export type LeaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Lease.
     */
    data: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
    /**
     * Choose, which Lease to update.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease updateMany
   */
  export type LeaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
  }

  /**
   * Lease updateManyAndReturn
   */
  export type LeaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * The data used to update Leases.
     */
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyInput>
    /**
     * Filter which Leases to update
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lease upsert
   */
  export type LeaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Lease to update in case it exists.
     */
    where: LeaseWhereUniqueInput
    /**
     * In case the Lease found by the `where` argument doesn't exist, create a new Lease with this data.
     */
    create: XOR<LeaseCreateInput, LeaseUncheckedCreateInput>
    /**
     * In case the Lease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseUpdateInput, LeaseUncheckedUpdateInput>
  }

  /**
   * Lease delete
   */
  export type LeaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    /**
     * Filter which Lease to delete.
     */
    where: LeaseWhereUniqueInput
  }

  /**
   * Lease deleteMany
   */
  export type LeaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leases to delete
     */
    where?: LeaseWhereInput
    /**
     * Limit how many Leases to delete.
     */
    limit?: number
  }

  /**
   * Lease.Document
   */
  export type Lease$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Lease.reminders
   */
  export type Lease$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    where?: ReminderLogWhereInput
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    cursor?: ReminderLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderLogScalarFieldEnum | ReminderLogScalarFieldEnum[]
  }

  /**
   * Lease without action
   */
  export type LeaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
  }


  /**
   * Model LeaseGeneratorUsage
   */

  export type AggregateLeaseGeneratorUsage = {
    _count: LeaseGeneratorUsageCountAggregateOutputType | null
    _avg: LeaseGeneratorUsageAvgAggregateOutputType | null
    _sum: LeaseGeneratorUsageSumAggregateOutputType | null
    _min: LeaseGeneratorUsageMinAggregateOutputType | null
    _max: LeaseGeneratorUsageMaxAggregateOutputType | null
  }

  export type LeaseGeneratorUsageAvgAggregateOutputType = {
    usageCount: number | null
    amountPaid: number | null
  }

  export type LeaseGeneratorUsageSumAggregateOutputType = {
    usageCount: number | null
    amountPaid: number | null
  }

  export type LeaseGeneratorUsageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    ipAddress: string | null
    userAgent: string | null
    usageCount: number | null
    paymentStatus: string | null
    stripeSessionId: string | null
    stripeCustomerId: string | null
    amountPaid: number | null
    currency: string | null
    paymentDate: Date | null
    accessExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseGeneratorUsageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    ipAddress: string | null
    userAgent: string | null
    usageCount: number | null
    paymentStatus: string | null
    stripeSessionId: string | null
    stripeCustomerId: string | null
    amountPaid: number | null
    currency: string | null
    paymentDate: Date | null
    accessExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaseGeneratorUsageCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    ipAddress: number
    userAgent: number
    usageCount: number
    paymentStatus: number
    stripeSessionId: number
    stripeCustomerId: number
    amountPaid: number
    currency: number
    paymentDate: number
    accessExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaseGeneratorUsageAvgAggregateInputType = {
    usageCount?: true
    amountPaid?: true
  }

  export type LeaseGeneratorUsageSumAggregateInputType = {
    usageCount?: true
    amountPaid?: true
  }

  export type LeaseGeneratorUsageMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    usageCount?: true
    paymentStatus?: true
    stripeSessionId?: true
    stripeCustomerId?: true
    amountPaid?: true
    currency?: true
    paymentDate?: true
    accessExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseGeneratorUsageMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    usageCount?: true
    paymentStatus?: true
    stripeSessionId?: true
    stripeCustomerId?: true
    amountPaid?: true
    currency?: true
    paymentDate?: true
    accessExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaseGeneratorUsageCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    usageCount?: true
    paymentStatus?: true
    stripeSessionId?: true
    stripeCustomerId?: true
    amountPaid?: true
    currency?: true
    paymentDate?: true
    accessExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaseGeneratorUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaseGeneratorUsage to aggregate.
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseGeneratorUsages to fetch.
     */
    orderBy?: LeaseGeneratorUsageOrderByWithRelationInput | LeaseGeneratorUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaseGeneratorUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseGeneratorUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseGeneratorUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaseGeneratorUsages
    **/
    _count?: true | LeaseGeneratorUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaseGeneratorUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaseGeneratorUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaseGeneratorUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaseGeneratorUsageMaxAggregateInputType
  }

  export type GetLeaseGeneratorUsageAggregateType<T extends LeaseGeneratorUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaseGeneratorUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaseGeneratorUsage[P]>
      : GetScalarType<T[P], AggregateLeaseGeneratorUsage[P]>
  }




  export type LeaseGeneratorUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaseGeneratorUsageWhereInput
    orderBy?: LeaseGeneratorUsageOrderByWithAggregationInput | LeaseGeneratorUsageOrderByWithAggregationInput[]
    by: LeaseGeneratorUsageScalarFieldEnum[] | LeaseGeneratorUsageScalarFieldEnum
    having?: LeaseGeneratorUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaseGeneratorUsageCountAggregateInputType | true
    _avg?: LeaseGeneratorUsageAvgAggregateInputType
    _sum?: LeaseGeneratorUsageSumAggregateInputType
    _min?: LeaseGeneratorUsageMinAggregateInputType
    _max?: LeaseGeneratorUsageMaxAggregateInputType
  }

  export type LeaseGeneratorUsageGroupByOutputType = {
    id: string
    userId: string | null
    email: string
    ipAddress: string | null
    userAgent: string | null
    usageCount: number | null
    paymentStatus: string | null
    stripeSessionId: string | null
    stripeCustomerId: string | null
    amountPaid: number | null
    currency: string | null
    paymentDate: Date | null
    accessExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: LeaseGeneratorUsageCountAggregateOutputType | null
    _avg: LeaseGeneratorUsageAvgAggregateOutputType | null
    _sum: LeaseGeneratorUsageSumAggregateOutputType | null
    _min: LeaseGeneratorUsageMinAggregateOutputType | null
    _max: LeaseGeneratorUsageMaxAggregateOutputType | null
  }

  type GetLeaseGeneratorUsageGroupByPayload<T extends LeaseGeneratorUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaseGeneratorUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaseGeneratorUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaseGeneratorUsageGroupByOutputType[P]>
            : GetScalarType<T[P], LeaseGeneratorUsageGroupByOutputType[P]>
        }
      >
    >


  export type LeaseGeneratorUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usageCount?: boolean
    paymentStatus?: boolean
    stripeSessionId?: boolean
    stripeCustomerId?: boolean
    amountPaid?: boolean
    currency?: boolean
    paymentDate?: boolean
    accessExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leaseGeneratorUsage"]>

  export type LeaseGeneratorUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usageCount?: boolean
    paymentStatus?: boolean
    stripeSessionId?: boolean
    stripeCustomerId?: boolean
    amountPaid?: boolean
    currency?: boolean
    paymentDate?: boolean
    accessExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leaseGeneratorUsage"]>

  export type LeaseGeneratorUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usageCount?: boolean
    paymentStatus?: boolean
    stripeSessionId?: boolean
    stripeCustomerId?: boolean
    amountPaid?: boolean
    currency?: boolean
    paymentDate?: boolean
    accessExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leaseGeneratorUsage"]>

  export type LeaseGeneratorUsageSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    usageCount?: boolean
    paymentStatus?: boolean
    stripeSessionId?: boolean
    stripeCustomerId?: boolean
    amountPaid?: boolean
    currency?: boolean
    paymentDate?: boolean
    accessExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaseGeneratorUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "ipAddress" | "userAgent" | "usageCount" | "paymentStatus" | "stripeSessionId" | "stripeCustomerId" | "amountPaid" | "currency" | "paymentDate" | "accessExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["leaseGeneratorUsage"]>
  export type LeaseGeneratorUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }
  export type LeaseGeneratorUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }
  export type LeaseGeneratorUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LeaseGeneratorUsage$UserArgs<ExtArgs>
  }

  export type $LeaseGeneratorUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaseGeneratorUsage"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      email: string
      ipAddress: string | null
      userAgent: string | null
      usageCount: number | null
      paymentStatus: string | null
      stripeSessionId: string | null
      stripeCustomerId: string | null
      amountPaid: number | null
      currency: string | null
      paymentDate: Date | null
      accessExpiresAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["leaseGeneratorUsage"]>
    composites: {}
  }

  type LeaseGeneratorUsageGetPayload<S extends boolean | null | undefined | LeaseGeneratorUsageDefaultArgs> = $Result.GetResult<Prisma.$LeaseGeneratorUsagePayload, S>

  type LeaseGeneratorUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaseGeneratorUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaseGeneratorUsageCountAggregateInputType | true
    }

  export interface LeaseGeneratorUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaseGeneratorUsage'], meta: { name: 'LeaseGeneratorUsage' } }
    /**
     * Find zero or one LeaseGeneratorUsage that matches the filter.
     * @param {LeaseGeneratorUsageFindUniqueArgs} args - Arguments to find a LeaseGeneratorUsage
     * @example
     * // Get one LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaseGeneratorUsageFindUniqueArgs>(args: SelectSubset<T, LeaseGeneratorUsageFindUniqueArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaseGeneratorUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaseGeneratorUsageFindUniqueOrThrowArgs} args - Arguments to find a LeaseGeneratorUsage
     * @example
     * // Get one LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaseGeneratorUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaseGeneratorUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaseGeneratorUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageFindFirstArgs} args - Arguments to find a LeaseGeneratorUsage
     * @example
     * // Get one LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaseGeneratorUsageFindFirstArgs>(args?: SelectSubset<T, LeaseGeneratorUsageFindFirstArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaseGeneratorUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageFindFirstOrThrowArgs} args - Arguments to find a LeaseGeneratorUsage
     * @example
     * // Get one LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaseGeneratorUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaseGeneratorUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaseGeneratorUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaseGeneratorUsages
     * const leaseGeneratorUsages = await prisma.leaseGeneratorUsage.findMany()
     * 
     * // Get first 10 LeaseGeneratorUsages
     * const leaseGeneratorUsages = await prisma.leaseGeneratorUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaseGeneratorUsageWithIdOnly = await prisma.leaseGeneratorUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaseGeneratorUsageFindManyArgs>(args?: SelectSubset<T, LeaseGeneratorUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaseGeneratorUsage.
     * @param {LeaseGeneratorUsageCreateArgs} args - Arguments to create a LeaseGeneratorUsage.
     * @example
     * // Create one LeaseGeneratorUsage
     * const LeaseGeneratorUsage = await prisma.leaseGeneratorUsage.create({
     *   data: {
     *     // ... data to create a LeaseGeneratorUsage
     *   }
     * })
     * 
     */
    create<T extends LeaseGeneratorUsageCreateArgs>(args: SelectSubset<T, LeaseGeneratorUsageCreateArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaseGeneratorUsages.
     * @param {LeaseGeneratorUsageCreateManyArgs} args - Arguments to create many LeaseGeneratorUsages.
     * @example
     * // Create many LeaseGeneratorUsages
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaseGeneratorUsageCreateManyArgs>(args?: SelectSubset<T, LeaseGeneratorUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaseGeneratorUsages and returns the data saved in the database.
     * @param {LeaseGeneratorUsageCreateManyAndReturnArgs} args - Arguments to create many LeaseGeneratorUsages.
     * @example
     * // Create many LeaseGeneratorUsages
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaseGeneratorUsages and only return the `id`
     * const leaseGeneratorUsageWithIdOnly = await prisma.leaseGeneratorUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaseGeneratorUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaseGeneratorUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaseGeneratorUsage.
     * @param {LeaseGeneratorUsageDeleteArgs} args - Arguments to delete one LeaseGeneratorUsage.
     * @example
     * // Delete one LeaseGeneratorUsage
     * const LeaseGeneratorUsage = await prisma.leaseGeneratorUsage.delete({
     *   where: {
     *     // ... filter to delete one LeaseGeneratorUsage
     *   }
     * })
     * 
     */
    delete<T extends LeaseGeneratorUsageDeleteArgs>(args: SelectSubset<T, LeaseGeneratorUsageDeleteArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaseGeneratorUsage.
     * @param {LeaseGeneratorUsageUpdateArgs} args - Arguments to update one LeaseGeneratorUsage.
     * @example
     * // Update one LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaseGeneratorUsageUpdateArgs>(args: SelectSubset<T, LeaseGeneratorUsageUpdateArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaseGeneratorUsages.
     * @param {LeaseGeneratorUsageDeleteManyArgs} args - Arguments to filter LeaseGeneratorUsages to delete.
     * @example
     * // Delete a few LeaseGeneratorUsages
     * const { count } = await prisma.leaseGeneratorUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaseGeneratorUsageDeleteManyArgs>(args?: SelectSubset<T, LeaseGeneratorUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaseGeneratorUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaseGeneratorUsages
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaseGeneratorUsageUpdateManyArgs>(args: SelectSubset<T, LeaseGeneratorUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaseGeneratorUsages and returns the data updated in the database.
     * @param {LeaseGeneratorUsageUpdateManyAndReturnArgs} args - Arguments to update many LeaseGeneratorUsages.
     * @example
     * // Update many LeaseGeneratorUsages
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaseGeneratorUsages and only return the `id`
     * const leaseGeneratorUsageWithIdOnly = await prisma.leaseGeneratorUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaseGeneratorUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaseGeneratorUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaseGeneratorUsage.
     * @param {LeaseGeneratorUsageUpsertArgs} args - Arguments to update or create a LeaseGeneratorUsage.
     * @example
     * // Update or create a LeaseGeneratorUsage
     * const leaseGeneratorUsage = await prisma.leaseGeneratorUsage.upsert({
     *   create: {
     *     // ... data to create a LeaseGeneratorUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaseGeneratorUsage we want to update
     *   }
     * })
     */
    upsert<T extends LeaseGeneratorUsageUpsertArgs>(args: SelectSubset<T, LeaseGeneratorUsageUpsertArgs<ExtArgs>>): Prisma__LeaseGeneratorUsageClient<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaseGeneratorUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageCountArgs} args - Arguments to filter LeaseGeneratorUsages to count.
     * @example
     * // Count the number of LeaseGeneratorUsages
     * const count = await prisma.leaseGeneratorUsage.count({
     *   where: {
     *     // ... the filter for the LeaseGeneratorUsages we want to count
     *   }
     * })
    **/
    count<T extends LeaseGeneratorUsageCountArgs>(
      args?: Subset<T, LeaseGeneratorUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaseGeneratorUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaseGeneratorUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaseGeneratorUsageAggregateArgs>(args: Subset<T, LeaseGeneratorUsageAggregateArgs>): Prisma.PrismaPromise<GetLeaseGeneratorUsageAggregateType<T>>

    /**
     * Group by LeaseGeneratorUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaseGeneratorUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaseGeneratorUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaseGeneratorUsageGroupByArgs['orderBy'] }
        : { orderBy?: LeaseGeneratorUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaseGeneratorUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaseGeneratorUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaseGeneratorUsage model
   */
  readonly fields: LeaseGeneratorUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaseGeneratorUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaseGeneratorUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends LeaseGeneratorUsage$UserArgs<ExtArgs> = {}>(args?: Subset<T, LeaseGeneratorUsage$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaseGeneratorUsage model
   */
  interface LeaseGeneratorUsageFieldRefs {
    readonly id: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly userId: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly email: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly ipAddress: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly userAgent: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly usageCount: FieldRef<"LeaseGeneratorUsage", 'Int'>
    readonly paymentStatus: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly stripeSessionId: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly stripeCustomerId: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly amountPaid: FieldRef<"LeaseGeneratorUsage", 'Int'>
    readonly currency: FieldRef<"LeaseGeneratorUsage", 'String'>
    readonly paymentDate: FieldRef<"LeaseGeneratorUsage", 'DateTime'>
    readonly accessExpiresAt: FieldRef<"LeaseGeneratorUsage", 'DateTime'>
    readonly createdAt: FieldRef<"LeaseGeneratorUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaseGeneratorUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaseGeneratorUsage findUnique
   */
  export type LeaseGeneratorUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter, which LeaseGeneratorUsage to fetch.
     */
    where: LeaseGeneratorUsageWhereUniqueInput
  }

  /**
   * LeaseGeneratorUsage findUniqueOrThrow
   */
  export type LeaseGeneratorUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter, which LeaseGeneratorUsage to fetch.
     */
    where: LeaseGeneratorUsageWhereUniqueInput
  }

  /**
   * LeaseGeneratorUsage findFirst
   */
  export type LeaseGeneratorUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter, which LeaseGeneratorUsage to fetch.
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseGeneratorUsages to fetch.
     */
    orderBy?: LeaseGeneratorUsageOrderByWithRelationInput | LeaseGeneratorUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaseGeneratorUsages.
     */
    cursor?: LeaseGeneratorUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseGeneratorUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseGeneratorUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaseGeneratorUsages.
     */
    distinct?: LeaseGeneratorUsageScalarFieldEnum | LeaseGeneratorUsageScalarFieldEnum[]
  }

  /**
   * LeaseGeneratorUsage findFirstOrThrow
   */
  export type LeaseGeneratorUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter, which LeaseGeneratorUsage to fetch.
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseGeneratorUsages to fetch.
     */
    orderBy?: LeaseGeneratorUsageOrderByWithRelationInput | LeaseGeneratorUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaseGeneratorUsages.
     */
    cursor?: LeaseGeneratorUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseGeneratorUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseGeneratorUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaseGeneratorUsages.
     */
    distinct?: LeaseGeneratorUsageScalarFieldEnum | LeaseGeneratorUsageScalarFieldEnum[]
  }

  /**
   * LeaseGeneratorUsage findMany
   */
  export type LeaseGeneratorUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter, which LeaseGeneratorUsages to fetch.
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaseGeneratorUsages to fetch.
     */
    orderBy?: LeaseGeneratorUsageOrderByWithRelationInput | LeaseGeneratorUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaseGeneratorUsages.
     */
    cursor?: LeaseGeneratorUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaseGeneratorUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaseGeneratorUsages.
     */
    skip?: number
    distinct?: LeaseGeneratorUsageScalarFieldEnum | LeaseGeneratorUsageScalarFieldEnum[]
  }

  /**
   * LeaseGeneratorUsage create
   */
  export type LeaseGeneratorUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaseGeneratorUsage.
     */
    data: XOR<LeaseGeneratorUsageCreateInput, LeaseGeneratorUsageUncheckedCreateInput>
  }

  /**
   * LeaseGeneratorUsage createMany
   */
  export type LeaseGeneratorUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaseGeneratorUsages.
     */
    data: LeaseGeneratorUsageCreateManyInput | LeaseGeneratorUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaseGeneratorUsage createManyAndReturn
   */
  export type LeaseGeneratorUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * The data used to create many LeaseGeneratorUsages.
     */
    data: LeaseGeneratorUsageCreateManyInput | LeaseGeneratorUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaseGeneratorUsage update
   */
  export type LeaseGeneratorUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaseGeneratorUsage.
     */
    data: XOR<LeaseGeneratorUsageUpdateInput, LeaseGeneratorUsageUncheckedUpdateInput>
    /**
     * Choose, which LeaseGeneratorUsage to update.
     */
    where: LeaseGeneratorUsageWhereUniqueInput
  }

  /**
   * LeaseGeneratorUsage updateMany
   */
  export type LeaseGeneratorUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaseGeneratorUsages.
     */
    data: XOR<LeaseGeneratorUsageUpdateManyMutationInput, LeaseGeneratorUsageUncheckedUpdateManyInput>
    /**
     * Filter which LeaseGeneratorUsages to update
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * Limit how many LeaseGeneratorUsages to update.
     */
    limit?: number
  }

  /**
   * LeaseGeneratorUsage updateManyAndReturn
   */
  export type LeaseGeneratorUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * The data used to update LeaseGeneratorUsages.
     */
    data: XOR<LeaseGeneratorUsageUpdateManyMutationInput, LeaseGeneratorUsageUncheckedUpdateManyInput>
    /**
     * Filter which LeaseGeneratorUsages to update
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * Limit how many LeaseGeneratorUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaseGeneratorUsage upsert
   */
  export type LeaseGeneratorUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaseGeneratorUsage to update in case it exists.
     */
    where: LeaseGeneratorUsageWhereUniqueInput
    /**
     * In case the LeaseGeneratorUsage found by the `where` argument doesn't exist, create a new LeaseGeneratorUsage with this data.
     */
    create: XOR<LeaseGeneratorUsageCreateInput, LeaseGeneratorUsageUncheckedCreateInput>
    /**
     * In case the LeaseGeneratorUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaseGeneratorUsageUpdateInput, LeaseGeneratorUsageUncheckedUpdateInput>
  }

  /**
   * LeaseGeneratorUsage delete
   */
  export type LeaseGeneratorUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    /**
     * Filter which LeaseGeneratorUsage to delete.
     */
    where: LeaseGeneratorUsageWhereUniqueInput
  }

  /**
   * LeaseGeneratorUsage deleteMany
   */
  export type LeaseGeneratorUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaseGeneratorUsages to delete
     */
    where?: LeaseGeneratorUsageWhereInput
    /**
     * Limit how many LeaseGeneratorUsages to delete.
     */
    limit?: number
  }

  /**
   * LeaseGeneratorUsage.User
   */
  export type LeaseGeneratorUsage$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeaseGeneratorUsage without action
   */
  export type LeaseGeneratorUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRequest
   */

  export type AggregateMaintenanceRequest = {
    _count: MaintenanceRequestCountAggregateOutputType | null
    _avg: MaintenanceRequestAvgAggregateOutputType | null
    _sum: MaintenanceRequestSumAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  export type MaintenanceRequestAvgAggregateOutputType = {
    estimatedCost: number | null
    actualCost: number | null
  }

  export type MaintenanceRequestSumAggregateOutputType = {
    estimatedCost: number | null
    actualCost: number | null
  }

  export type MaintenanceRequestMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.RequestStatus | null
    preferredDate: Date | null
    allowEntry: boolean | null
    contactPhone: string | null
    requestedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    assignedTo: string | null
    estimatedCost: number | null
    actualCost: number | null
  }

  export type MaintenanceRequestMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: $Enums.Priority | null
    status: $Enums.RequestStatus | null
    preferredDate: Date | null
    allowEntry: boolean | null
    contactPhone: string | null
    requestedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    assignedTo: string | null
    estimatedCost: number | null
    actualCost: number | null
  }

  export type MaintenanceRequestCountAggregateOutputType = {
    id: number
    unitId: number
    title: number
    description: number
    category: number
    priority: number
    status: number
    preferredDate: number
    allowEntry: number
    contactPhone: number
    requestedBy: number
    notes: number
    photos: number
    createdAt: number
    updatedAt: number
    completedAt: number
    assignedTo: number
    estimatedCost: number
    actualCost: number
    _all: number
  }


  export type MaintenanceRequestAvgAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
  }

  export type MaintenanceRequestSumAggregateInputType = {
    estimatedCost?: true
    actualCost?: true
  }

  export type MaintenanceRequestMinAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    preferredDate?: true
    allowEntry?: true
    contactPhone?: true
    requestedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    assignedTo?: true
    estimatedCost?: true
    actualCost?: true
  }

  export type MaintenanceRequestMaxAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    preferredDate?: true
    allowEntry?: true
    contactPhone?: true
    requestedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    assignedTo?: true
    estimatedCost?: true
    actualCost?: true
  }

  export type MaintenanceRequestCountAggregateInputType = {
    id?: true
    unitId?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    status?: true
    preferredDate?: true
    allowEntry?: true
    contactPhone?: true
    requestedBy?: true
    notes?: true
    photos?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    assignedTo?: true
    estimatedCost?: true
    actualCost?: true
    _all?: true
  }

  export type MaintenanceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequest to aggregate.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRequests
    **/
    _count?: true | MaintenanceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type GetMaintenanceRequestAggregateType<T extends MaintenanceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
  }




  export type MaintenanceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithAggregationInput | MaintenanceRequestOrderByWithAggregationInput[]
    by: MaintenanceRequestScalarFieldEnum[] | MaintenanceRequestScalarFieldEnum
    having?: MaintenanceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRequestCountAggregateInputType | true
    _avg?: MaintenanceRequestAvgAggregateInputType
    _sum?: MaintenanceRequestSumAggregateInputType
    _min?: MaintenanceRequestMinAggregateInputType
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type MaintenanceRequestGroupByOutputType = {
    id: string
    unitId: string
    title: string
    description: string
    category: string | null
    priority: $Enums.Priority
    status: $Enums.RequestStatus
    preferredDate: Date | null
    allowEntry: boolean
    contactPhone: string | null
    requestedBy: string | null
    notes: string | null
    photos: string[]
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    assignedTo: string | null
    estimatedCost: number | null
    actualCost: number | null
    _count: MaintenanceRequestCountAggregateOutputType | null
    _avg: MaintenanceRequestAvgAggregateOutputType | null
    _sum: MaintenanceRequestSumAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceRequestGroupByPayload<T extends MaintenanceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    preferredDate?: boolean
    allowEntry?: boolean
    contactPhone?: boolean
    requestedBy?: boolean
    notes?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    Expense?: boolean | MaintenanceRequest$ExpenseArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
    files?: boolean | MaintenanceRequest$filesArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    preferredDate?: boolean
    allowEntry?: boolean
    contactPhone?: boolean
    requestedBy?: boolean
    notes?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    preferredDate?: boolean
    allowEntry?: boolean
    contactPhone?: boolean
    requestedBy?: boolean
    notes?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectScalar = {
    id?: boolean
    unitId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    preferredDate?: boolean
    allowEntry?: boolean
    contactPhone?: boolean
    requestedBy?: boolean
    notes?: boolean
    photos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    estimatedCost?: boolean
    actualCost?: boolean
  }

  export type MaintenanceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "title" | "description" | "category" | "priority" | "status" | "preferredDate" | "allowEntry" | "contactPhone" | "requestedBy" | "notes" | "photos" | "createdAt" | "updatedAt" | "completedAt" | "assignedTo" | "estimatedCost" | "actualCost", ExtArgs["result"]["maintenanceRequest"]>
  export type MaintenanceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Expense?: boolean | MaintenanceRequest$ExpenseArgs<ExtArgs>
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
    files?: boolean | MaintenanceRequest$filesArgs<ExtArgs>
    _count?: boolean | MaintenanceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $MaintenanceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRequest"
    objects: {
      Expense: Prisma.$ExpensePayload<ExtArgs>[]
      Unit: Prisma.$UnitPayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      title: string
      description: string
      category: string | null
      priority: $Enums.Priority
      status: $Enums.RequestStatus
      preferredDate: Date | null
      allowEntry: boolean
      contactPhone: string | null
      requestedBy: string | null
      notes: string | null
      photos: string[]
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      assignedTo: string | null
      estimatedCost: number | null
      actualCost: number | null
    }, ExtArgs["result"]["maintenanceRequest"]>
    composites: {}
  }

  type MaintenanceRequestGetPayload<S extends boolean | null | undefined | MaintenanceRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRequestPayload, S>

  type MaintenanceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceRequestCountAggregateInputType | true
    }

  export interface MaintenanceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRequest'], meta: { name: 'MaintenanceRequest' } }
    /**
     * Find zero or one MaintenanceRequest that matches the filter.
     * @param {MaintenanceRequestFindUniqueArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
     * 
     * // Get first 10 MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceRequest.
     * @param {MaintenanceRequestCreateArgs} args - Arguments to create a MaintenanceRequest.
     * @example
     * // Create one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRequestCreateArgs>(args: SelectSubset<T, MaintenanceRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceRequests.
     * @param {MaintenanceRequestCreateManyArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRequests and returns the data saved in the database.
     * @param {MaintenanceRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceRequest.
     * @param {MaintenanceRequestDeleteArgs} args - Arguments to delete one MaintenanceRequest.
     * @example
     * // Delete one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRequestDeleteArgs>(args: SelectSubset<T, MaintenanceRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceRequest.
     * @param {MaintenanceRequestUpdateArgs} args - Arguments to update one MaintenanceRequest.
     * @example
     * // Update one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRequestUpdateArgs>(args: SelectSubset<T, MaintenanceRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceRequests.
     * @param {MaintenanceRequestDeleteManyArgs} args - Arguments to filter MaintenanceRequests to delete.
     * @example
     * // Delete a few MaintenanceRequests
     * const { count } = await prisma.maintenanceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests and returns the data updated in the database.
     * @param {MaintenanceRequestUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceRequests.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceRequest.
     * @param {MaintenanceRequestUpsertArgs} args - Arguments to update or create a MaintenanceRequest.
     * @example
     * // Update or create a MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRequestUpsertArgs>(args: SelectSubset<T, MaintenanceRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestCountArgs} args - Arguments to filter MaintenanceRequests to count.
     * @example
     * // Count the number of MaintenanceRequests
     * const count = await prisma.maintenanceRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRequestCountArgs>(
      args?: Subset<T, MaintenanceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRequestAggregateArgs>(args: Subset<T, MaintenanceRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRequestAggregateType<T>>

    /**
     * Group by MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRequest model
   */
  readonly fields: MaintenanceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Expense<T extends MaintenanceRequest$ExpenseArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$ExpenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends MaintenanceRequest$filesArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRequest model
   */
  interface MaintenanceRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceRequest", 'String'>
    readonly unitId: FieldRef<"MaintenanceRequest", 'String'>
    readonly title: FieldRef<"MaintenanceRequest", 'String'>
    readonly description: FieldRef<"MaintenanceRequest", 'String'>
    readonly category: FieldRef<"MaintenanceRequest", 'String'>
    readonly priority: FieldRef<"MaintenanceRequest", 'Priority'>
    readonly status: FieldRef<"MaintenanceRequest", 'RequestStatus'>
    readonly preferredDate: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly allowEntry: FieldRef<"MaintenanceRequest", 'Boolean'>
    readonly contactPhone: FieldRef<"MaintenanceRequest", 'String'>
    readonly requestedBy: FieldRef<"MaintenanceRequest", 'String'>
    readonly notes: FieldRef<"MaintenanceRequest", 'String'>
    readonly photos: FieldRef<"MaintenanceRequest", 'String[]'>
    readonly createdAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly completedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly assignedTo: FieldRef<"MaintenanceRequest", 'String'>
    readonly estimatedCost: FieldRef<"MaintenanceRequest", 'Float'>
    readonly actualCost: FieldRef<"MaintenanceRequest", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRequest findUnique
   */
  export type MaintenanceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findUniqueOrThrow
   */
  export type MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findFirst
   */
  export type MaintenanceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findFirstOrThrow
   */
  export type MaintenanceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findMany
   */
  export type MaintenanceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequests to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest create
   */
  export type MaintenanceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceRequest createMany
   */
  export type MaintenanceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceRequest createManyAndReturn
   */
  export type MaintenanceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest update
   */
  export type MaintenanceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRequest to update.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest updateMany
   */
  export type MaintenanceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest updateManyAndReturn
   */
  export type MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest upsert
   */
  export type MaintenanceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRequest to update in case it exists.
     */
    where: MaintenanceRequestWhereUniqueInput
    /**
     * In case the MaintenanceRequest found by the `where` argument doesn't exist, create a new MaintenanceRequest with this data.
     */
    create: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceRequest delete
   */
  export type MaintenanceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRequest to delete.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest deleteMany
   */
  export type MaintenanceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequests to delete
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest.Expense
   */
  export type MaintenanceRequest$ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest.files
   */
  export type MaintenanceRequest$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest without action
   */
  export type MaintenanceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    readAt: Date | null
    attachmentUrl: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    readAt: Date | null
    attachmentUrl: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    threadId: number
    senderId: number
    receiverId: number
    content: number
    readAt: number
    attachmentUrl: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    receiverId?: true
    content?: true
    readAt?: true
    attachmentUrl?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    receiverId?: true
    content?: true
    readAt?: true
    attachmentUrl?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    receiverId?: true
    content?: true
    readAt?: true
    attachmentUrl?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    threadId: string
    senderId: string
    receiverId: string
    content: string
    readAt: Date | null
    attachmentUrl: string | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    readAt?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    readAt?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    readAt?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    readAt?: boolean
    attachmentUrl?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "senderId" | "receiverId" | "content" | "readAt" | "attachmentUrl" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      User_Message_receiverIdToUser: Prisma.$UserPayload<ExtArgs>
      User_Message_senderIdToUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      senderId: string
      receiverId: string
      content: string
      readAt: Date | null
      attachmentUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User_Message_receiverIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User_Message_senderIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly attachmentUrl: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    description: string | null
    imageUrl: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyType: $Enums.PropertyType | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    description: string | null
    imageUrl: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    propertyType: $Enums.PropertyType | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    description: number
    imageUrl: number
    ownerId: number
    createdAt: number
    updatedAt: number
    propertyType: number
    _all: number
  }


  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    description?: true
    imageUrl?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    propertyType?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    description?: true
    imageUrl?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    propertyType?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    description?: true
    imageUrl?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    propertyType?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description: string | null
    imageUrl: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    propertyType: $Enums.PropertyType
    _count: PropertyCountAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    description?: boolean
    imageUrl?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyType?: boolean
    Document?: boolean | Property$DocumentArgs<ExtArgs>
    Expense?: boolean | Property$ExpenseArgs<ExtArgs>
    Inspection?: boolean | Property$InspectionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Unit?: boolean | Property$UnitArgs<ExtArgs>
    files?: boolean | Property$filesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    description?: boolean
    imageUrl?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyType?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    description?: boolean
    imageUrl?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyType?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    description?: boolean
    imageUrl?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyType?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "state" | "zipCode" | "description" | "imageUrl" | "ownerId" | "createdAt" | "updatedAt" | "propertyType", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Document?: boolean | Property$DocumentArgs<ExtArgs>
    Expense?: boolean | Property$ExpenseArgs<ExtArgs>
    Inspection?: boolean | Property$InspectionArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Unit?: boolean | Property$UnitArgs<ExtArgs>
    files?: boolean | Property$filesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      Document: Prisma.$DocumentPayload<ExtArgs>[]
      Expense: Prisma.$ExpensePayload<ExtArgs>[]
      Inspection: Prisma.$InspectionPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      Unit: Prisma.$UnitPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      state: string
      zipCode: string
      description: string | null
      imageUrl: string | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
      propertyType: $Enums.PropertyType
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Document<T extends Property$DocumentArgs<ExtArgs> = {}>(args?: Subset<T, Property$DocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Expense<T extends Property$ExpenseArgs<ExtArgs> = {}>(args?: Subset<T, Property$ExpenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inspection<T extends Property$InspectionArgs<ExtArgs> = {}>(args?: Subset<T, Property$InspectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Unit<T extends Property$UnitArgs<ExtArgs> = {}>(args?: Subset<T, Property$UnitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Property$filesArgs<ExtArgs> = {}>(args?: Subset<T, Property$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly address: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly state: FieldRef<"Property", 'String'>
    readonly zipCode: FieldRef<"Property", 'String'>
    readonly description: FieldRef<"Property", 'String'>
    readonly imageUrl: FieldRef<"Property", 'String'>
    readonly ownerId: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
    readonly propertyType: FieldRef<"Property", 'PropertyType'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.Document
   */
  export type Property$DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Property.Expense
   */
  export type Property$ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Property.Inspection
   */
  export type Property$InspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Property.Unit
   */
  export type Property$UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Property.files
   */
  export type Property$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.SubStatus | null
    startDate: Date | null
    endDate: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    planId: string | null
    planType: $Enums.PlanType | null
    billingPeriod: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.SubStatus | null
    startDate: Date | null
    endDate: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    planId: string | null
    planType: $Enums.PlanType | null
    billingPeriod: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    startDate: number
    endDate: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripePriceId: number
    planId: number
    planType: number
    billingPeriod: number
    currentPeriodStart: number
    currentPeriodEnd: number
    trialStart: number
    trialEnd: number
    cancelAtPeriodEnd: number
    canceledAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startDate?: true
    endDate?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    planId?: true
    planType?: true
    billingPeriod?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    trialStart?: true
    trialEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startDate?: true
    endDate?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    planId?: true
    planType?: true
    billingPeriod?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    trialStart?: true
    trialEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    startDate?: true
    endDate?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    planId?: true
    planType?: true
    billingPeriod?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    trialStart?: true
    trialEnd?: true
    cancelAtPeriodEnd?: true
    canceledAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.SubStatus
    startDate: Date
    endDate: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    planId: string | null
    planType: $Enums.PlanType | null
    billingPeriod: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    canceledAt: Date | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    planId?: boolean
    planType?: boolean
    billingPeriod?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    Invoice?: boolean | Subscription$InvoiceArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    paymentFailures?: boolean | Subscription$paymentFailuresArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    planId?: boolean
    planType?: boolean
    billingPeriod?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    planId?: boolean
    planType?: boolean
    billingPeriod?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    planId?: boolean
    planType?: boolean
    billingPeriod?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    cancelAtPeriodEnd?: boolean
    canceledAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "startDate" | "endDate" | "cancelledAt" | "createdAt" | "updatedAt" | "stripeCustomerId" | "stripeSubscriptionId" | "stripePriceId" | "planId" | "planType" | "billingPeriod" | "currentPeriodStart" | "currentPeriodEnd" | "trialStart" | "trialEnd" | "cancelAtPeriodEnd" | "canceledAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Invoice?: boolean | Subscription$InvoiceArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    paymentFailures?: boolean | Subscription$paymentFailuresArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      paymentFailures: Prisma.$PaymentFailurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.SubStatus
      startDate: Date
      endDate: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      stripePriceId: string | null
      planId: string | null
      planType: $Enums.PlanType | null
      billingPeriod: string | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      cancelAtPeriodEnd: boolean | null
      canceledAt: Date | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Invoice<T extends Subscription$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentFailures<T extends Subscription$paymentFailuresArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentFailuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubStatus'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripePriceId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly planType: FieldRef<"Subscription", 'PlanType'>
    readonly billingPeriod: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly trialStart: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.Invoice
   */
  export type Subscription$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription.paymentFailures
   */
  export type Subscription$paymentFailuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    where?: PaymentFailureWhereInput
    orderBy?: PaymentFailureOrderByWithRelationInput | PaymentFailureOrderByWithRelationInput[]
    cursor?: PaymentFailureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentFailureScalarFieldEnum | PaymentFailureScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    emergencyContact: string | null
    avatarUrl: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    emergencyContact: string | null
    avatarUrl: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    emergencyContact: number
    avatarUrl: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    emergencyContact?: true
    avatarUrl?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    emergencyContact?: true
    avatarUrl?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    emergencyContact?: true
    avatarUrl?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    emergencyContact: string | null
    avatarUrl: string | null
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    avatarUrl?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lease?: boolean | Tenant$LeaseArgs<ExtArgs>
    User?: boolean | Tenant$UserArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    avatarUrl?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | Tenant$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    avatarUrl?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | Tenant$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    avatarUrl?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "emergencyContact" | "avatarUrl" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lease?: boolean | Tenant$LeaseArgs<ExtArgs>
    User?: boolean | Tenant$UserArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Tenant$UserArgs<ExtArgs>
  }
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Tenant$UserArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      Lease: Prisma.$LeasePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      emergencyContact: string | null
      avatarUrl: string | null
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lease<T extends Tenant$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$LeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Tenant$UserArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly emergencyContact: FieldRef<"Tenant", 'String'>
    readonly avatarUrl: FieldRef<"Tenant", 'String'>
    readonly userId: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.Lease
   */
  export type Tenant$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Tenant.User
   */
  export type Tenant$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareFeet: number | null
    rent: number | null
  }

  export type UnitSumAggregateOutputType = {
    bedrooms: number | null
    bathrooms: number | null
    squareFeet: number | null
    rent: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    unitNumber: string | null
    propertyId: string | null
    bedrooms: number | null
    bathrooms: number | null
    squareFeet: number | null
    rent: number | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    lastInspectionDate: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    unitNumber: string | null
    propertyId: string | null
    bedrooms: number | null
    bathrooms: number | null
    squareFeet: number | null
    rent: number | null
    status: $Enums.UnitStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    lastInspectionDate: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    unitNumber: number
    propertyId: number
    bedrooms: number
    bathrooms: number
    squareFeet: number
    rent: number
    status: number
    createdAt: number
    updatedAt: number
    lastInspectionDate: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareFeet?: true
    rent?: true
  }

  export type UnitSumAggregateInputType = {
    bedrooms?: true
    bathrooms?: true
    squareFeet?: true
    rent?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    unitNumber?: true
    propertyId?: true
    bedrooms?: true
    bathrooms?: true
    squareFeet?: true
    rent?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInspectionDate?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    unitNumber?: true
    propertyId?: true
    bedrooms?: true
    bathrooms?: true
    squareFeet?: true
    rent?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInspectionDate?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    unitNumber?: true
    propertyId?: true
    bedrooms?: true
    bathrooms?: true
    squareFeet?: true
    rent?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastInspectionDate?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    unitNumber: string
    propertyId: string
    bedrooms: number
    bathrooms: number
    squareFeet: number | null
    rent: number
    status: $Enums.UnitStatus
    createdAt: Date
    updatedAt: Date
    lastInspectionDate: Date | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    propertyId?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFeet?: boolean
    rent?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInspectionDate?: boolean
    Inspection?: boolean | Unit$InspectionArgs<ExtArgs>
    Lease?: boolean | Unit$LeaseArgs<ExtArgs>
    MaintenanceRequest?: boolean | Unit$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    propertyId?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFeet?: boolean
    rent?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInspectionDate?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitNumber?: boolean
    propertyId?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFeet?: boolean
    rent?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInspectionDate?: boolean
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    unitNumber?: boolean
    propertyId?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    squareFeet?: boolean
    rent?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastInspectionDate?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitNumber" | "propertyId" | "bedrooms" | "bathrooms" | "squareFeet" | "rent" | "status" | "createdAt" | "updatedAt" | "lastInspectionDate", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inspection?: boolean | Unit$InspectionArgs<ExtArgs>
    Lease?: boolean | Unit$LeaseArgs<ExtArgs>
    MaintenanceRequest?: boolean | Unit$MaintenanceRequestArgs<ExtArgs>
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      Inspection: Prisma.$InspectionPayload<ExtArgs>[]
      Lease: Prisma.$LeasePayload<ExtArgs>[]
      MaintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      Property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitNumber: string
      propertyId: string
      bedrooms: number
      bathrooms: number
      squareFeet: number | null
      rent: number
      status: $Enums.UnitStatus
      createdAt: Date
      updatedAt: Date
      lastInspectionDate: Date | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inspection<T extends Unit$InspectionArgs<ExtArgs> = {}>(args?: Subset<T, Unit$InspectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Lease<T extends Unit$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, Unit$LeaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MaintenanceRequest<T extends Unit$MaintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, Unit$MaintenanceRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly unitNumber: FieldRef<"Unit", 'String'>
    readonly propertyId: FieldRef<"Unit", 'String'>
    readonly bedrooms: FieldRef<"Unit", 'Int'>
    readonly bathrooms: FieldRef<"Unit", 'Float'>
    readonly squareFeet: FieldRef<"Unit", 'Int'>
    readonly rent: FieldRef<"Unit", 'Float'>
    readonly status: FieldRef<"Unit", 'UnitStatus'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
    readonly lastInspectionDate: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.Inspection
   */
  export type Unit$InspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Unit.Lease
   */
  export type Unit$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
    orderBy?: LeaseOrderByWithRelationInput | LeaseOrderByWithRelationInput[]
    cursor?: LeaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseScalarFieldEnum | LeaseScalarFieldEnum[]
  }

  /**
   * Unit.MaintenanceRequest
   */
  export type Unit$MaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    supabaseId: string | null
    stripeCustomerId: string | null
    email: string | null
    name: string | null
    phone: string | null
    bio: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    supabaseId: string | null
    stripeCustomerId: string | null
    email: string | null
    name: string | null
    phone: string | null
    bio: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    supabaseId: number
    stripeCustomerId: number
    email: number
    name: number
    phone: number
    bio: number
    avatarUrl: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    supabaseId?: true
    stripeCustomerId?: true
    email?: true
    name?: true
    phone?: true
    bio?: true
    avatarUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    supabaseId?: true
    stripeCustomerId?: true
    email?: true
    name?: true
    phone?: true
    bio?: true
    avatarUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    supabaseId?: true
    stripeCustomerId?: true
    email?: true
    name?: true
    phone?: true
    bio?: true
    avatarUrl?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    supabaseId: string
    stripeCustomerId: string | null
    email: string
    name: string | null
    phone: string | null
    bio: string | null
    avatarUrl: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    stripeCustomerId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    bio?: boolean
    avatarUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    BlogArticle?: boolean | User$BlogArticleArgs<ExtArgs>
    Inspection?: boolean | User$InspectionArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    LeaseGeneratorUsage?: boolean | User$LeaseGeneratorUsageArgs<ExtArgs>
    Message_Message_receiverIdToUser?: boolean | User$Message_Message_receiverIdToUserArgs<ExtArgs>
    Message_Message_senderIdToUser?: boolean | User$Message_Message_senderIdToUserArgs<ExtArgs>
    Property?: boolean | User$PropertyArgs<ExtArgs>
    Subscription?: boolean | User$SubscriptionArgs<ExtArgs>
    Tenant?: boolean | User$TenantArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    reminders?: boolean | User$remindersArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    featureAccess?: boolean | User$featureAccessArgs<ExtArgs>
    accessLogs?: boolean | User$accessLogsArgs<ExtArgs>
    notificationLogs?: boolean | User$notificationLogsArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    stripeCustomerId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    bio?: boolean
    avatarUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseId?: boolean
    stripeCustomerId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    bio?: boolean
    avatarUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    supabaseId?: boolean
    stripeCustomerId?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    bio?: boolean
    avatarUrl?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supabaseId" | "stripeCustomerId" | "email" | "name" | "phone" | "bio" | "avatarUrl" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlogArticle?: boolean | User$BlogArticleArgs<ExtArgs>
    Inspection?: boolean | User$InspectionArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    LeaseGeneratorUsage?: boolean | User$LeaseGeneratorUsageArgs<ExtArgs>
    Message_Message_receiverIdToUser?: boolean | User$Message_Message_receiverIdToUserArgs<ExtArgs>
    Message_Message_senderIdToUser?: boolean | User$Message_Message_senderIdToUserArgs<ExtArgs>
    Property?: boolean | User$PropertyArgs<ExtArgs>
    Subscription?: boolean | User$SubscriptionArgs<ExtArgs>
    Tenant?: boolean | User$TenantArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    reminders?: boolean | User$remindersArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    featureAccess?: boolean | User$featureAccessArgs<ExtArgs>
    accessLogs?: boolean | User$accessLogsArgs<ExtArgs>
    notificationLogs?: boolean | User$notificationLogsArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      BlogArticle: Prisma.$BlogArticlePayload<ExtArgs>[]
      Inspection: Prisma.$InspectionPayload<ExtArgs>[]
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
      LeaseGeneratorUsage: Prisma.$LeaseGeneratorUsagePayload<ExtArgs>[]
      Message_Message_receiverIdToUser: Prisma.$MessagePayload<ExtArgs>[]
      Message_Message_senderIdToUser: Prisma.$MessagePayload<ExtArgs>[]
      Property: Prisma.$PropertyPayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
      Tenant: Prisma.$TenantPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      reminders: Prisma.$ReminderLogPayload<ExtArgs>[]
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      featureAccess: Prisma.$UserFeatureAccessPayload<ExtArgs> | null
      accessLogs: Prisma.$UserAccessLogPayload<ExtArgs>[]
      notificationLogs: Prisma.$NotificationLogPayload<ExtArgs>[]
      uploadedFiles: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supabaseId: string
      stripeCustomerId: string | null
      email: string
      name: string | null
      phone: string | null
      bio: string | null
      avatarUrl: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlogArticle<T extends User$BlogArticleArgs<ExtArgs> = {}>(args?: Subset<T, User$BlogArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inspection<T extends User$InspectionArgs<ExtArgs> = {}>(args?: Subset<T, User$InspectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invoice<T extends User$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, User$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LeaseGeneratorUsage<T extends User$LeaseGeneratorUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$LeaseGeneratorUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaseGeneratorUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message_Message_receiverIdToUser<T extends User$Message_Message_receiverIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Message_Message_receiverIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message_Message_senderIdToUser<T extends User$Message_Message_senderIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Message_Message_senderIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Property<T extends User$PropertyArgs<ExtArgs> = {}>(args?: Subset<T, User$PropertyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subscription<T extends User$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$SubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tenant<T extends User$TenantArgs<ExtArgs> = {}>(args?: Subset<T, User$TenantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends User$remindersArgs<ExtArgs> = {}>(args?: Subset<T, User$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featureAccess<T extends User$featureAccessArgs<ExtArgs> = {}>(args?: Subset<T, User$featureAccessArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accessLogs<T extends User$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationLogs<T extends User$notificationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedFiles<T extends User$uploadedFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly supabaseId: FieldRef<"User", 'String'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.BlogArticle
   */
  export type User$BlogArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogArticle
     */
    select?: BlogArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogArticle
     */
    omit?: BlogArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogArticleInclude<ExtArgs> | null
    where?: BlogArticleWhereInput
    orderBy?: BlogArticleOrderByWithRelationInput | BlogArticleOrderByWithRelationInput[]
    cursor?: BlogArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogArticleScalarFieldEnum | BlogArticleScalarFieldEnum[]
  }

  /**
   * User.Inspection
   */
  export type User$InspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * User.Invoice
   */
  export type User$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.LeaseGeneratorUsage
   */
  export type User$LeaseGeneratorUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaseGeneratorUsage
     */
    select?: LeaseGeneratorUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaseGeneratorUsage
     */
    omit?: LeaseGeneratorUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseGeneratorUsageInclude<ExtArgs> | null
    where?: LeaseGeneratorUsageWhereInput
    orderBy?: LeaseGeneratorUsageOrderByWithRelationInput | LeaseGeneratorUsageOrderByWithRelationInput[]
    cursor?: LeaseGeneratorUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaseGeneratorUsageScalarFieldEnum | LeaseGeneratorUsageScalarFieldEnum[]
  }

  /**
   * User.Message_Message_receiverIdToUser
   */
  export type User$Message_Message_receiverIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Message_Message_senderIdToUser
   */
  export type User$Message_Message_senderIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Property
   */
  export type User$PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.Subscription
   */
  export type User$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.Tenant
   */
  export type User$TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.reminders
   */
  export type User$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    where?: ReminderLogWhereInput
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    cursor?: ReminderLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderLogScalarFieldEnum | ReminderLogScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.featureAccess
   */
  export type User$featureAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    where?: UserFeatureAccessWhereInput
  }

  /**
   * User.accessLogs
   */
  export type User$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    where?: UserAccessLogWhereInput
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    cursor?: UserAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * User.notificationLogs
   */
  export type User$notificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * User.uploadedFiles
   */
  export type User$uploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenId: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    userAgent: string | null
    ipAddress: string | null
    isActive: boolean | null
    invalidatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshTokenId: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    userAgent: string | null
    ipAddress: string | null
    isActive: boolean | null
    invalidatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshTokenId: number
    expiresAt: number
    lastActivity: number
    userAgent: number
    ipAddress: number
    isActive: number
    invalidatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    expiresAt?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    isActive?: true
    invalidatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    expiresAt?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    isActive?: true
    invalidatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshTokenId?: true
    expiresAt?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    isActive?: true
    invalidatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    refreshTokenId: string
    expiresAt: Date
    lastActivity: Date
    userAgent: string | null
    ipAddress: string | null
    isActive: boolean
    invalidatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isActive?: boolean
    invalidatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isActive?: boolean
    invalidatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isActive?: boolean
    invalidatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshTokenId?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    isActive?: boolean
    invalidatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshTokenId" | "expiresAt" | "lastActivity" | "userAgent" | "ipAddress" | "isActive" | "invalidatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshTokenId: string
      expiresAt: Date
      lastActivity: Date
      userAgent: string | null
      ipAddress: string | null
      isActive: boolean
      invalidatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly refreshTokenId: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly lastActivity: FieldRef<"UserSession", 'DateTime'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly invalidatedAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model SecurityAuditLog
   */

  export type AggregateSecurityAuditLog = {
    _count: SecurityAuditLogCountAggregateOutputType | null
    _min: SecurityAuditLogMinAggregateOutputType | null
    _max: SecurityAuditLogMaxAggregateOutputType | null
  }

  export type SecurityAuditLogMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    severity: string | null
    userId: string | null
    email: string | null
    ipAddress: string | null
    userAgent: string | null
    resource: string | null
    action: string | null
    timestamp: Date | null
  }

  export type SecurityAuditLogMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    severity: string | null
    userId: string | null
    email: string | null
    ipAddress: string | null
    userAgent: string | null
    resource: string | null
    action: string | null
    timestamp: Date | null
  }

  export type SecurityAuditLogCountAggregateOutputType = {
    id: number
    eventType: number
    severity: number
    userId: number
    email: number
    ipAddress: number
    userAgent: number
    resource: number
    action: number
    details: number
    timestamp: number
    _all: number
  }


  export type SecurityAuditLogMinAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    resource?: true
    action?: true
    timestamp?: true
  }

  export type SecurityAuditLogMaxAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    resource?: true
    action?: true
    timestamp?: true
  }

  export type SecurityAuditLogCountAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    userId?: true
    email?: true
    ipAddress?: true
    userAgent?: true
    resource?: true
    action?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type SecurityAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAuditLog to aggregate.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityAuditLogs
    **/
    _count?: true | SecurityAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityAuditLogMaxAggregateInputType
  }

  export type GetSecurityAuditLogAggregateType<T extends SecurityAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityAuditLog[P]>
      : GetScalarType<T[P], AggregateSecurityAuditLog[P]>
  }




  export type SecurityAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAuditLogWhereInput
    orderBy?: SecurityAuditLogOrderByWithAggregationInput | SecurityAuditLogOrderByWithAggregationInput[]
    by: SecurityAuditLogScalarFieldEnum[] | SecurityAuditLogScalarFieldEnum
    having?: SecurityAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityAuditLogCountAggregateInputType | true
    _min?: SecurityAuditLogMinAggregateInputType
    _max?: SecurityAuditLogMaxAggregateInputType
  }

  export type SecurityAuditLogGroupByOutputType = {
    id: string
    eventType: string
    severity: string
    userId: string | null
    email: string | null
    ipAddress: string | null
    userAgent: string | null
    resource: string | null
    action: string | null
    details: JsonValue
    timestamp: Date
    _count: SecurityAuditLogCountAggregateOutputType | null
    _min: SecurityAuditLogMinAggregateOutputType | null
    _max: SecurityAuditLogMaxAggregateOutputType | null
  }

  type GetSecurityAuditLogGroupByPayload<T extends SecurityAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type SecurityAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    resource?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    resource?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    resource?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectScalar = {
    id?: boolean
    eventType?: boolean
    severity?: boolean
    userId?: boolean
    email?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    resource?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type SecurityAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "severity" | "userId" | "email" | "ipAddress" | "userAgent" | "resource" | "action" | "details" | "timestamp", ExtArgs["result"]["securityAuditLog"]>

  export type $SecurityAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      severity: string
      userId: string | null
      email: string | null
      ipAddress: string | null
      userAgent: string | null
      resource: string | null
      action: string | null
      details: Prisma.JsonValue
      timestamp: Date
    }, ExtArgs["result"]["securityAuditLog"]>
    composites: {}
  }

  type SecurityAuditLogGetPayload<S extends boolean | null | undefined | SecurityAuditLogDefaultArgs> = $Result.GetResult<Prisma.$SecurityAuditLogPayload, S>

  type SecurityAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityAuditLogCountAggregateInputType | true
    }

  export interface SecurityAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityAuditLog'], meta: { name: 'SecurityAuditLog' } }
    /**
     * Find zero or one SecurityAuditLog that matches the filter.
     * @param {SecurityAuditLogFindUniqueArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityAuditLogFindUniqueArgs>(args: SelectSubset<T, SecurityAuditLogFindUniqueArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityAuditLogFindUniqueOrThrowArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindFirstArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityAuditLogFindFirstArgs>(args?: SelectSubset<T, SecurityAuditLogFindFirstArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindFirstOrThrowArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityAuditLogs
     * const securityAuditLogs = await prisma.securityAuditLog.findMany()
     * 
     * // Get first 10 SecurityAuditLogs
     * const securityAuditLogs = await prisma.securityAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityAuditLogFindManyArgs>(args?: SelectSubset<T, SecurityAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityAuditLog.
     * @param {SecurityAuditLogCreateArgs} args - Arguments to create a SecurityAuditLog.
     * @example
     * // Create one SecurityAuditLog
     * const SecurityAuditLog = await prisma.securityAuditLog.create({
     *   data: {
     *     // ... data to create a SecurityAuditLog
     *   }
     * })
     * 
     */
    create<T extends SecurityAuditLogCreateArgs>(args: SelectSubset<T, SecurityAuditLogCreateArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityAuditLogs.
     * @param {SecurityAuditLogCreateManyArgs} args - Arguments to create many SecurityAuditLogs.
     * @example
     * // Create many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityAuditLogCreateManyArgs>(args?: SelectSubset<T, SecurityAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityAuditLogs and returns the data saved in the database.
     * @param {SecurityAuditLogCreateManyAndReturnArgs} args - Arguments to create many SecurityAuditLogs.
     * @example
     * // Create many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityAuditLogs and only return the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityAuditLog.
     * @param {SecurityAuditLogDeleteArgs} args - Arguments to delete one SecurityAuditLog.
     * @example
     * // Delete one SecurityAuditLog
     * const SecurityAuditLog = await prisma.securityAuditLog.delete({
     *   where: {
     *     // ... filter to delete one SecurityAuditLog
     *   }
     * })
     * 
     */
    delete<T extends SecurityAuditLogDeleteArgs>(args: SelectSubset<T, SecurityAuditLogDeleteArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityAuditLog.
     * @param {SecurityAuditLogUpdateArgs} args - Arguments to update one SecurityAuditLog.
     * @example
     * // Update one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityAuditLogUpdateArgs>(args: SelectSubset<T, SecurityAuditLogUpdateArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityAuditLogs.
     * @param {SecurityAuditLogDeleteManyArgs} args - Arguments to filter SecurityAuditLogs to delete.
     * @example
     * // Delete a few SecurityAuditLogs
     * const { count } = await prisma.securityAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityAuditLogDeleteManyArgs>(args?: SelectSubset<T, SecurityAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityAuditLogUpdateManyArgs>(args: SelectSubset<T, SecurityAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAuditLogs and returns the data updated in the database.
     * @param {SecurityAuditLogUpdateManyAndReturnArgs} args - Arguments to update many SecurityAuditLogs.
     * @example
     * // Update many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityAuditLogs and only return the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityAuditLog.
     * @param {SecurityAuditLogUpsertArgs} args - Arguments to update or create a SecurityAuditLog.
     * @example
     * // Update or create a SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.upsert({
     *   create: {
     *     // ... data to create a SecurityAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends SecurityAuditLogUpsertArgs>(args: SelectSubset<T, SecurityAuditLogUpsertArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogCountArgs} args - Arguments to filter SecurityAuditLogs to count.
     * @example
     * // Count the number of SecurityAuditLogs
     * const count = await prisma.securityAuditLog.count({
     *   where: {
     *     // ... the filter for the SecurityAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends SecurityAuditLogCountArgs>(
      args?: Subset<T, SecurityAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityAuditLogAggregateArgs>(args: Subset<T, SecurityAuditLogAggregateArgs>): Prisma.PrismaPromise<GetSecurityAuditLogAggregateType<T>>

    /**
     * Group by SecurityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: SecurityAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityAuditLog model
   */
  readonly fields: SecurityAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityAuditLog model
   */
  interface SecurityAuditLogFieldRefs {
    readonly id: FieldRef<"SecurityAuditLog", 'String'>
    readonly eventType: FieldRef<"SecurityAuditLog", 'String'>
    readonly severity: FieldRef<"SecurityAuditLog", 'String'>
    readonly userId: FieldRef<"SecurityAuditLog", 'String'>
    readonly email: FieldRef<"SecurityAuditLog", 'String'>
    readonly ipAddress: FieldRef<"SecurityAuditLog", 'String'>
    readonly userAgent: FieldRef<"SecurityAuditLog", 'String'>
    readonly resource: FieldRef<"SecurityAuditLog", 'String'>
    readonly action: FieldRef<"SecurityAuditLog", 'String'>
    readonly details: FieldRef<"SecurityAuditLog", 'Json'>
    readonly timestamp: FieldRef<"SecurityAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityAuditLog findUnique
   */
  export type SecurityAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog findUniqueOrThrow
   */
  export type SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog findFirst
   */
  export type SecurityAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAuditLogs.
     */
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog findFirstOrThrow
   */
  export type SecurityAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityAuditLogs.
     */
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog findMany
   */
  export type SecurityAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLogs to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog create
   */
  export type SecurityAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityAuditLog.
     */
    data: XOR<SecurityAuditLogCreateInput, SecurityAuditLogUncheckedCreateInput>
  }

  /**
   * SecurityAuditLog createMany
   */
  export type SecurityAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityAuditLogs.
     */
    data: SecurityAuditLogCreateManyInput | SecurityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAuditLog createManyAndReturn
   */
  export type SecurityAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityAuditLogs.
     */
    data: SecurityAuditLogCreateManyInput | SecurityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAuditLog update
   */
  export type SecurityAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityAuditLog.
     */
    data: XOR<SecurityAuditLogUpdateInput, SecurityAuditLogUncheckedUpdateInput>
    /**
     * Choose, which SecurityAuditLog to update.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog updateMany
   */
  export type SecurityAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityAuditLogs.
     */
    data: XOR<SecurityAuditLogUpdateManyMutationInput, SecurityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAuditLogs to update
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog updateManyAndReturn
   */
  export type SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update SecurityAuditLogs.
     */
    data: XOR<SecurityAuditLogUpdateManyMutationInput, SecurityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAuditLogs to update
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog upsert
   */
  export type SecurityAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityAuditLog to update in case it exists.
     */
    where: SecurityAuditLogWhereUniqueInput
    /**
     * In case the SecurityAuditLog found by the `where` argument doesn't exist, create a new SecurityAuditLog with this data.
     */
    create: XOR<SecurityAuditLogCreateInput, SecurityAuditLogUncheckedCreateInput>
    /**
     * In case the SecurityAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityAuditLogUpdateInput, SecurityAuditLogUncheckedUpdateInput>
  }

  /**
   * SecurityAuditLog delete
   */
  export type SecurityAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter which SecurityAuditLog to delete.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog deleteMany
   */
  export type SecurityAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAuditLogs to delete
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog without action
   */
  export type SecurityAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model wrappers_fdw_stats
   */

  export type AggregateWrappers_fdw_stats = {
    _count: Wrappers_fdw_statsCountAggregateOutputType | null
    _avg: Wrappers_fdw_statsAvgAggregateOutputType | null
    _sum: Wrappers_fdw_statsSumAggregateOutputType | null
    _min: Wrappers_fdw_statsMinAggregateOutputType | null
    _max: Wrappers_fdw_statsMaxAggregateOutputType | null
  }

  export type Wrappers_fdw_statsAvgAggregateOutputType = {
    create_times: number | null
    rows_in: number | null
    rows_out: number | null
    bytes_in: number | null
    bytes_out: number | null
  }

  export type Wrappers_fdw_statsSumAggregateOutputType = {
    create_times: bigint | null
    rows_in: bigint | null
    rows_out: bigint | null
    bytes_in: bigint | null
    bytes_out: bigint | null
  }

  export type Wrappers_fdw_statsMinAggregateOutputType = {
    fdw_name: string | null
    create_times: bigint | null
    rows_in: bigint | null
    rows_out: bigint | null
    bytes_in: bigint | null
    bytes_out: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Wrappers_fdw_statsMaxAggregateOutputType = {
    fdw_name: string | null
    create_times: bigint | null
    rows_in: bigint | null
    rows_out: bigint | null
    bytes_in: bigint | null
    bytes_out: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Wrappers_fdw_statsCountAggregateOutputType = {
    fdw_name: number
    create_times: number
    rows_in: number
    rows_out: number
    bytes_in: number
    bytes_out: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Wrappers_fdw_statsAvgAggregateInputType = {
    create_times?: true
    rows_in?: true
    rows_out?: true
    bytes_in?: true
    bytes_out?: true
  }

  export type Wrappers_fdw_statsSumAggregateInputType = {
    create_times?: true
    rows_in?: true
    rows_out?: true
    bytes_in?: true
    bytes_out?: true
  }

  export type Wrappers_fdw_statsMinAggregateInputType = {
    fdw_name?: true
    create_times?: true
    rows_in?: true
    rows_out?: true
    bytes_in?: true
    bytes_out?: true
    created_at?: true
    updated_at?: true
  }

  export type Wrappers_fdw_statsMaxAggregateInputType = {
    fdw_name?: true
    create_times?: true
    rows_in?: true
    rows_out?: true
    bytes_in?: true
    bytes_out?: true
    created_at?: true
    updated_at?: true
  }

  export type Wrappers_fdw_statsCountAggregateInputType = {
    fdw_name?: true
    create_times?: true
    rows_in?: true
    rows_out?: true
    bytes_in?: true
    bytes_out?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Wrappers_fdw_statsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wrappers_fdw_stats to aggregate.
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wrappers_fdw_stats to fetch.
     */
    orderBy?: wrappers_fdw_statsOrderByWithRelationInput | wrappers_fdw_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wrappers_fdw_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wrappers_fdw_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wrappers_fdw_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wrappers_fdw_stats
    **/
    _count?: true | Wrappers_fdw_statsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wrappers_fdw_statsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wrappers_fdw_statsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wrappers_fdw_statsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wrappers_fdw_statsMaxAggregateInputType
  }

  export type GetWrappers_fdw_statsAggregateType<T extends Wrappers_fdw_statsAggregateArgs> = {
        [P in keyof T & keyof AggregateWrappers_fdw_stats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWrappers_fdw_stats[P]>
      : GetScalarType<T[P], AggregateWrappers_fdw_stats[P]>
  }




  export type wrappers_fdw_statsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wrappers_fdw_statsWhereInput
    orderBy?: wrappers_fdw_statsOrderByWithAggregationInput | wrappers_fdw_statsOrderByWithAggregationInput[]
    by: Wrappers_fdw_statsScalarFieldEnum[] | Wrappers_fdw_statsScalarFieldEnum
    having?: wrappers_fdw_statsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wrappers_fdw_statsCountAggregateInputType | true
    _avg?: Wrappers_fdw_statsAvgAggregateInputType
    _sum?: Wrappers_fdw_statsSumAggregateInputType
    _min?: Wrappers_fdw_statsMinAggregateInputType
    _max?: Wrappers_fdw_statsMaxAggregateInputType
  }

  export type Wrappers_fdw_statsGroupByOutputType = {
    fdw_name: string
    create_times: bigint | null
    rows_in: bigint | null
    rows_out: bigint | null
    bytes_in: bigint | null
    bytes_out: bigint | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: Wrappers_fdw_statsCountAggregateOutputType | null
    _avg: Wrappers_fdw_statsAvgAggregateOutputType | null
    _sum: Wrappers_fdw_statsSumAggregateOutputType | null
    _min: Wrappers_fdw_statsMinAggregateOutputType | null
    _max: Wrappers_fdw_statsMaxAggregateOutputType | null
  }

  type GetWrappers_fdw_statsGroupByPayload<T extends wrappers_fdw_statsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wrappers_fdw_statsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wrappers_fdw_statsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wrappers_fdw_statsGroupByOutputType[P]>
            : GetScalarType<T[P], Wrappers_fdw_statsGroupByOutputType[P]>
        }
      >
    >


  export type wrappers_fdw_statsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fdw_name?: boolean
    create_times?: boolean
    rows_in?: boolean
    rows_out?: boolean
    bytes_in?: boolean
    bytes_out?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["wrappers_fdw_stats"]>

  export type wrappers_fdw_statsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fdw_name?: boolean
    create_times?: boolean
    rows_in?: boolean
    rows_out?: boolean
    bytes_in?: boolean
    bytes_out?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["wrappers_fdw_stats"]>

  export type wrappers_fdw_statsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fdw_name?: boolean
    create_times?: boolean
    rows_in?: boolean
    rows_out?: boolean
    bytes_in?: boolean
    bytes_out?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["wrappers_fdw_stats"]>

  export type wrappers_fdw_statsSelectScalar = {
    fdw_name?: boolean
    create_times?: boolean
    rows_in?: boolean
    rows_out?: boolean
    bytes_in?: boolean
    bytes_out?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type wrappers_fdw_statsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"fdw_name" | "create_times" | "rows_in" | "rows_out" | "bytes_in" | "bytes_out" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["wrappers_fdw_stats"]>

  export type $wrappers_fdw_statsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wrappers_fdw_stats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      fdw_name: string
      create_times: bigint | null
      rows_in: bigint | null
      rows_out: bigint | null
      bytes_in: bigint | null
      bytes_out: bigint | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["wrappers_fdw_stats"]>
    composites: {}
  }

  type wrappers_fdw_statsGetPayload<S extends boolean | null | undefined | wrappers_fdw_statsDefaultArgs> = $Result.GetResult<Prisma.$wrappers_fdw_statsPayload, S>

  type wrappers_fdw_statsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wrappers_fdw_statsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wrappers_fdw_statsCountAggregateInputType | true
    }

  export interface wrappers_fdw_statsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wrappers_fdw_stats'], meta: { name: 'wrappers_fdw_stats' } }
    /**
     * Find zero or one Wrappers_fdw_stats that matches the filter.
     * @param {wrappers_fdw_statsFindUniqueArgs} args - Arguments to find a Wrappers_fdw_stats
     * @example
     * // Get one Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wrappers_fdw_statsFindUniqueArgs>(args: SelectSubset<T, wrappers_fdw_statsFindUniqueArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wrappers_fdw_stats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wrappers_fdw_statsFindUniqueOrThrowArgs} args - Arguments to find a Wrappers_fdw_stats
     * @example
     * // Get one Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wrappers_fdw_statsFindUniqueOrThrowArgs>(args: SelectSubset<T, wrappers_fdw_statsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wrappers_fdw_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsFindFirstArgs} args - Arguments to find a Wrappers_fdw_stats
     * @example
     * // Get one Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wrappers_fdw_statsFindFirstArgs>(args?: SelectSubset<T, wrappers_fdw_statsFindFirstArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wrappers_fdw_stats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsFindFirstOrThrowArgs} args - Arguments to find a Wrappers_fdw_stats
     * @example
     * // Get one Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wrappers_fdw_statsFindFirstOrThrowArgs>(args?: SelectSubset<T, wrappers_fdw_statsFindFirstOrThrowArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wrappers_fdw_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findMany()
     * 
     * // Get first 10 Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.findMany({ take: 10 })
     * 
     * // Only select the `fdw_name`
     * const wrappers_fdw_statsWithFdw_nameOnly = await prisma.wrappers_fdw_stats.findMany({ select: { fdw_name: true } })
     * 
     */
    findMany<T extends wrappers_fdw_statsFindManyArgs>(args?: SelectSubset<T, wrappers_fdw_statsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsCreateArgs} args - Arguments to create a Wrappers_fdw_stats.
     * @example
     * // Create one Wrappers_fdw_stats
     * const Wrappers_fdw_stats = await prisma.wrappers_fdw_stats.create({
     *   data: {
     *     // ... data to create a Wrappers_fdw_stats
     *   }
     * })
     * 
     */
    create<T extends wrappers_fdw_statsCreateArgs>(args: SelectSubset<T, wrappers_fdw_statsCreateArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsCreateManyArgs} args - Arguments to create many Wrappers_fdw_stats.
     * @example
     * // Create many Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wrappers_fdw_statsCreateManyArgs>(args?: SelectSubset<T, wrappers_fdw_statsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wrappers_fdw_stats and returns the data saved in the database.
     * @param {wrappers_fdw_statsCreateManyAndReturnArgs} args - Arguments to create many Wrappers_fdw_stats.
     * @example
     * // Create many Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wrappers_fdw_stats and only return the `fdw_name`
     * const wrappers_fdw_statsWithFdw_nameOnly = await prisma.wrappers_fdw_stats.createManyAndReturn({
     *   select: { fdw_name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wrappers_fdw_statsCreateManyAndReturnArgs>(args?: SelectSubset<T, wrappers_fdw_statsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsDeleteArgs} args - Arguments to delete one Wrappers_fdw_stats.
     * @example
     * // Delete one Wrappers_fdw_stats
     * const Wrappers_fdw_stats = await prisma.wrappers_fdw_stats.delete({
     *   where: {
     *     // ... filter to delete one Wrappers_fdw_stats
     *   }
     * })
     * 
     */
    delete<T extends wrappers_fdw_statsDeleteArgs>(args: SelectSubset<T, wrappers_fdw_statsDeleteArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsUpdateArgs} args - Arguments to update one Wrappers_fdw_stats.
     * @example
     * // Update one Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wrappers_fdw_statsUpdateArgs>(args: SelectSubset<T, wrappers_fdw_statsUpdateArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsDeleteManyArgs} args - Arguments to filter Wrappers_fdw_stats to delete.
     * @example
     * // Delete a few Wrappers_fdw_stats
     * const { count } = await prisma.wrappers_fdw_stats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wrappers_fdw_statsDeleteManyArgs>(args?: SelectSubset<T, wrappers_fdw_statsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wrappers_fdw_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wrappers_fdw_statsUpdateManyArgs>(args: SelectSubset<T, wrappers_fdw_statsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wrappers_fdw_stats and returns the data updated in the database.
     * @param {wrappers_fdw_statsUpdateManyAndReturnArgs} args - Arguments to update many Wrappers_fdw_stats.
     * @example
     * // Update many Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wrappers_fdw_stats and only return the `fdw_name`
     * const wrappers_fdw_statsWithFdw_nameOnly = await prisma.wrappers_fdw_stats.updateManyAndReturn({
     *   select: { fdw_name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends wrappers_fdw_statsUpdateManyAndReturnArgs>(args: SelectSubset<T, wrappers_fdw_statsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wrappers_fdw_stats.
     * @param {wrappers_fdw_statsUpsertArgs} args - Arguments to update or create a Wrappers_fdw_stats.
     * @example
     * // Update or create a Wrappers_fdw_stats
     * const wrappers_fdw_stats = await prisma.wrappers_fdw_stats.upsert({
     *   create: {
     *     // ... data to create a Wrappers_fdw_stats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wrappers_fdw_stats we want to update
     *   }
     * })
     */
    upsert<T extends wrappers_fdw_statsUpsertArgs>(args: SelectSubset<T, wrappers_fdw_statsUpsertArgs<ExtArgs>>): Prisma__wrappers_fdw_statsClient<$Result.GetResult<Prisma.$wrappers_fdw_statsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wrappers_fdw_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsCountArgs} args - Arguments to filter Wrappers_fdw_stats to count.
     * @example
     * // Count the number of Wrappers_fdw_stats
     * const count = await prisma.wrappers_fdw_stats.count({
     *   where: {
     *     // ... the filter for the Wrappers_fdw_stats we want to count
     *   }
     * })
    **/
    count<T extends wrappers_fdw_statsCountArgs>(
      args?: Subset<T, wrappers_fdw_statsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wrappers_fdw_statsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wrappers_fdw_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wrappers_fdw_statsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wrappers_fdw_statsAggregateArgs>(args: Subset<T, Wrappers_fdw_statsAggregateArgs>): Prisma.PrismaPromise<GetWrappers_fdw_statsAggregateType<T>>

    /**
     * Group by Wrappers_fdw_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wrappers_fdw_statsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wrappers_fdw_statsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wrappers_fdw_statsGroupByArgs['orderBy'] }
        : { orderBy?: wrappers_fdw_statsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wrappers_fdw_statsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWrappers_fdw_statsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wrappers_fdw_stats model
   */
  readonly fields: wrappers_fdw_statsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wrappers_fdw_stats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wrappers_fdw_statsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wrappers_fdw_stats model
   */
  interface wrappers_fdw_statsFieldRefs {
    readonly fdw_name: FieldRef<"wrappers_fdw_stats", 'String'>
    readonly create_times: FieldRef<"wrappers_fdw_stats", 'BigInt'>
    readonly rows_in: FieldRef<"wrappers_fdw_stats", 'BigInt'>
    readonly rows_out: FieldRef<"wrappers_fdw_stats", 'BigInt'>
    readonly bytes_in: FieldRef<"wrappers_fdw_stats", 'BigInt'>
    readonly bytes_out: FieldRef<"wrappers_fdw_stats", 'BigInt'>
    readonly metadata: FieldRef<"wrappers_fdw_stats", 'Json'>
    readonly created_at: FieldRef<"wrappers_fdw_stats", 'DateTime'>
    readonly updated_at: FieldRef<"wrappers_fdw_stats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wrappers_fdw_stats findUnique
   */
  export type wrappers_fdw_statsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter, which wrappers_fdw_stats to fetch.
     */
    where: wrappers_fdw_statsWhereUniqueInput
  }

  /**
   * wrappers_fdw_stats findUniqueOrThrow
   */
  export type wrappers_fdw_statsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter, which wrappers_fdw_stats to fetch.
     */
    where: wrappers_fdw_statsWhereUniqueInput
  }

  /**
   * wrappers_fdw_stats findFirst
   */
  export type wrappers_fdw_statsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter, which wrappers_fdw_stats to fetch.
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wrappers_fdw_stats to fetch.
     */
    orderBy?: wrappers_fdw_statsOrderByWithRelationInput | wrappers_fdw_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wrappers_fdw_stats.
     */
    cursor?: wrappers_fdw_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wrappers_fdw_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wrappers_fdw_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wrappers_fdw_stats.
     */
    distinct?: Wrappers_fdw_statsScalarFieldEnum | Wrappers_fdw_statsScalarFieldEnum[]
  }

  /**
   * wrappers_fdw_stats findFirstOrThrow
   */
  export type wrappers_fdw_statsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter, which wrappers_fdw_stats to fetch.
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wrappers_fdw_stats to fetch.
     */
    orderBy?: wrappers_fdw_statsOrderByWithRelationInput | wrappers_fdw_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wrappers_fdw_stats.
     */
    cursor?: wrappers_fdw_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wrappers_fdw_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wrappers_fdw_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wrappers_fdw_stats.
     */
    distinct?: Wrappers_fdw_statsScalarFieldEnum | Wrappers_fdw_statsScalarFieldEnum[]
  }

  /**
   * wrappers_fdw_stats findMany
   */
  export type wrappers_fdw_statsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter, which wrappers_fdw_stats to fetch.
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wrappers_fdw_stats to fetch.
     */
    orderBy?: wrappers_fdw_statsOrderByWithRelationInput | wrappers_fdw_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wrappers_fdw_stats.
     */
    cursor?: wrappers_fdw_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wrappers_fdw_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wrappers_fdw_stats.
     */
    skip?: number
    distinct?: Wrappers_fdw_statsScalarFieldEnum | Wrappers_fdw_statsScalarFieldEnum[]
  }

  /**
   * wrappers_fdw_stats create
   */
  export type wrappers_fdw_statsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * The data needed to create a wrappers_fdw_stats.
     */
    data: XOR<wrappers_fdw_statsCreateInput, wrappers_fdw_statsUncheckedCreateInput>
  }

  /**
   * wrappers_fdw_stats createMany
   */
  export type wrappers_fdw_statsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wrappers_fdw_stats.
     */
    data: wrappers_fdw_statsCreateManyInput | wrappers_fdw_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wrappers_fdw_stats createManyAndReturn
   */
  export type wrappers_fdw_statsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * The data used to create many wrappers_fdw_stats.
     */
    data: wrappers_fdw_statsCreateManyInput | wrappers_fdw_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wrappers_fdw_stats update
   */
  export type wrappers_fdw_statsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * The data needed to update a wrappers_fdw_stats.
     */
    data: XOR<wrappers_fdw_statsUpdateInput, wrappers_fdw_statsUncheckedUpdateInput>
    /**
     * Choose, which wrappers_fdw_stats to update.
     */
    where: wrappers_fdw_statsWhereUniqueInput
  }

  /**
   * wrappers_fdw_stats updateMany
   */
  export type wrappers_fdw_statsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wrappers_fdw_stats.
     */
    data: XOR<wrappers_fdw_statsUpdateManyMutationInput, wrappers_fdw_statsUncheckedUpdateManyInput>
    /**
     * Filter which wrappers_fdw_stats to update
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * Limit how many wrappers_fdw_stats to update.
     */
    limit?: number
  }

  /**
   * wrappers_fdw_stats updateManyAndReturn
   */
  export type wrappers_fdw_statsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * The data used to update wrappers_fdw_stats.
     */
    data: XOR<wrappers_fdw_statsUpdateManyMutationInput, wrappers_fdw_statsUncheckedUpdateManyInput>
    /**
     * Filter which wrappers_fdw_stats to update
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * Limit how many wrappers_fdw_stats to update.
     */
    limit?: number
  }

  /**
   * wrappers_fdw_stats upsert
   */
  export type wrappers_fdw_statsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * The filter to search for the wrappers_fdw_stats to update in case it exists.
     */
    where: wrappers_fdw_statsWhereUniqueInput
    /**
     * In case the wrappers_fdw_stats found by the `where` argument doesn't exist, create a new wrappers_fdw_stats with this data.
     */
    create: XOR<wrappers_fdw_statsCreateInput, wrappers_fdw_statsUncheckedCreateInput>
    /**
     * In case the wrappers_fdw_stats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wrappers_fdw_statsUpdateInput, wrappers_fdw_statsUncheckedUpdateInput>
  }

  /**
   * wrappers_fdw_stats delete
   */
  export type wrappers_fdw_statsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
    /**
     * Filter which wrappers_fdw_stats to delete.
     */
    where: wrappers_fdw_statsWhereUniqueInput
  }

  /**
   * wrappers_fdw_stats deleteMany
   */
  export type wrappers_fdw_statsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wrappers_fdw_stats to delete
     */
    where?: wrappers_fdw_statsWhereInput
    /**
     * Limit how many wrappers_fdw_stats to delete.
     */
    limit?: number
  }

  /**
   * wrappers_fdw_stats without action
   */
  export type wrappers_fdw_statsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wrappers_fdw_stats
     */
    select?: wrappers_fdw_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wrappers_fdw_stats
     */
    omit?: wrappers_fdw_statsOmit<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: $Enums.ActivityEntityType | null
    entityId: string | null
    entityName: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: $Enums.ActivityEntityType | null
    entityId: string | null
    entityName: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    entityName: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName: string | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "entityName" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: $Enums.ActivityEntityType
      entityId: string
      entityName: string | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly action: FieldRef<"Activity", 'String'>
    readonly entityType: FieldRef<"Activity", 'ActivityEntityType'>
    readonly entityId: FieldRef<"Activity", 'String'>
    readonly entityName: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _avg: WebhookEventAvgAggregateOutputType | null
    _sum: WebhookEventSumAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventAvgAggregateOutputType = {
    processingTime: number | null
    retryCount: number | null
  }

  export type WebhookEventSumAggregateOutputType = {
    processingTime: number | null
    retryCount: number | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    stripeEventId: string | null
    eventType: string | null
    processed: boolean | null
    processingTime: number | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    stripeEventId: string | null
    eventType: string | null
    processed: boolean | null
    processingTime: number | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    stripeEventId: number
    eventType: number
    processed: number
    processingTime: number
    errorMessage: number
    retryCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookEventAvgAggregateInputType = {
    processingTime?: true
    retryCount?: true
  }

  export type WebhookEventSumAggregateInputType = {
    processingTime?: true
    retryCount?: true
  }

  export type WebhookEventMinAggregateInputType = {
    id?: true
    stripeEventId?: true
    eventType?: true
    processed?: true
    processingTime?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    stripeEventId?: true
    eventType?: true
    processed?: true
    processingTime?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    stripeEventId?: true
    eventType?: true
    processed?: true
    processingTime?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _avg?: WebhookEventAvgAggregateInputType
    _sum?: WebhookEventSumAggregateInputType
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    stripeEventId: string
    eventType: string
    processed: boolean
    processingTime: number | null
    errorMessage: string | null
    retryCount: number
    createdAt: Date
    updatedAt: Date
    _count: WebhookEventCountAggregateOutputType | null
    _avg: WebhookEventAvgAggregateOutputType | null
    _sum: WebhookEventSumAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeEventId?: boolean
    eventType?: boolean
    processed?: boolean
    processingTime?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeEventId?: boolean
    eventType?: boolean
    processed?: boolean
    processingTime?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeEventId?: boolean
    eventType?: boolean
    processed?: boolean
    processingTime?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    stripeEventId?: boolean
    eventType?: boolean
    processed?: boolean
    processingTime?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stripeEventId" | "eventType" | "processed" | "processingTime" | "errorMessage" | "retryCount" | "createdAt" | "updatedAt", ExtArgs["result"]["webhookEvent"]>

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripeEventId: string
      eventType: string
      processed: boolean
      processingTime: number | null
      errorMessage: string | null
      retryCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents and returns the data updated in the database.
     * @param {WebhookEventUpdateManyAndReturnArgs} args - Arguments to update many WebhookEvents.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly stripeEventId: FieldRef<"WebhookEvent", 'String'>
    readonly eventType: FieldRef<"WebhookEvent", 'String'>
    readonly processed: FieldRef<"WebhookEvent", 'Boolean'>
    readonly processingTime: FieldRef<"WebhookEvent", 'Int'>
    readonly errorMessage: FieldRef<"WebhookEvent", 'String'>
    readonly retryCount: FieldRef<"WebhookEvent", 'Int'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent updateManyAndReturn
   */
  export type WebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
  }


  /**
   * Model ReminderLog
   */

  export type AggregateReminderLog = {
    _count: ReminderLogCountAggregateOutputType | null
    _avg: ReminderLogAvgAggregateOutputType | null
    _sum: ReminderLogSumAggregateOutputType | null
    _min: ReminderLogMinAggregateOutputType | null
    _max: ReminderLogMaxAggregateOutputType | null
  }

  export type ReminderLogAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type ReminderLogSumAggregateOutputType = {
    retryCount: number | null
  }

  export type ReminderLogMinAggregateOutputType = {
    id: string | null
    leaseId: string | null
    userId: string | null
    type: $Enums.ReminderType | null
    status: $Enums.ReminderStatus | null
    recipientEmail: string | null
    recipientName: string | null
    subject: string | null
    content: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderLogMaxAggregateOutputType = {
    id: string | null
    leaseId: string | null
    userId: string | null
    type: $Enums.ReminderType | null
    status: $Enums.ReminderStatus | null
    recipientEmail: string | null
    recipientName: string | null
    subject: string | null
    content: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderLogCountAggregateOutputType = {
    id: number
    leaseId: number
    userId: number
    type: number
    status: number
    recipientEmail: number
    recipientName: number
    subject: number
    content: number
    sentAt: number
    deliveredAt: number
    openedAt: number
    errorMessage: number
    retryCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReminderLogAvgAggregateInputType = {
    retryCount?: true
  }

  export type ReminderLogSumAggregateInputType = {
    retryCount?: true
  }

  export type ReminderLogMinAggregateInputType = {
    id?: true
    leaseId?: true
    userId?: true
    type?: true
    status?: true
    recipientEmail?: true
    recipientName?: true
    subject?: true
    content?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderLogMaxAggregateInputType = {
    id?: true
    leaseId?: true
    userId?: true
    type?: true
    status?: true
    recipientEmail?: true
    recipientName?: true
    subject?: true
    content?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderLogCountAggregateInputType = {
    id?: true
    leaseId?: true
    userId?: true
    type?: true
    status?: true
    recipientEmail?: true
    recipientName?: true
    subject?: true
    content?: true
    sentAt?: true
    deliveredAt?: true
    openedAt?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReminderLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderLog to aggregate.
     */
    where?: ReminderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderLogs to fetch.
     */
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReminderLogs
    **/
    _count?: true | ReminderLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReminderLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReminderLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderLogMaxAggregateInputType
  }

  export type GetReminderLogAggregateType<T extends ReminderLogAggregateArgs> = {
        [P in keyof T & keyof AggregateReminderLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminderLog[P]>
      : GetScalarType<T[P], AggregateReminderLog[P]>
  }




  export type ReminderLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderLogWhereInput
    orderBy?: ReminderLogOrderByWithAggregationInput | ReminderLogOrderByWithAggregationInput[]
    by: ReminderLogScalarFieldEnum[] | ReminderLogScalarFieldEnum
    having?: ReminderLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderLogCountAggregateInputType | true
    _avg?: ReminderLogAvgAggregateInputType
    _sum?: ReminderLogSumAggregateInputType
    _min?: ReminderLogMinAggregateInputType
    _max?: ReminderLogMaxAggregateInputType
  }

  export type ReminderLogGroupByOutputType = {
    id: string
    leaseId: string | null
    userId: string
    type: $Enums.ReminderType
    status: $Enums.ReminderStatus
    recipientEmail: string
    recipientName: string | null
    subject: string | null
    content: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    openedAt: Date | null
    errorMessage: string | null
    retryCount: number
    createdAt: Date
    updatedAt: Date
    _count: ReminderLogCountAggregateOutputType | null
    _avg: ReminderLogAvgAggregateOutputType | null
    _sum: ReminderLogSumAggregateOutputType | null
    _min: ReminderLogMinAggregateOutputType | null
    _max: ReminderLogMaxAggregateOutputType | null
  }

  type GetReminderLogGroupByPayload<T extends ReminderLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderLogGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderLogGroupByOutputType[P]>
        }
      >
    >


  export type ReminderLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    subject?: boolean
    content?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }, ExtArgs["result"]["reminderLog"]>

  export type ReminderLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    subject?: boolean
    content?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }, ExtArgs["result"]["reminderLog"]>

  export type ReminderLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leaseId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    subject?: boolean
    content?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }, ExtArgs["result"]["reminderLog"]>

  export type ReminderLogSelectScalar = {
    id?: boolean
    leaseId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    subject?: boolean
    content?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    openedAt?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReminderLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leaseId" | "userId" | "type" | "status" | "recipientEmail" | "recipientName" | "subject" | "content" | "sentAt" | "deliveredAt" | "openedAt" | "errorMessage" | "retryCount" | "createdAt" | "updatedAt", ExtArgs["result"]["reminderLog"]>
  export type ReminderLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }
  export type ReminderLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }
  export type ReminderLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lease?: boolean | ReminderLog$LeaseArgs<ExtArgs>
  }

  export type $ReminderLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReminderLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Lease: Prisma.$LeasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leaseId: string | null
      userId: string
      type: $Enums.ReminderType
      status: $Enums.ReminderStatus
      recipientEmail: string
      recipientName: string | null
      subject: string | null
      content: string | null
      sentAt: Date | null
      deliveredAt: Date | null
      openedAt: Date | null
      errorMessage: string | null
      retryCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reminderLog"]>
    composites: {}
  }

  type ReminderLogGetPayload<S extends boolean | null | undefined | ReminderLogDefaultArgs> = $Result.GetResult<Prisma.$ReminderLogPayload, S>

  type ReminderLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReminderLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReminderLogCountAggregateInputType | true
    }

  export interface ReminderLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReminderLog'], meta: { name: 'ReminderLog' } }
    /**
     * Find zero or one ReminderLog that matches the filter.
     * @param {ReminderLogFindUniqueArgs} args - Arguments to find a ReminderLog
     * @example
     * // Get one ReminderLog
     * const reminderLog = await prisma.reminderLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderLogFindUniqueArgs>(args: SelectSubset<T, ReminderLogFindUniqueArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReminderLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReminderLogFindUniqueOrThrowArgs} args - Arguments to find a ReminderLog
     * @example
     * // Get one ReminderLog
     * const reminderLog = await prisma.reminderLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogFindFirstArgs} args - Arguments to find a ReminderLog
     * @example
     * // Get one ReminderLog
     * const reminderLog = await prisma.reminderLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderLogFindFirstArgs>(args?: SelectSubset<T, ReminderLogFindFirstArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogFindFirstOrThrowArgs} args - Arguments to find a ReminderLog
     * @example
     * // Get one ReminderLog
     * const reminderLog = await prisma.reminderLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReminderLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReminderLogs
     * const reminderLogs = await prisma.reminderLog.findMany()
     * 
     * // Get first 10 ReminderLogs
     * const reminderLogs = await prisma.reminderLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderLogWithIdOnly = await prisma.reminderLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderLogFindManyArgs>(args?: SelectSubset<T, ReminderLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReminderLog.
     * @param {ReminderLogCreateArgs} args - Arguments to create a ReminderLog.
     * @example
     * // Create one ReminderLog
     * const ReminderLog = await prisma.reminderLog.create({
     *   data: {
     *     // ... data to create a ReminderLog
     *   }
     * })
     * 
     */
    create<T extends ReminderLogCreateArgs>(args: SelectSubset<T, ReminderLogCreateArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReminderLogs.
     * @param {ReminderLogCreateManyArgs} args - Arguments to create many ReminderLogs.
     * @example
     * // Create many ReminderLogs
     * const reminderLog = await prisma.reminderLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderLogCreateManyArgs>(args?: SelectSubset<T, ReminderLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReminderLogs and returns the data saved in the database.
     * @param {ReminderLogCreateManyAndReturnArgs} args - Arguments to create many ReminderLogs.
     * @example
     * // Create many ReminderLogs
     * const reminderLog = await prisma.reminderLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReminderLogs and only return the `id`
     * const reminderLogWithIdOnly = await prisma.reminderLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReminderLog.
     * @param {ReminderLogDeleteArgs} args - Arguments to delete one ReminderLog.
     * @example
     * // Delete one ReminderLog
     * const ReminderLog = await prisma.reminderLog.delete({
     *   where: {
     *     // ... filter to delete one ReminderLog
     *   }
     * })
     * 
     */
    delete<T extends ReminderLogDeleteArgs>(args: SelectSubset<T, ReminderLogDeleteArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReminderLog.
     * @param {ReminderLogUpdateArgs} args - Arguments to update one ReminderLog.
     * @example
     * // Update one ReminderLog
     * const reminderLog = await prisma.reminderLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderLogUpdateArgs>(args: SelectSubset<T, ReminderLogUpdateArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReminderLogs.
     * @param {ReminderLogDeleteManyArgs} args - Arguments to filter ReminderLogs to delete.
     * @example
     * // Delete a few ReminderLogs
     * const { count } = await prisma.reminderLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderLogDeleteManyArgs>(args?: SelectSubset<T, ReminderLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReminderLogs
     * const reminderLog = await prisma.reminderLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderLogUpdateManyArgs>(args: SelectSubset<T, ReminderLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderLogs and returns the data updated in the database.
     * @param {ReminderLogUpdateManyAndReturnArgs} args - Arguments to update many ReminderLogs.
     * @example
     * // Update many ReminderLogs
     * const reminderLog = await prisma.reminderLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReminderLogs and only return the `id`
     * const reminderLogWithIdOnly = await prisma.reminderLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReminderLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ReminderLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReminderLog.
     * @param {ReminderLogUpsertArgs} args - Arguments to update or create a ReminderLog.
     * @example
     * // Update or create a ReminderLog
     * const reminderLog = await prisma.reminderLog.upsert({
     *   create: {
     *     // ... data to create a ReminderLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReminderLog we want to update
     *   }
     * })
     */
    upsert<T extends ReminderLogUpsertArgs>(args: SelectSubset<T, ReminderLogUpsertArgs<ExtArgs>>): Prisma__ReminderLogClient<$Result.GetResult<Prisma.$ReminderLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReminderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogCountArgs} args - Arguments to filter ReminderLogs to count.
     * @example
     * // Count the number of ReminderLogs
     * const count = await prisma.reminderLog.count({
     *   where: {
     *     // ... the filter for the ReminderLogs we want to count
     *   }
     * })
    **/
    count<T extends ReminderLogCountArgs>(
      args?: Subset<T, ReminderLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReminderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderLogAggregateArgs>(args: Subset<T, ReminderLogAggregateArgs>): Prisma.PrismaPromise<GetReminderLogAggregateType<T>>

    /**
     * Group by ReminderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderLogGroupByArgs['orderBy'] }
        : { orderBy?: ReminderLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReminderLog model
   */
  readonly fields: ReminderLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReminderLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Lease<T extends ReminderLog$LeaseArgs<ExtArgs> = {}>(args?: Subset<T, ReminderLog$LeaseArgs<ExtArgs>>): Prisma__LeaseClient<$Result.GetResult<Prisma.$LeasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReminderLog model
   */
  interface ReminderLogFieldRefs {
    readonly id: FieldRef<"ReminderLog", 'String'>
    readonly leaseId: FieldRef<"ReminderLog", 'String'>
    readonly userId: FieldRef<"ReminderLog", 'String'>
    readonly type: FieldRef<"ReminderLog", 'ReminderType'>
    readonly status: FieldRef<"ReminderLog", 'ReminderStatus'>
    readonly recipientEmail: FieldRef<"ReminderLog", 'String'>
    readonly recipientName: FieldRef<"ReminderLog", 'String'>
    readonly subject: FieldRef<"ReminderLog", 'String'>
    readonly content: FieldRef<"ReminderLog", 'String'>
    readonly sentAt: FieldRef<"ReminderLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"ReminderLog", 'DateTime'>
    readonly openedAt: FieldRef<"ReminderLog", 'DateTime'>
    readonly errorMessage: FieldRef<"ReminderLog", 'String'>
    readonly retryCount: FieldRef<"ReminderLog", 'Int'>
    readonly createdAt: FieldRef<"ReminderLog", 'DateTime'>
    readonly updatedAt: FieldRef<"ReminderLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReminderLog findUnique
   */
  export type ReminderLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter, which ReminderLog to fetch.
     */
    where: ReminderLogWhereUniqueInput
  }

  /**
   * ReminderLog findUniqueOrThrow
   */
  export type ReminderLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter, which ReminderLog to fetch.
     */
    where: ReminderLogWhereUniqueInput
  }

  /**
   * ReminderLog findFirst
   */
  export type ReminderLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter, which ReminderLog to fetch.
     */
    where?: ReminderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderLogs to fetch.
     */
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderLogs.
     */
    cursor?: ReminderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderLogs.
     */
    distinct?: ReminderLogScalarFieldEnum | ReminderLogScalarFieldEnum[]
  }

  /**
   * ReminderLog findFirstOrThrow
   */
  export type ReminderLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter, which ReminderLog to fetch.
     */
    where?: ReminderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderLogs to fetch.
     */
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderLogs.
     */
    cursor?: ReminderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderLogs.
     */
    distinct?: ReminderLogScalarFieldEnum | ReminderLogScalarFieldEnum[]
  }

  /**
   * ReminderLog findMany
   */
  export type ReminderLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter, which ReminderLogs to fetch.
     */
    where?: ReminderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderLogs to fetch.
     */
    orderBy?: ReminderLogOrderByWithRelationInput | ReminderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReminderLogs.
     */
    cursor?: ReminderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderLogs.
     */
    skip?: number
    distinct?: ReminderLogScalarFieldEnum | ReminderLogScalarFieldEnum[]
  }

  /**
   * ReminderLog create
   */
  export type ReminderLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ReminderLog.
     */
    data: XOR<ReminderLogCreateInput, ReminderLogUncheckedCreateInput>
  }

  /**
   * ReminderLog createMany
   */
  export type ReminderLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReminderLogs.
     */
    data: ReminderLogCreateManyInput | ReminderLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReminderLog createManyAndReturn
   */
  export type ReminderLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * The data used to create many ReminderLogs.
     */
    data: ReminderLogCreateManyInput | ReminderLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderLog update
   */
  export type ReminderLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ReminderLog.
     */
    data: XOR<ReminderLogUpdateInput, ReminderLogUncheckedUpdateInput>
    /**
     * Choose, which ReminderLog to update.
     */
    where: ReminderLogWhereUniqueInput
  }

  /**
   * ReminderLog updateMany
   */
  export type ReminderLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReminderLogs.
     */
    data: XOR<ReminderLogUpdateManyMutationInput, ReminderLogUncheckedUpdateManyInput>
    /**
     * Filter which ReminderLogs to update
     */
    where?: ReminderLogWhereInput
    /**
     * Limit how many ReminderLogs to update.
     */
    limit?: number
  }

  /**
   * ReminderLog updateManyAndReturn
   */
  export type ReminderLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * The data used to update ReminderLogs.
     */
    data: XOR<ReminderLogUpdateManyMutationInput, ReminderLogUncheckedUpdateManyInput>
    /**
     * Filter which ReminderLogs to update
     */
    where?: ReminderLogWhereInput
    /**
     * Limit how many ReminderLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderLog upsert
   */
  export type ReminderLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ReminderLog to update in case it exists.
     */
    where: ReminderLogWhereUniqueInput
    /**
     * In case the ReminderLog found by the `where` argument doesn't exist, create a new ReminderLog with this data.
     */
    create: XOR<ReminderLogCreateInput, ReminderLogUncheckedCreateInput>
    /**
     * In case the ReminderLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderLogUpdateInput, ReminderLogUncheckedUpdateInput>
  }

  /**
   * ReminderLog delete
   */
  export type ReminderLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
    /**
     * Filter which ReminderLog to delete.
     */
    where: ReminderLogWhereUniqueInput
  }

  /**
   * ReminderLog deleteMany
   */
  export type ReminderLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderLogs to delete
     */
    where?: ReminderLogWhereInput
    /**
     * Limit how many ReminderLogs to delete.
     */
    limit?: number
  }

  /**
   * ReminderLog.Lease
   */
  export type ReminderLog$LeaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lease
     */
    select?: LeaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lease
     */
    omit?: LeaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaseInclude<ExtArgs> | null
    where?: LeaseWhereInput
  }

  /**
   * ReminderLog without action
   */
  export type ReminderLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderLog
     */
    select?: ReminderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderLog
     */
    omit?: ReminderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderLogInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    daysBeforeDue: number | null
    overdueGracePeriod: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    daysBeforeDue: number | null
    overdueGracePeriod: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    enableReminders: boolean | null
    daysBeforeDue: number | null
    enableOverdueReminders: boolean | null
    overdueGracePeriod: number | null
    autoSendReminders: boolean | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    defaultDashboardView: string | null
    showWelcomeMessage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    enableReminders: boolean | null
    daysBeforeDue: number | null
    enableOverdueReminders: boolean | null
    overdueGracePeriod: number | null
    autoSendReminders: boolean | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    defaultDashboardView: string | null
    showWelcomeMessage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    enableReminders: number
    daysBeforeDue: number
    enableOverdueReminders: number
    overdueGracePeriod: number
    autoSendReminders: number
    emailNotifications: number
    smsNotifications: number
    pushNotifications: number
    defaultDashboardView: number
    showWelcomeMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    daysBeforeDue?: true
    overdueGracePeriod?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    daysBeforeDue?: true
    overdueGracePeriod?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    enableReminders?: true
    daysBeforeDue?: true
    enableOverdueReminders?: true
    overdueGracePeriod?: true
    autoSendReminders?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    defaultDashboardView?: true
    showWelcomeMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    enableReminders?: true
    daysBeforeDue?: true
    enableOverdueReminders?: true
    overdueGracePeriod?: true
    autoSendReminders?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    defaultDashboardView?: true
    showWelcomeMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    enableReminders?: true
    daysBeforeDue?: true
    enableOverdueReminders?: true
    overdueGracePeriod?: true
    autoSendReminders?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    defaultDashboardView?: true
    showWelcomeMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    enableReminders: boolean
    daysBeforeDue: number
    enableOverdueReminders: boolean
    overdueGracePeriod: number
    autoSendReminders: boolean
    emailNotifications: boolean
    smsNotifications: boolean
    pushNotifications: boolean
    defaultDashboardView: string
    showWelcomeMessage: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    enableReminders?: boolean
    daysBeforeDue?: boolean
    enableOverdueReminders?: boolean
    overdueGracePeriod?: boolean
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: boolean
    showWelcomeMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    enableReminders?: boolean
    daysBeforeDue?: boolean
    enableOverdueReminders?: boolean
    overdueGracePeriod?: boolean
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: boolean
    showWelcomeMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    enableReminders?: boolean
    daysBeforeDue?: boolean
    enableOverdueReminders?: boolean
    overdueGracePeriod?: boolean
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: boolean
    showWelcomeMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    enableReminders?: boolean
    daysBeforeDue?: boolean
    enableOverdueReminders?: boolean
    overdueGracePeriod?: boolean
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: boolean
    showWelcomeMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "enableReminders" | "daysBeforeDue" | "enableOverdueReminders" | "overdueGracePeriod" | "autoSendReminders" | "emailNotifications" | "smsNotifications" | "pushNotifications" | "defaultDashboardView" | "showWelcomeMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      enableReminders: boolean
      daysBeforeDue: number
      enableOverdueReminders: boolean
      overdueGracePeriod: number
      autoSendReminders: boolean
      emailNotifications: boolean
      smsNotifications: boolean
      pushNotifications: boolean
      defaultDashboardView: string
      showWelcomeMessage: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly enableReminders: FieldRef<"UserPreferences", 'Boolean'>
    readonly daysBeforeDue: FieldRef<"UserPreferences", 'Int'>
    readonly enableOverdueReminders: FieldRef<"UserPreferences", 'Boolean'>
    readonly overdueGracePeriod: FieldRef<"UserPreferences", 'Int'>
    readonly autoSendReminders: FieldRef<"UserPreferences", 'Boolean'>
    readonly emailNotifications: FieldRef<"UserPreferences", 'Boolean'>
    readonly smsNotifications: FieldRef<"UserPreferences", 'Boolean'>
    readonly pushNotifications: FieldRef<"UserPreferences", 'Boolean'>
    readonly defaultDashboardView: FieldRef<"UserPreferences", 'String'>
    readonly showWelcomeMessage: FieldRef<"UserPreferences", 'Boolean'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserFeatureAccess
   */

  export type AggregateUserFeatureAccess = {
    _count: UserFeatureAccessCountAggregateOutputType | null
    _avg: UserFeatureAccessAvgAggregateOutputType | null
    _sum: UserFeatureAccessSumAggregateOutputType | null
    _min: UserFeatureAccessMinAggregateOutputType | null
    _max: UserFeatureAccessMaxAggregateOutputType | null
  }

  export type UserFeatureAccessAvgAggregateOutputType = {
    maxProperties: number | null
    maxUnitsPerProperty: number | null
    maxStorageGB: number | null
  }

  export type UserFeatureAccessSumAggregateOutputType = {
    maxProperties: number | null
    maxUnitsPerProperty: number | null
    maxStorageGB: number | null
  }

  export type UserFeatureAccessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    canExportData: boolean | null
    canAccessAdvancedAnalytics: boolean | null
    canUseBulkOperations: boolean | null
    canAccessAPI: boolean | null
    canInviteTeamMembers: boolean | null
    maxProperties: number | null
    maxUnitsPerProperty: number | null
    maxStorageGB: number | null
    hasPrioritySupport: boolean | null
    canUsePremiumIntegrations: boolean | null
    lastUpdated: Date | null
    updateReason: string | null
    createdAt: Date | null
  }

  export type UserFeatureAccessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    canExportData: boolean | null
    canAccessAdvancedAnalytics: boolean | null
    canUseBulkOperations: boolean | null
    canAccessAPI: boolean | null
    canInviteTeamMembers: boolean | null
    maxProperties: number | null
    maxUnitsPerProperty: number | null
    maxStorageGB: number | null
    hasPrioritySupport: boolean | null
    canUsePremiumIntegrations: boolean | null
    lastUpdated: Date | null
    updateReason: string | null
    createdAt: Date | null
  }

  export type UserFeatureAccessCountAggregateOutputType = {
    id: number
    userId: number
    canExportData: number
    canAccessAdvancedAnalytics: number
    canUseBulkOperations: number
    canAccessAPI: number
    canInviteTeamMembers: number
    maxProperties: number
    maxUnitsPerProperty: number
    maxStorageGB: number
    hasPrioritySupport: number
    canUsePremiumIntegrations: number
    lastUpdated: number
    updateReason: number
    createdAt: number
    _all: number
  }


  export type UserFeatureAccessAvgAggregateInputType = {
    maxProperties?: true
    maxUnitsPerProperty?: true
    maxStorageGB?: true
  }

  export type UserFeatureAccessSumAggregateInputType = {
    maxProperties?: true
    maxUnitsPerProperty?: true
    maxStorageGB?: true
  }

  export type UserFeatureAccessMinAggregateInputType = {
    id?: true
    userId?: true
    canExportData?: true
    canAccessAdvancedAnalytics?: true
    canUseBulkOperations?: true
    canAccessAPI?: true
    canInviteTeamMembers?: true
    maxProperties?: true
    maxUnitsPerProperty?: true
    maxStorageGB?: true
    hasPrioritySupport?: true
    canUsePremiumIntegrations?: true
    lastUpdated?: true
    updateReason?: true
    createdAt?: true
  }

  export type UserFeatureAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    canExportData?: true
    canAccessAdvancedAnalytics?: true
    canUseBulkOperations?: true
    canAccessAPI?: true
    canInviteTeamMembers?: true
    maxProperties?: true
    maxUnitsPerProperty?: true
    maxStorageGB?: true
    hasPrioritySupport?: true
    canUsePremiumIntegrations?: true
    lastUpdated?: true
    updateReason?: true
    createdAt?: true
  }

  export type UserFeatureAccessCountAggregateInputType = {
    id?: true
    userId?: true
    canExportData?: true
    canAccessAdvancedAnalytics?: true
    canUseBulkOperations?: true
    canAccessAPI?: true
    canInviteTeamMembers?: true
    maxProperties?: true
    maxUnitsPerProperty?: true
    maxStorageGB?: true
    hasPrioritySupport?: true
    canUsePremiumIntegrations?: true
    lastUpdated?: true
    updateReason?: true
    createdAt?: true
    _all?: true
  }

  export type UserFeatureAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureAccess to aggregate.
     */
    where?: UserFeatureAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureAccesses to fetch.
     */
    orderBy?: UserFeatureAccessOrderByWithRelationInput | UserFeatureAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeatureAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeatureAccesses
    **/
    _count?: true | UserFeatureAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFeatureAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFeatureAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeatureAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeatureAccessMaxAggregateInputType
  }

  export type GetUserFeatureAccessAggregateType<T extends UserFeatureAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeatureAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeatureAccess[P]>
      : GetScalarType<T[P], AggregateUserFeatureAccess[P]>
  }




  export type UserFeatureAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureAccessWhereInput
    orderBy?: UserFeatureAccessOrderByWithAggregationInput | UserFeatureAccessOrderByWithAggregationInput[]
    by: UserFeatureAccessScalarFieldEnum[] | UserFeatureAccessScalarFieldEnum
    having?: UserFeatureAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeatureAccessCountAggregateInputType | true
    _avg?: UserFeatureAccessAvgAggregateInputType
    _sum?: UserFeatureAccessSumAggregateInputType
    _min?: UserFeatureAccessMinAggregateInputType
    _max?: UserFeatureAccessMaxAggregateInputType
  }

  export type UserFeatureAccessGroupByOutputType = {
    id: string
    userId: string
    canExportData: boolean
    canAccessAdvancedAnalytics: boolean
    canUseBulkOperations: boolean
    canAccessAPI: boolean
    canInviteTeamMembers: boolean
    maxProperties: number
    maxUnitsPerProperty: number
    maxStorageGB: number
    hasPrioritySupport: boolean
    canUsePremiumIntegrations: boolean
    lastUpdated: Date
    updateReason: string | null
    createdAt: Date
    _count: UserFeatureAccessCountAggregateOutputType | null
    _avg: UserFeatureAccessAvgAggregateOutputType | null
    _sum: UserFeatureAccessSumAggregateOutputType | null
    _min: UserFeatureAccessMinAggregateOutputType | null
    _max: UserFeatureAccessMaxAggregateOutputType | null
  }

  type GetUserFeatureAccessGroupByPayload<T extends UserFeatureAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeatureAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeatureAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeatureAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeatureAccessGroupByOutputType[P]>
        }
      >
    >


  export type UserFeatureAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: boolean
    maxUnitsPerProperty?: boolean
    maxStorageGB?: boolean
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: boolean
    updateReason?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureAccess"]>

  export type UserFeatureAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: boolean
    maxUnitsPerProperty?: boolean
    maxStorageGB?: boolean
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: boolean
    updateReason?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureAccess"]>

  export type UserFeatureAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: boolean
    maxUnitsPerProperty?: boolean
    maxStorageGB?: boolean
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: boolean
    updateReason?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureAccess"]>

  export type UserFeatureAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: boolean
    maxUnitsPerProperty?: boolean
    maxStorageGB?: boolean
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: boolean
    updateReason?: boolean
    createdAt?: boolean
  }

  export type UserFeatureAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "canExportData" | "canAccessAdvancedAnalytics" | "canUseBulkOperations" | "canAccessAPI" | "canInviteTeamMembers" | "maxProperties" | "maxUnitsPerProperty" | "maxStorageGB" | "hasPrioritySupport" | "canUsePremiumIntegrations" | "lastUpdated" | "updateReason" | "createdAt", ExtArgs["result"]["userFeatureAccess"]>
  export type UserFeatureAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFeatureAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeatureAccess"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      canExportData: boolean
      canAccessAdvancedAnalytics: boolean
      canUseBulkOperations: boolean
      canAccessAPI: boolean
      canInviteTeamMembers: boolean
      maxProperties: number
      maxUnitsPerProperty: number
      maxStorageGB: number
      hasPrioritySupport: boolean
      canUsePremiumIntegrations: boolean
      lastUpdated: Date
      updateReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["userFeatureAccess"]>
    composites: {}
  }

  type UserFeatureAccessGetPayload<S extends boolean | null | undefined | UserFeatureAccessDefaultArgs> = $Result.GetResult<Prisma.$UserFeatureAccessPayload, S>

  type UserFeatureAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFeatureAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFeatureAccessCountAggregateInputType | true
    }

  export interface UserFeatureAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeatureAccess'], meta: { name: 'UserFeatureAccess' } }
    /**
     * Find zero or one UserFeatureAccess that matches the filter.
     * @param {UserFeatureAccessFindUniqueArgs} args - Arguments to find a UserFeatureAccess
     * @example
     * // Get one UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeatureAccessFindUniqueArgs>(args: SelectSubset<T, UserFeatureAccessFindUniqueArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFeatureAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFeatureAccessFindUniqueOrThrowArgs} args - Arguments to find a UserFeatureAccess
     * @example
     * // Get one UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeatureAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeatureAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessFindFirstArgs} args - Arguments to find a UserFeatureAccess
     * @example
     * // Get one UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeatureAccessFindFirstArgs>(args?: SelectSubset<T, UserFeatureAccessFindFirstArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessFindFirstOrThrowArgs} args - Arguments to find a UserFeatureAccess
     * @example
     * // Get one UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeatureAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeatureAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFeatureAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeatureAccesses
     * const userFeatureAccesses = await prisma.userFeatureAccess.findMany()
     * 
     * // Get first 10 UserFeatureAccesses
     * const userFeatureAccesses = await prisma.userFeatureAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeatureAccessWithIdOnly = await prisma.userFeatureAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeatureAccessFindManyArgs>(args?: SelectSubset<T, UserFeatureAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFeatureAccess.
     * @param {UserFeatureAccessCreateArgs} args - Arguments to create a UserFeatureAccess.
     * @example
     * // Create one UserFeatureAccess
     * const UserFeatureAccess = await prisma.userFeatureAccess.create({
     *   data: {
     *     // ... data to create a UserFeatureAccess
     *   }
     * })
     * 
     */
    create<T extends UserFeatureAccessCreateArgs>(args: SelectSubset<T, UserFeatureAccessCreateArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFeatureAccesses.
     * @param {UserFeatureAccessCreateManyArgs} args - Arguments to create many UserFeatureAccesses.
     * @example
     * // Create many UserFeatureAccesses
     * const userFeatureAccess = await prisma.userFeatureAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeatureAccessCreateManyArgs>(args?: SelectSubset<T, UserFeatureAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeatureAccesses and returns the data saved in the database.
     * @param {UserFeatureAccessCreateManyAndReturnArgs} args - Arguments to create many UserFeatureAccesses.
     * @example
     * // Create many UserFeatureAccesses
     * const userFeatureAccess = await prisma.userFeatureAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeatureAccesses and only return the `id`
     * const userFeatureAccessWithIdOnly = await prisma.userFeatureAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeatureAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeatureAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFeatureAccess.
     * @param {UserFeatureAccessDeleteArgs} args - Arguments to delete one UserFeatureAccess.
     * @example
     * // Delete one UserFeatureAccess
     * const UserFeatureAccess = await prisma.userFeatureAccess.delete({
     *   where: {
     *     // ... filter to delete one UserFeatureAccess
     *   }
     * })
     * 
     */
    delete<T extends UserFeatureAccessDeleteArgs>(args: SelectSubset<T, UserFeatureAccessDeleteArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFeatureAccess.
     * @param {UserFeatureAccessUpdateArgs} args - Arguments to update one UserFeatureAccess.
     * @example
     * // Update one UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeatureAccessUpdateArgs>(args: SelectSubset<T, UserFeatureAccessUpdateArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFeatureAccesses.
     * @param {UserFeatureAccessDeleteManyArgs} args - Arguments to filter UserFeatureAccesses to delete.
     * @example
     * // Delete a few UserFeatureAccesses
     * const { count } = await prisma.userFeatureAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeatureAccessDeleteManyArgs>(args?: SelectSubset<T, UserFeatureAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeatureAccesses
     * const userFeatureAccess = await prisma.userFeatureAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeatureAccessUpdateManyArgs>(args: SelectSubset<T, UserFeatureAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureAccesses and returns the data updated in the database.
     * @param {UserFeatureAccessUpdateManyAndReturnArgs} args - Arguments to update many UserFeatureAccesses.
     * @example
     * // Update many UserFeatureAccesses
     * const userFeatureAccess = await prisma.userFeatureAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFeatureAccesses and only return the `id`
     * const userFeatureAccessWithIdOnly = await prisma.userFeatureAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFeatureAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFeatureAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFeatureAccess.
     * @param {UserFeatureAccessUpsertArgs} args - Arguments to update or create a UserFeatureAccess.
     * @example
     * // Update or create a UserFeatureAccess
     * const userFeatureAccess = await prisma.userFeatureAccess.upsert({
     *   create: {
     *     // ... data to create a UserFeatureAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeatureAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserFeatureAccessUpsertArgs>(args: SelectSubset<T, UserFeatureAccessUpsertArgs<ExtArgs>>): Prisma__UserFeatureAccessClient<$Result.GetResult<Prisma.$UserFeatureAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFeatureAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessCountArgs} args - Arguments to filter UserFeatureAccesses to count.
     * @example
     * // Count the number of UserFeatureAccesses
     * const count = await prisma.userFeatureAccess.count({
     *   where: {
     *     // ... the filter for the UserFeatureAccesses we want to count
     *   }
     * })
    **/
    count<T extends UserFeatureAccessCountArgs>(
      args?: Subset<T, UserFeatureAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeatureAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeatureAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeatureAccessAggregateArgs>(args: Subset<T, UserFeatureAccessAggregateArgs>): Prisma.PrismaPromise<GetUserFeatureAccessAggregateType<T>>

    /**
     * Group by UserFeatureAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeatureAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeatureAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserFeatureAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeatureAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeatureAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeatureAccess model
   */
  readonly fields: UserFeatureAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeatureAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeatureAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeatureAccess model
   */
  interface UserFeatureAccessFieldRefs {
    readonly id: FieldRef<"UserFeatureAccess", 'String'>
    readonly userId: FieldRef<"UserFeatureAccess", 'String'>
    readonly canExportData: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly canAccessAdvancedAnalytics: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly canUseBulkOperations: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly canAccessAPI: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly canInviteTeamMembers: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly maxProperties: FieldRef<"UserFeatureAccess", 'Int'>
    readonly maxUnitsPerProperty: FieldRef<"UserFeatureAccess", 'Int'>
    readonly maxStorageGB: FieldRef<"UserFeatureAccess", 'Float'>
    readonly hasPrioritySupport: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly canUsePremiumIntegrations: FieldRef<"UserFeatureAccess", 'Boolean'>
    readonly lastUpdated: FieldRef<"UserFeatureAccess", 'DateTime'>
    readonly updateReason: FieldRef<"UserFeatureAccess", 'String'>
    readonly createdAt: FieldRef<"UserFeatureAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeatureAccess findUnique
   */
  export type UserFeatureAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureAccess to fetch.
     */
    where: UserFeatureAccessWhereUniqueInput
  }

  /**
   * UserFeatureAccess findUniqueOrThrow
   */
  export type UserFeatureAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureAccess to fetch.
     */
    where: UserFeatureAccessWhereUniqueInput
  }

  /**
   * UserFeatureAccess findFirst
   */
  export type UserFeatureAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureAccess to fetch.
     */
    where?: UserFeatureAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureAccesses to fetch.
     */
    orderBy?: UserFeatureAccessOrderByWithRelationInput | UserFeatureAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureAccesses.
     */
    cursor?: UserFeatureAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureAccesses.
     */
    distinct?: UserFeatureAccessScalarFieldEnum | UserFeatureAccessScalarFieldEnum[]
  }

  /**
   * UserFeatureAccess findFirstOrThrow
   */
  export type UserFeatureAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureAccess to fetch.
     */
    where?: UserFeatureAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureAccesses to fetch.
     */
    orderBy?: UserFeatureAccessOrderByWithRelationInput | UserFeatureAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureAccesses.
     */
    cursor?: UserFeatureAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureAccesses.
     */
    distinct?: UserFeatureAccessScalarFieldEnum | UserFeatureAccessScalarFieldEnum[]
  }

  /**
   * UserFeatureAccess findMany
   */
  export type UserFeatureAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureAccesses to fetch.
     */
    where?: UserFeatureAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureAccesses to fetch.
     */
    orderBy?: UserFeatureAccessOrderByWithRelationInput | UserFeatureAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeatureAccesses.
     */
    cursor?: UserFeatureAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureAccesses.
     */
    skip?: number
    distinct?: UserFeatureAccessScalarFieldEnum | UserFeatureAccessScalarFieldEnum[]
  }

  /**
   * UserFeatureAccess create
   */
  export type UserFeatureAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeatureAccess.
     */
    data: XOR<UserFeatureAccessCreateInput, UserFeatureAccessUncheckedCreateInput>
  }

  /**
   * UserFeatureAccess createMany
   */
  export type UserFeatureAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeatureAccesses.
     */
    data: UserFeatureAccessCreateManyInput | UserFeatureAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeatureAccess createManyAndReturn
   */
  export type UserFeatureAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * The data used to create many UserFeatureAccesses.
     */
    data: UserFeatureAccessCreateManyInput | UserFeatureAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureAccess update
   */
  export type UserFeatureAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeatureAccess.
     */
    data: XOR<UserFeatureAccessUpdateInput, UserFeatureAccessUncheckedUpdateInput>
    /**
     * Choose, which UserFeatureAccess to update.
     */
    where: UserFeatureAccessWhereUniqueInput
  }

  /**
   * UserFeatureAccess updateMany
   */
  export type UserFeatureAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeatureAccesses.
     */
    data: XOR<UserFeatureAccessUpdateManyMutationInput, UserFeatureAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureAccesses to update
     */
    where?: UserFeatureAccessWhereInput
    /**
     * Limit how many UserFeatureAccesses to update.
     */
    limit?: number
  }

  /**
   * UserFeatureAccess updateManyAndReturn
   */
  export type UserFeatureAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * The data used to update UserFeatureAccesses.
     */
    data: XOR<UserFeatureAccessUpdateManyMutationInput, UserFeatureAccessUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureAccesses to update
     */
    where?: UserFeatureAccessWhereInput
    /**
     * Limit how many UserFeatureAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureAccess upsert
   */
  export type UserFeatureAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeatureAccess to update in case it exists.
     */
    where: UserFeatureAccessWhereUniqueInput
    /**
     * In case the UserFeatureAccess found by the `where` argument doesn't exist, create a new UserFeatureAccess with this data.
     */
    create: XOR<UserFeatureAccessCreateInput, UserFeatureAccessUncheckedCreateInput>
    /**
     * In case the UserFeatureAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeatureAccessUpdateInput, UserFeatureAccessUncheckedUpdateInput>
  }

  /**
   * UserFeatureAccess delete
   */
  export type UserFeatureAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
    /**
     * Filter which UserFeatureAccess to delete.
     */
    where: UserFeatureAccessWhereUniqueInput
  }

  /**
   * UserFeatureAccess deleteMany
   */
  export type UserFeatureAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureAccesses to delete
     */
    where?: UserFeatureAccessWhereInput
    /**
     * Limit how many UserFeatureAccesses to delete.
     */
    limit?: number
  }

  /**
   * UserFeatureAccess without action
   */
  export type UserFeatureAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureAccess
     */
    select?: UserFeatureAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureAccess
     */
    omit?: UserFeatureAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureAccessInclude<ExtArgs> | null
  }


  /**
   * Model UserAccessLog
   */

  export type AggregateUserAccessLog = {
    _count: UserAccessLogCountAggregateOutputType | null
    _min: UserAccessLogMinAggregateOutputType | null
    _max: UserAccessLogMaxAggregateOutputType | null
  }

  export type UserAccessLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionStatus: string | null
    planType: string | null
    reason: string | null
    timestamp: Date | null
  }

  export type UserAccessLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subscriptionStatus: string | null
    planType: string | null
    reason: string | null
    timestamp: Date | null
  }

  export type UserAccessLogCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionStatus: number
    planType: number
    reason: number
    accessGranted: number
    timestamp: number
    _all: number
  }


  export type UserAccessLogMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionStatus?: true
    planType?: true
    reason?: true
    timestamp?: true
  }

  export type UserAccessLogMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionStatus?: true
    planType?: true
    reason?: true
    timestamp?: true
  }

  export type UserAccessLogCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionStatus?: true
    planType?: true
    reason?: true
    accessGranted?: true
    timestamp?: true
    _all?: true
  }

  export type UserAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccessLog to aggregate.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccessLogs
    **/
    _count?: true | UserAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccessLogMaxAggregateInputType
  }

  export type GetUserAccessLogAggregateType<T extends UserAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccessLog[P]>
      : GetScalarType<T[P], AggregateUserAccessLog[P]>
  }




  export type UserAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccessLogWhereInput
    orderBy?: UserAccessLogOrderByWithAggregationInput | UserAccessLogOrderByWithAggregationInput[]
    by: UserAccessLogScalarFieldEnum[] | UserAccessLogScalarFieldEnum
    having?: UserAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccessLogCountAggregateInputType | true
    _min?: UserAccessLogMinAggregateInputType
    _max?: UserAccessLogMaxAggregateInputType
  }

  export type UserAccessLogGroupByOutputType = {
    id: string
    userId: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonValue
    timestamp: Date
    _count: UserAccessLogCountAggregateOutputType | null
    _min: UserAccessLogMinAggregateOutputType | null
    _max: UserAccessLogMaxAggregateOutputType | null
  }

  type GetUserAccessLogGroupByPayload<T extends UserAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type UserAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionStatus?: boolean
    planType?: boolean
    reason?: boolean
    accessGranted?: boolean
    timestamp?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionStatus?: boolean
    planType?: boolean
    reason?: boolean
    accessGranted?: boolean
    timestamp?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionStatus?: boolean
    planType?: boolean
    reason?: boolean
    accessGranted?: boolean
    timestamp?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccessLog"]>

  export type UserAccessLogSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionStatus?: boolean
    planType?: boolean
    reason?: boolean
    accessGranted?: boolean
    timestamp?: boolean
  }

  export type UserAccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subscriptionStatus" | "planType" | "reason" | "accessGranted" | "timestamp", ExtArgs["result"]["userAccessLog"]>
  export type UserAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAccessLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccessLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subscriptionStatus: string
      planType: string
      reason: string
      accessGranted: Prisma.JsonValue
      timestamp: Date
    }, ExtArgs["result"]["userAccessLog"]>
    composites: {}
  }

  type UserAccessLogGetPayload<S extends boolean | null | undefined | UserAccessLogDefaultArgs> = $Result.GetResult<Prisma.$UserAccessLogPayload, S>

  type UserAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAccessLogCountAggregateInputType | true
    }

  export interface UserAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccessLog'], meta: { name: 'UserAccessLog' } }
    /**
     * Find zero or one UserAccessLog that matches the filter.
     * @param {UserAccessLogFindUniqueArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccessLogFindUniqueArgs>(args: SelectSubset<T, UserAccessLogFindUniqueArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAccessLogFindUniqueOrThrowArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindFirstArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccessLogFindFirstArgs>(args?: SelectSubset<T, UserAccessLogFindFirstArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindFirstOrThrowArgs} args - Arguments to find a UserAccessLog
     * @example
     * // Get one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccessLogs
     * const userAccessLogs = await prisma.userAccessLog.findMany()
     * 
     * // Get first 10 UserAccessLogs
     * const userAccessLogs = await prisma.userAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAccessLogFindManyArgs>(args?: SelectSubset<T, UserAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAccessLog.
     * @param {UserAccessLogCreateArgs} args - Arguments to create a UserAccessLog.
     * @example
     * // Create one UserAccessLog
     * const UserAccessLog = await prisma.userAccessLog.create({
     *   data: {
     *     // ... data to create a UserAccessLog
     *   }
     * })
     * 
     */
    create<T extends UserAccessLogCreateArgs>(args: SelectSubset<T, UserAccessLogCreateArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAccessLogs.
     * @param {UserAccessLogCreateManyArgs} args - Arguments to create many UserAccessLogs.
     * @example
     * // Create many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccessLogCreateManyArgs>(args?: SelectSubset<T, UserAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAccessLogs and returns the data saved in the database.
     * @param {UserAccessLogCreateManyAndReturnArgs} args - Arguments to create many UserAccessLogs.
     * @example
     * // Create many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAccessLogs and only return the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAccessLog.
     * @param {UserAccessLogDeleteArgs} args - Arguments to delete one UserAccessLog.
     * @example
     * // Delete one UserAccessLog
     * const UserAccessLog = await prisma.userAccessLog.delete({
     *   where: {
     *     // ... filter to delete one UserAccessLog
     *   }
     * })
     * 
     */
    delete<T extends UserAccessLogDeleteArgs>(args: SelectSubset<T, UserAccessLogDeleteArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAccessLog.
     * @param {UserAccessLogUpdateArgs} args - Arguments to update one UserAccessLog.
     * @example
     * // Update one UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccessLogUpdateArgs>(args: SelectSubset<T, UserAccessLogUpdateArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAccessLogs.
     * @param {UserAccessLogDeleteManyArgs} args - Arguments to filter UserAccessLogs to delete.
     * @example
     * // Delete a few UserAccessLogs
     * const { count } = await prisma.userAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccessLogDeleteManyArgs>(args?: SelectSubset<T, UserAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccessLogUpdateManyArgs>(args: SelectSubset<T, UserAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccessLogs and returns the data updated in the database.
     * @param {UserAccessLogUpdateManyAndReturnArgs} args - Arguments to update many UserAccessLogs.
     * @example
     * // Update many UserAccessLogs
     * const userAccessLog = await prisma.userAccessLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAccessLogs and only return the `id`
     * const userAccessLogWithIdOnly = await prisma.userAccessLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAccessLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAccessLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAccessLog.
     * @param {UserAccessLogUpsertArgs} args - Arguments to update or create a UserAccessLog.
     * @example
     * // Update or create a UserAccessLog
     * const userAccessLog = await prisma.userAccessLog.upsert({
     *   create: {
     *     // ... data to create a UserAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends UserAccessLogUpsertArgs>(args: SelectSubset<T, UserAccessLogUpsertArgs<ExtArgs>>): Prisma__UserAccessLogClient<$Result.GetResult<Prisma.$UserAccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogCountArgs} args - Arguments to filter UserAccessLogs to count.
     * @example
     * // Count the number of UserAccessLogs
     * const count = await prisma.userAccessLog.count({
     *   where: {
     *     // ... the filter for the UserAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends UserAccessLogCountArgs>(
      args?: Subset<T, UserAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccessLogAggregateArgs>(args: Subset<T, UserAccessLogAggregateArgs>): Prisma.PrismaPromise<GetUserAccessLogAggregateType<T>>

    /**
     * Group by UserAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: UserAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccessLog model
   */
  readonly fields: UserAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccessLog model
   */
  interface UserAccessLogFieldRefs {
    readonly id: FieldRef<"UserAccessLog", 'String'>
    readonly userId: FieldRef<"UserAccessLog", 'String'>
    readonly subscriptionStatus: FieldRef<"UserAccessLog", 'String'>
    readonly planType: FieldRef<"UserAccessLog", 'String'>
    readonly reason: FieldRef<"UserAccessLog", 'String'>
    readonly accessGranted: FieldRef<"UserAccessLog", 'Json'>
    readonly timestamp: FieldRef<"UserAccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccessLog findUnique
   */
  export type UserAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog findUniqueOrThrow
   */
  export type UserAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog findFirst
   */
  export type UserAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccessLogs.
     */
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog findFirstOrThrow
   */
  export type UserAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLog to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccessLogs.
     */
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog findMany
   */
  export type UserAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which UserAccessLogs to fetch.
     */
    where?: UserAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccessLogs to fetch.
     */
    orderBy?: UserAccessLogOrderByWithRelationInput | UserAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccessLogs.
     */
    cursor?: UserAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccessLogs.
     */
    skip?: number
    distinct?: UserAccessLogScalarFieldEnum | UserAccessLogScalarFieldEnum[]
  }

  /**
   * UserAccessLog create
   */
  export type UserAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccessLog.
     */
    data: XOR<UserAccessLogCreateInput, UserAccessLogUncheckedCreateInput>
  }

  /**
   * UserAccessLog createMany
   */
  export type UserAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccessLogs.
     */
    data: UserAccessLogCreateManyInput | UserAccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccessLog createManyAndReturn
   */
  export type UserAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * The data used to create many UserAccessLogs.
     */
    data: UserAccessLogCreateManyInput | UserAccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccessLog update
   */
  export type UserAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccessLog.
     */
    data: XOR<UserAccessLogUpdateInput, UserAccessLogUncheckedUpdateInput>
    /**
     * Choose, which UserAccessLog to update.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog updateMany
   */
  export type UserAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccessLogs.
     */
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which UserAccessLogs to update
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to update.
     */
    limit?: number
  }

  /**
   * UserAccessLog updateManyAndReturn
   */
  export type UserAccessLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * The data used to update UserAccessLogs.
     */
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which UserAccessLogs to update
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccessLog upsert
   */
  export type UserAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccessLog to update in case it exists.
     */
    where: UserAccessLogWhereUniqueInput
    /**
     * In case the UserAccessLog found by the `where` argument doesn't exist, create a new UserAccessLog with this data.
     */
    create: XOR<UserAccessLogCreateInput, UserAccessLogUncheckedCreateInput>
    /**
     * In case the UserAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccessLogUpdateInput, UserAccessLogUncheckedUpdateInput>
  }

  /**
   * UserAccessLog delete
   */
  export type UserAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
    /**
     * Filter which UserAccessLog to delete.
     */
    where: UserAccessLogWhereUniqueInput
  }

  /**
   * UserAccessLog deleteMany
   */
  export type UserAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccessLogs to delete
     */
    where?: UserAccessLogWhereInput
    /**
     * Limit how many UserAccessLogs to delete.
     */
    limit?: number
  }

  /**
   * UserAccessLog without action
   */
  export type UserAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccessLog
     */
    select?: UserAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccessLog
     */
    omit?: UserAccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    subscriptionId: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    subscriptionId: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    subscriptionId: number
    metadata: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    subscriptionId?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    subscriptionId?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    subscriptionId?: true
    metadata?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    type: string
    subscriptionId: string | null
    metadata: JsonValue
    sentAt: Date
    createdAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    subscriptionId?: boolean
    metadata?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "subscriptionId" | "metadata" | "sentAt" | "createdAt", ExtArgs["result"]["notificationLog"]>
  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      subscriptionId: string | null
      metadata: Prisma.JsonValue
      sentAt: Date
      createdAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs and returns the data updated in the database.
     * @param {NotificationLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationLogs.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly type: FieldRef<"NotificationLog", 'String'>
    readonly subscriptionId: FieldRef<"NotificationLog", 'String'>
    readonly metadata: FieldRef<"NotificationLog", 'Json'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog updateManyAndReturn
   */
  export type NotificationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model FailedWebhookEvent
   */

  export type AggregateFailedWebhookEvent = {
    _count: FailedWebhookEventCountAggregateOutputType | null
    _avg: FailedWebhookEventAvgAggregateOutputType | null
    _sum: FailedWebhookEventSumAggregateOutputType | null
    _min: FailedWebhookEventMinAggregateOutputType | null
    _max: FailedWebhookEventMaxAggregateOutputType | null
  }

  export type FailedWebhookEventAvgAggregateOutputType = {
    failureCount: number | null
  }

  export type FailedWebhookEventSumAggregateOutputType = {
    failureCount: number | null
  }

  export type FailedWebhookEventMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    payload: string | null
    signature: string | null
    failureReason: string | null
    failureCount: number | null
    firstFailedAt: Date | null
    lastRetryAt: Date | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FailedWebhookEventMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    eventType: string | null
    payload: string | null
    signature: string | null
    failureReason: string | null
    failureCount: number | null
    firstFailedAt: Date | null
    lastRetryAt: Date | null
    nextRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FailedWebhookEventCountAggregateOutputType = {
    id: number
    eventId: number
    eventType: number
    payload: number
    signature: number
    failureReason: number
    failureCount: number
    firstFailedAt: number
    lastRetryAt: number
    nextRetryAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FailedWebhookEventAvgAggregateInputType = {
    failureCount?: true
  }

  export type FailedWebhookEventSumAggregateInputType = {
    failureCount?: true
  }

  export type FailedWebhookEventMinAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    payload?: true
    signature?: true
    failureReason?: true
    failureCount?: true
    firstFailedAt?: true
    lastRetryAt?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FailedWebhookEventMaxAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    payload?: true
    signature?: true
    failureReason?: true
    failureCount?: true
    firstFailedAt?: true
    lastRetryAt?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FailedWebhookEventCountAggregateInputType = {
    id?: true
    eventId?: true
    eventType?: true
    payload?: true
    signature?: true
    failureReason?: true
    failureCount?: true
    firstFailedAt?: true
    lastRetryAt?: true
    nextRetryAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FailedWebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedWebhookEvent to aggregate.
     */
    where?: FailedWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedWebhookEvents to fetch.
     */
    orderBy?: FailedWebhookEventOrderByWithRelationInput | FailedWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FailedWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FailedWebhookEvents
    **/
    _count?: true | FailedWebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FailedWebhookEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FailedWebhookEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FailedWebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FailedWebhookEventMaxAggregateInputType
  }

  export type GetFailedWebhookEventAggregateType<T extends FailedWebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFailedWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailedWebhookEvent[P]>
      : GetScalarType<T[P], AggregateFailedWebhookEvent[P]>
  }




  export type FailedWebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FailedWebhookEventWhereInput
    orderBy?: FailedWebhookEventOrderByWithAggregationInput | FailedWebhookEventOrderByWithAggregationInput[]
    by: FailedWebhookEventScalarFieldEnum[] | FailedWebhookEventScalarFieldEnum
    having?: FailedWebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FailedWebhookEventCountAggregateInputType | true
    _avg?: FailedWebhookEventAvgAggregateInputType
    _sum?: FailedWebhookEventSumAggregateInputType
    _min?: FailedWebhookEventMinAggregateInputType
    _max?: FailedWebhookEventMaxAggregateInputType
  }

  export type FailedWebhookEventGroupByOutputType = {
    id: string
    eventId: string
    eventType: string
    payload: string
    signature: string
    failureReason: string
    failureCount: number
    firstFailedAt: Date
    lastRetryAt: Date | null
    nextRetryAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FailedWebhookEventCountAggregateOutputType | null
    _avg: FailedWebhookEventAvgAggregateOutputType | null
    _sum: FailedWebhookEventSumAggregateOutputType | null
    _min: FailedWebhookEventMinAggregateOutputType | null
    _max: FailedWebhookEventMaxAggregateOutputType | null
  }

  type GetFailedWebhookEventGroupByPayload<T extends FailedWebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FailedWebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FailedWebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FailedWebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], FailedWebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type FailedWebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    failureReason?: boolean
    failureCount?: boolean
    firstFailedAt?: boolean
    lastRetryAt?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["failedWebhookEvent"]>

  export type FailedWebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    failureReason?: boolean
    failureCount?: boolean
    firstFailedAt?: boolean
    lastRetryAt?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["failedWebhookEvent"]>

  export type FailedWebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    failureReason?: boolean
    failureCount?: boolean
    firstFailedAt?: boolean
    lastRetryAt?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["failedWebhookEvent"]>

  export type FailedWebhookEventSelectScalar = {
    id?: boolean
    eventId?: boolean
    eventType?: boolean
    payload?: boolean
    signature?: boolean
    failureReason?: boolean
    failureCount?: boolean
    firstFailedAt?: boolean
    lastRetryAt?: boolean
    nextRetryAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FailedWebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "eventType" | "payload" | "signature" | "failureReason" | "failureCount" | "firstFailedAt" | "lastRetryAt" | "nextRetryAt" | "createdAt" | "updatedAt", ExtArgs["result"]["failedWebhookEvent"]>

  export type $FailedWebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FailedWebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      eventType: string
      payload: string
      signature: string
      failureReason: string
      failureCount: number
      firstFailedAt: Date
      lastRetryAt: Date | null
      nextRetryAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["failedWebhookEvent"]>
    composites: {}
  }

  type FailedWebhookEventGetPayload<S extends boolean | null | undefined | FailedWebhookEventDefaultArgs> = $Result.GetResult<Prisma.$FailedWebhookEventPayload, S>

  type FailedWebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FailedWebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FailedWebhookEventCountAggregateInputType | true
    }

  export interface FailedWebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FailedWebhookEvent'], meta: { name: 'FailedWebhookEvent' } }
    /**
     * Find zero or one FailedWebhookEvent that matches the filter.
     * @param {FailedWebhookEventFindUniqueArgs} args - Arguments to find a FailedWebhookEvent
     * @example
     * // Get one FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FailedWebhookEventFindUniqueArgs>(args: SelectSubset<T, FailedWebhookEventFindUniqueArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FailedWebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FailedWebhookEventFindUniqueOrThrowArgs} args - Arguments to find a FailedWebhookEvent
     * @example
     * // Get one FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FailedWebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FailedWebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedWebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventFindFirstArgs} args - Arguments to find a FailedWebhookEvent
     * @example
     * // Get one FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FailedWebhookEventFindFirstArgs>(args?: SelectSubset<T, FailedWebhookEventFindFirstArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedWebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventFindFirstOrThrowArgs} args - Arguments to find a FailedWebhookEvent
     * @example
     * // Get one FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FailedWebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FailedWebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FailedWebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FailedWebhookEvents
     * const failedWebhookEvents = await prisma.failedWebhookEvent.findMany()
     * 
     * // Get first 10 FailedWebhookEvents
     * const failedWebhookEvents = await prisma.failedWebhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failedWebhookEventWithIdOnly = await prisma.failedWebhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FailedWebhookEventFindManyArgs>(args?: SelectSubset<T, FailedWebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FailedWebhookEvent.
     * @param {FailedWebhookEventCreateArgs} args - Arguments to create a FailedWebhookEvent.
     * @example
     * // Create one FailedWebhookEvent
     * const FailedWebhookEvent = await prisma.failedWebhookEvent.create({
     *   data: {
     *     // ... data to create a FailedWebhookEvent
     *   }
     * })
     * 
     */
    create<T extends FailedWebhookEventCreateArgs>(args: SelectSubset<T, FailedWebhookEventCreateArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FailedWebhookEvents.
     * @param {FailedWebhookEventCreateManyArgs} args - Arguments to create many FailedWebhookEvents.
     * @example
     * // Create many FailedWebhookEvents
     * const failedWebhookEvent = await prisma.failedWebhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FailedWebhookEventCreateManyArgs>(args?: SelectSubset<T, FailedWebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FailedWebhookEvents and returns the data saved in the database.
     * @param {FailedWebhookEventCreateManyAndReturnArgs} args - Arguments to create many FailedWebhookEvents.
     * @example
     * // Create many FailedWebhookEvents
     * const failedWebhookEvent = await prisma.failedWebhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FailedWebhookEvents and only return the `id`
     * const failedWebhookEventWithIdOnly = await prisma.failedWebhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FailedWebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FailedWebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FailedWebhookEvent.
     * @param {FailedWebhookEventDeleteArgs} args - Arguments to delete one FailedWebhookEvent.
     * @example
     * // Delete one FailedWebhookEvent
     * const FailedWebhookEvent = await prisma.failedWebhookEvent.delete({
     *   where: {
     *     // ... filter to delete one FailedWebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends FailedWebhookEventDeleteArgs>(args: SelectSubset<T, FailedWebhookEventDeleteArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FailedWebhookEvent.
     * @param {FailedWebhookEventUpdateArgs} args - Arguments to update one FailedWebhookEvent.
     * @example
     * // Update one FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FailedWebhookEventUpdateArgs>(args: SelectSubset<T, FailedWebhookEventUpdateArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FailedWebhookEvents.
     * @param {FailedWebhookEventDeleteManyArgs} args - Arguments to filter FailedWebhookEvents to delete.
     * @example
     * // Delete a few FailedWebhookEvents
     * const { count } = await prisma.failedWebhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FailedWebhookEventDeleteManyArgs>(args?: SelectSubset<T, FailedWebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FailedWebhookEvents
     * const failedWebhookEvent = await prisma.failedWebhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FailedWebhookEventUpdateManyArgs>(args: SelectSubset<T, FailedWebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedWebhookEvents and returns the data updated in the database.
     * @param {FailedWebhookEventUpdateManyAndReturnArgs} args - Arguments to update many FailedWebhookEvents.
     * @example
     * // Update many FailedWebhookEvents
     * const failedWebhookEvent = await prisma.failedWebhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FailedWebhookEvents and only return the `id`
     * const failedWebhookEventWithIdOnly = await prisma.failedWebhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FailedWebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, FailedWebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FailedWebhookEvent.
     * @param {FailedWebhookEventUpsertArgs} args - Arguments to update or create a FailedWebhookEvent.
     * @example
     * // Update or create a FailedWebhookEvent
     * const failedWebhookEvent = await prisma.failedWebhookEvent.upsert({
     *   create: {
     *     // ... data to create a FailedWebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FailedWebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends FailedWebhookEventUpsertArgs>(args: SelectSubset<T, FailedWebhookEventUpsertArgs<ExtArgs>>): Prisma__FailedWebhookEventClient<$Result.GetResult<Prisma.$FailedWebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FailedWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventCountArgs} args - Arguments to filter FailedWebhookEvents to count.
     * @example
     * // Count the number of FailedWebhookEvents
     * const count = await prisma.failedWebhookEvent.count({
     *   where: {
     *     // ... the filter for the FailedWebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends FailedWebhookEventCountArgs>(
      args?: Subset<T, FailedWebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FailedWebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FailedWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FailedWebhookEventAggregateArgs>(args: Subset<T, FailedWebhookEventAggregateArgs>): Prisma.PrismaPromise<GetFailedWebhookEventAggregateType<T>>

    /**
     * Group by FailedWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedWebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FailedWebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FailedWebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: FailedWebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FailedWebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailedWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FailedWebhookEvent model
   */
  readonly fields: FailedWebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FailedWebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FailedWebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FailedWebhookEvent model
   */
  interface FailedWebhookEventFieldRefs {
    readonly id: FieldRef<"FailedWebhookEvent", 'String'>
    readonly eventId: FieldRef<"FailedWebhookEvent", 'String'>
    readonly eventType: FieldRef<"FailedWebhookEvent", 'String'>
    readonly payload: FieldRef<"FailedWebhookEvent", 'String'>
    readonly signature: FieldRef<"FailedWebhookEvent", 'String'>
    readonly failureReason: FieldRef<"FailedWebhookEvent", 'String'>
    readonly failureCount: FieldRef<"FailedWebhookEvent", 'Int'>
    readonly firstFailedAt: FieldRef<"FailedWebhookEvent", 'DateTime'>
    readonly lastRetryAt: FieldRef<"FailedWebhookEvent", 'DateTime'>
    readonly nextRetryAt: FieldRef<"FailedWebhookEvent", 'DateTime'>
    readonly createdAt: FieldRef<"FailedWebhookEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"FailedWebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FailedWebhookEvent findUnique
   */
  export type FailedWebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which FailedWebhookEvent to fetch.
     */
    where: FailedWebhookEventWhereUniqueInput
  }

  /**
   * FailedWebhookEvent findUniqueOrThrow
   */
  export type FailedWebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which FailedWebhookEvent to fetch.
     */
    where: FailedWebhookEventWhereUniqueInput
  }

  /**
   * FailedWebhookEvent findFirst
   */
  export type FailedWebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which FailedWebhookEvent to fetch.
     */
    where?: FailedWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedWebhookEvents to fetch.
     */
    orderBy?: FailedWebhookEventOrderByWithRelationInput | FailedWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedWebhookEvents.
     */
    cursor?: FailedWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedWebhookEvents.
     */
    distinct?: FailedWebhookEventScalarFieldEnum | FailedWebhookEventScalarFieldEnum[]
  }

  /**
   * FailedWebhookEvent findFirstOrThrow
   */
  export type FailedWebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which FailedWebhookEvent to fetch.
     */
    where?: FailedWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedWebhookEvents to fetch.
     */
    orderBy?: FailedWebhookEventOrderByWithRelationInput | FailedWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedWebhookEvents.
     */
    cursor?: FailedWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedWebhookEvents.
     */
    distinct?: FailedWebhookEventScalarFieldEnum | FailedWebhookEventScalarFieldEnum[]
  }

  /**
   * FailedWebhookEvent findMany
   */
  export type FailedWebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which FailedWebhookEvents to fetch.
     */
    where?: FailedWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedWebhookEvents to fetch.
     */
    orderBy?: FailedWebhookEventOrderByWithRelationInput | FailedWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FailedWebhookEvents.
     */
    cursor?: FailedWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedWebhookEvents.
     */
    skip?: number
    distinct?: FailedWebhookEventScalarFieldEnum | FailedWebhookEventScalarFieldEnum[]
  }

  /**
   * FailedWebhookEvent create
   */
  export type FailedWebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to create a FailedWebhookEvent.
     */
    data: XOR<FailedWebhookEventCreateInput, FailedWebhookEventUncheckedCreateInput>
  }

  /**
   * FailedWebhookEvent createMany
   */
  export type FailedWebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FailedWebhookEvents.
     */
    data: FailedWebhookEventCreateManyInput | FailedWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedWebhookEvent createManyAndReturn
   */
  export type FailedWebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many FailedWebhookEvents.
     */
    data: FailedWebhookEventCreateManyInput | FailedWebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedWebhookEvent update
   */
  export type FailedWebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to update a FailedWebhookEvent.
     */
    data: XOR<FailedWebhookEventUpdateInput, FailedWebhookEventUncheckedUpdateInput>
    /**
     * Choose, which FailedWebhookEvent to update.
     */
    where: FailedWebhookEventWhereUniqueInput
  }

  /**
   * FailedWebhookEvent updateMany
   */
  export type FailedWebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FailedWebhookEvents.
     */
    data: XOR<FailedWebhookEventUpdateManyMutationInput, FailedWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which FailedWebhookEvents to update
     */
    where?: FailedWebhookEventWhereInput
    /**
     * Limit how many FailedWebhookEvents to update.
     */
    limit?: number
  }

  /**
   * FailedWebhookEvent updateManyAndReturn
   */
  export type FailedWebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update FailedWebhookEvents.
     */
    data: XOR<FailedWebhookEventUpdateManyMutationInput, FailedWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which FailedWebhookEvents to update
     */
    where?: FailedWebhookEventWhereInput
    /**
     * Limit how many FailedWebhookEvents to update.
     */
    limit?: number
  }

  /**
   * FailedWebhookEvent upsert
   */
  export type FailedWebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * The filter to search for the FailedWebhookEvent to update in case it exists.
     */
    where: FailedWebhookEventWhereUniqueInput
    /**
     * In case the FailedWebhookEvent found by the `where` argument doesn't exist, create a new FailedWebhookEvent with this data.
     */
    create: XOR<FailedWebhookEventCreateInput, FailedWebhookEventUncheckedCreateInput>
    /**
     * In case the FailedWebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FailedWebhookEventUpdateInput, FailedWebhookEventUncheckedUpdateInput>
  }

  /**
   * FailedWebhookEvent delete
   */
  export type FailedWebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
    /**
     * Filter which FailedWebhookEvent to delete.
     */
    where: FailedWebhookEventWhereUniqueInput
  }

  /**
   * FailedWebhookEvent deleteMany
   */
  export type FailedWebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedWebhookEvents to delete
     */
    where?: FailedWebhookEventWhereInput
    /**
     * Limit how many FailedWebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * FailedWebhookEvent without action
   */
  export type FailedWebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedWebhookEvent
     */
    select?: FailedWebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedWebhookEvent
     */
    omit?: FailedWebhookEventOmit<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedById: string | null
    propertyId: string | null
    maintenanceRequestId: string | null
    createdAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedById: string | null
    propertyId: string | null
    maintenanceRequestId: string | null
    createdAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    uploadedById: number
    propertyId: number
    maintenanceRequestId: number
    createdAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    propertyId?: true
    maintenanceRequestId?: true
    createdAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    propertyId?: true
    maintenanceRequestId?: true
    createdAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    propertyId?: true
    maintenanceRequestId?: true
    createdAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number | null
    url: string
    uploadedById: string | null
    propertyId: string | null
    maintenanceRequestId: string | null
    createdAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    propertyId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    propertyId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    propertyId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    propertyId?: boolean
    maintenanceRequestId?: boolean
    createdAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "url" | "uploadedById" | "propertyId" | "maintenanceRequestId" | "createdAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UploadedBy?: boolean | File$UploadedByArgs<ExtArgs>
    Property?: boolean | File$PropertyArgs<ExtArgs>
    MaintenanceRequest?: boolean | File$MaintenanceRequestArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      UploadedBy: Prisma.$UserPayload<ExtArgs> | null
      Property: Prisma.$PropertyPayload<ExtArgs> | null
      MaintenanceRequest: Prisma.$MaintenanceRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number | null
      url: string
      uploadedById: string | null
      propertyId: string | null
      maintenanceRequestId: string | null
      createdAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UploadedBy<T extends File$UploadedByArgs<ExtArgs> = {}>(args?: Subset<T, File$UploadedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Property<T extends File$PropertyArgs<ExtArgs> = {}>(args?: Subset<T, File$PropertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    MaintenanceRequest<T extends File$MaintenanceRequestArgs<ExtArgs> = {}>(args?: Subset<T, File$MaintenanceRequestArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly originalName: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly url: FieldRef<"File", 'String'>
    readonly uploadedById: FieldRef<"File", 'String'>
    readonly propertyId: FieldRef<"File", 'String'>
    readonly maintenanceRequestId: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.UploadedBy
   */
  export type File$UploadedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * File.Property
   */
  export type File$PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * File.MaintenanceRequest
   */
  export type File$MaintenanceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model PaymentFailure
   */

  export type AggregatePaymentFailure = {
    _count: PaymentFailureCountAggregateOutputType | null
    _avg: PaymentFailureAvgAggregateOutputType | null
    _sum: PaymentFailureSumAggregateOutputType | null
    _min: PaymentFailureMinAggregateOutputType | null
    _max: PaymentFailureMaxAggregateOutputType | null
  }

  export type PaymentFailureAvgAggregateOutputType = {
    amount: number | null
    attemptCount: number | null
  }

  export type PaymentFailureSumAggregateOutputType = {
    amount: number | null
    attemptCount: number | null
  }

  export type PaymentFailureMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amount: number | null
    currency: string | null
    attemptCount: number | null
    errorCode: string | null
    errorMessage: string | null
    nextRetryAt: Date | null
    resolved: boolean | null
    resolvedAt: Date | null
    finalAttempt: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentFailureMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    stripeInvoiceId: string | null
    amount: number | null
    currency: string | null
    attemptCount: number | null
    errorCode: string | null
    errorMessage: string | null
    nextRetryAt: Date | null
    resolved: boolean | null
    resolvedAt: Date | null
    finalAttempt: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentFailureCountAggregateOutputType = {
    id: number
    subscriptionId: number
    stripeInvoiceId: number
    amount: number
    currency: number
    attemptCount: number
    errorCode: number
    errorMessage: number
    nextRetryAt: number
    resolved: number
    resolvedAt: number
    finalAttempt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentFailureAvgAggregateInputType = {
    amount?: true
    attemptCount?: true
  }

  export type PaymentFailureSumAggregateInputType = {
    amount?: true
    attemptCount?: true
  }

  export type PaymentFailureMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    attemptCount?: true
    errorCode?: true
    errorMessage?: true
    nextRetryAt?: true
    resolved?: true
    resolvedAt?: true
    finalAttempt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentFailureMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    attemptCount?: true
    errorCode?: true
    errorMessage?: true
    nextRetryAt?: true
    resolved?: true
    resolvedAt?: true
    finalAttempt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentFailureCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    stripeInvoiceId?: true
    amount?: true
    currency?: true
    attemptCount?: true
    errorCode?: true
    errorMessage?: true
    nextRetryAt?: true
    resolved?: true
    resolvedAt?: true
    finalAttempt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentFailureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentFailure to aggregate.
     */
    where?: PaymentFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentFailures to fetch.
     */
    orderBy?: PaymentFailureOrderByWithRelationInput | PaymentFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentFailures
    **/
    _count?: true | PaymentFailureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentFailureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentFailureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentFailureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentFailureMaxAggregateInputType
  }

  export type GetPaymentFailureAggregateType<T extends PaymentFailureAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentFailure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentFailure[P]>
      : GetScalarType<T[P], AggregatePaymentFailure[P]>
  }




  export type PaymentFailureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentFailureWhereInput
    orderBy?: PaymentFailureOrderByWithAggregationInput | PaymentFailureOrderByWithAggregationInput[]
    by: PaymentFailureScalarFieldEnum[] | PaymentFailureScalarFieldEnum
    having?: PaymentFailureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentFailureCountAggregateInputType | true
    _avg?: PaymentFailureAvgAggregateInputType
    _sum?: PaymentFailureSumAggregateInputType
    _min?: PaymentFailureMinAggregateInputType
    _max?: PaymentFailureMaxAggregateInputType
  }

  export type PaymentFailureGroupByOutputType = {
    id: string
    subscriptionId: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount: number
    errorCode: string | null
    errorMessage: string | null
    nextRetryAt: Date | null
    resolved: boolean
    resolvedAt: Date | null
    finalAttempt: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentFailureCountAggregateOutputType | null
    _avg: PaymentFailureAvgAggregateOutputType | null
    _sum: PaymentFailureSumAggregateOutputType | null
    _min: PaymentFailureMinAggregateOutputType | null
    _max: PaymentFailureMaxAggregateOutputType | null
  }

  type GetPaymentFailureGroupByPayload<T extends PaymentFailureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentFailureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentFailureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentFailureGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentFailureGroupByOutputType[P]>
        }
      >
    >


  export type PaymentFailureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    attemptCount?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    finalAttempt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentFailure"]>

  export type PaymentFailureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    attemptCount?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    finalAttempt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentFailure"]>

  export type PaymentFailureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    attemptCount?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    finalAttempt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentFailure"]>

  export type PaymentFailureSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    stripeInvoiceId?: boolean
    amount?: boolean
    currency?: boolean
    attemptCount?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    nextRetryAt?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    finalAttempt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentFailureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "stripeInvoiceId" | "amount" | "currency" | "attemptCount" | "errorCode" | "errorMessage" | "nextRetryAt" | "resolved" | "resolvedAt" | "finalAttempt" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentFailure"]>
  export type PaymentFailureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentFailureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentFailureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PaymentFailurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentFailure"
    objects: {
      Subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      stripeInvoiceId: string
      amount: number
      currency: string
      attemptCount: number
      errorCode: string | null
      errorMessage: string | null
      nextRetryAt: Date | null
      resolved: boolean
      resolvedAt: Date | null
      finalAttempt: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentFailure"]>
    composites: {}
  }

  type PaymentFailureGetPayload<S extends boolean | null | undefined | PaymentFailureDefaultArgs> = $Result.GetResult<Prisma.$PaymentFailurePayload, S>

  type PaymentFailureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFailureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentFailureCountAggregateInputType | true
    }

  export interface PaymentFailureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentFailure'], meta: { name: 'PaymentFailure' } }
    /**
     * Find zero or one PaymentFailure that matches the filter.
     * @param {PaymentFailureFindUniqueArgs} args - Arguments to find a PaymentFailure
     * @example
     * // Get one PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFailureFindUniqueArgs>(args: SelectSubset<T, PaymentFailureFindUniqueArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentFailure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFailureFindUniqueOrThrowArgs} args - Arguments to find a PaymentFailure
     * @example
     * // Get one PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFailureFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFailureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentFailure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureFindFirstArgs} args - Arguments to find a PaymentFailure
     * @example
     * // Get one PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFailureFindFirstArgs>(args?: SelectSubset<T, PaymentFailureFindFirstArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentFailure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureFindFirstOrThrowArgs} args - Arguments to find a PaymentFailure
     * @example
     * // Get one PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFailureFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFailureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentFailures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentFailures
     * const paymentFailures = await prisma.paymentFailure.findMany()
     * 
     * // Get first 10 PaymentFailures
     * const paymentFailures = await prisma.paymentFailure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentFailureWithIdOnly = await prisma.paymentFailure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFailureFindManyArgs>(args?: SelectSubset<T, PaymentFailureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentFailure.
     * @param {PaymentFailureCreateArgs} args - Arguments to create a PaymentFailure.
     * @example
     * // Create one PaymentFailure
     * const PaymentFailure = await prisma.paymentFailure.create({
     *   data: {
     *     // ... data to create a PaymentFailure
     *   }
     * })
     * 
     */
    create<T extends PaymentFailureCreateArgs>(args: SelectSubset<T, PaymentFailureCreateArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentFailures.
     * @param {PaymentFailureCreateManyArgs} args - Arguments to create many PaymentFailures.
     * @example
     * // Create many PaymentFailures
     * const paymentFailure = await prisma.paymentFailure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentFailureCreateManyArgs>(args?: SelectSubset<T, PaymentFailureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentFailures and returns the data saved in the database.
     * @param {PaymentFailureCreateManyAndReturnArgs} args - Arguments to create many PaymentFailures.
     * @example
     * // Create many PaymentFailures
     * const paymentFailure = await prisma.paymentFailure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentFailures and only return the `id`
     * const paymentFailureWithIdOnly = await prisma.paymentFailure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentFailureCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentFailureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentFailure.
     * @param {PaymentFailureDeleteArgs} args - Arguments to delete one PaymentFailure.
     * @example
     * // Delete one PaymentFailure
     * const PaymentFailure = await prisma.paymentFailure.delete({
     *   where: {
     *     // ... filter to delete one PaymentFailure
     *   }
     * })
     * 
     */
    delete<T extends PaymentFailureDeleteArgs>(args: SelectSubset<T, PaymentFailureDeleteArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentFailure.
     * @param {PaymentFailureUpdateArgs} args - Arguments to update one PaymentFailure.
     * @example
     * // Update one PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentFailureUpdateArgs>(args: SelectSubset<T, PaymentFailureUpdateArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentFailures.
     * @param {PaymentFailureDeleteManyArgs} args - Arguments to filter PaymentFailures to delete.
     * @example
     * // Delete a few PaymentFailures
     * const { count } = await prisma.paymentFailure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentFailureDeleteManyArgs>(args?: SelectSubset<T, PaymentFailureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentFailures
     * const paymentFailure = await prisma.paymentFailure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentFailureUpdateManyArgs>(args: SelectSubset<T, PaymentFailureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentFailures and returns the data updated in the database.
     * @param {PaymentFailureUpdateManyAndReturnArgs} args - Arguments to update many PaymentFailures.
     * @example
     * // Update many PaymentFailures
     * const paymentFailure = await prisma.paymentFailure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentFailures and only return the `id`
     * const paymentFailureWithIdOnly = await prisma.paymentFailure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentFailureUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentFailureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentFailure.
     * @param {PaymentFailureUpsertArgs} args - Arguments to update or create a PaymentFailure.
     * @example
     * // Update or create a PaymentFailure
     * const paymentFailure = await prisma.paymentFailure.upsert({
     *   create: {
     *     // ... data to create a PaymentFailure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentFailure we want to update
     *   }
     * })
     */
    upsert<T extends PaymentFailureUpsertArgs>(args: SelectSubset<T, PaymentFailureUpsertArgs<ExtArgs>>): Prisma__PaymentFailureClient<$Result.GetResult<Prisma.$PaymentFailurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentFailures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureCountArgs} args - Arguments to filter PaymentFailures to count.
     * @example
     * // Count the number of PaymentFailures
     * const count = await prisma.paymentFailure.count({
     *   where: {
     *     // ... the filter for the PaymentFailures we want to count
     *   }
     * })
    **/
    count<T extends PaymentFailureCountArgs>(
      args?: Subset<T, PaymentFailureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentFailureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentFailureAggregateArgs>(args: Subset<T, PaymentFailureAggregateArgs>): Prisma.PrismaPromise<GetPaymentFailureAggregateType<T>>

    /**
     * Group by PaymentFailure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFailureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentFailureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentFailureGroupByArgs['orderBy'] }
        : { orderBy?: PaymentFailureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentFailureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentFailureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentFailure model
   */
  readonly fields: PaymentFailureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentFailure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentFailureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentFailure model
   */
  interface PaymentFailureFieldRefs {
    readonly id: FieldRef<"PaymentFailure", 'String'>
    readonly subscriptionId: FieldRef<"PaymentFailure", 'String'>
    readonly stripeInvoiceId: FieldRef<"PaymentFailure", 'String'>
    readonly amount: FieldRef<"PaymentFailure", 'Int'>
    readonly currency: FieldRef<"PaymentFailure", 'String'>
    readonly attemptCount: FieldRef<"PaymentFailure", 'Int'>
    readonly errorCode: FieldRef<"PaymentFailure", 'String'>
    readonly errorMessage: FieldRef<"PaymentFailure", 'String'>
    readonly nextRetryAt: FieldRef<"PaymentFailure", 'DateTime'>
    readonly resolved: FieldRef<"PaymentFailure", 'Boolean'>
    readonly resolvedAt: FieldRef<"PaymentFailure", 'DateTime'>
    readonly finalAttempt: FieldRef<"PaymentFailure", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentFailure", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentFailure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentFailure findUnique
   */
  export type PaymentFailureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter, which PaymentFailure to fetch.
     */
    where: PaymentFailureWhereUniqueInput
  }

  /**
   * PaymentFailure findUniqueOrThrow
   */
  export type PaymentFailureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter, which PaymentFailure to fetch.
     */
    where: PaymentFailureWhereUniqueInput
  }

  /**
   * PaymentFailure findFirst
   */
  export type PaymentFailureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter, which PaymentFailure to fetch.
     */
    where?: PaymentFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentFailures to fetch.
     */
    orderBy?: PaymentFailureOrderByWithRelationInput | PaymentFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentFailures.
     */
    cursor?: PaymentFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentFailures.
     */
    distinct?: PaymentFailureScalarFieldEnum | PaymentFailureScalarFieldEnum[]
  }

  /**
   * PaymentFailure findFirstOrThrow
   */
  export type PaymentFailureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter, which PaymentFailure to fetch.
     */
    where?: PaymentFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentFailures to fetch.
     */
    orderBy?: PaymentFailureOrderByWithRelationInput | PaymentFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentFailures.
     */
    cursor?: PaymentFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentFailures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentFailures.
     */
    distinct?: PaymentFailureScalarFieldEnum | PaymentFailureScalarFieldEnum[]
  }

  /**
   * PaymentFailure findMany
   */
  export type PaymentFailureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter, which PaymentFailures to fetch.
     */
    where?: PaymentFailureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentFailures to fetch.
     */
    orderBy?: PaymentFailureOrderByWithRelationInput | PaymentFailureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentFailures.
     */
    cursor?: PaymentFailureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentFailures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentFailures.
     */
    skip?: number
    distinct?: PaymentFailureScalarFieldEnum | PaymentFailureScalarFieldEnum[]
  }

  /**
   * PaymentFailure create
   */
  export type PaymentFailureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentFailure.
     */
    data: XOR<PaymentFailureCreateInput, PaymentFailureUncheckedCreateInput>
  }

  /**
   * PaymentFailure createMany
   */
  export type PaymentFailureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentFailures.
     */
    data: PaymentFailureCreateManyInput | PaymentFailureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentFailure createManyAndReturn
   */
  export type PaymentFailureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentFailures.
     */
    data: PaymentFailureCreateManyInput | PaymentFailureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentFailure update
   */
  export type PaymentFailureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentFailure.
     */
    data: XOR<PaymentFailureUpdateInput, PaymentFailureUncheckedUpdateInput>
    /**
     * Choose, which PaymentFailure to update.
     */
    where: PaymentFailureWhereUniqueInput
  }

  /**
   * PaymentFailure updateMany
   */
  export type PaymentFailureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentFailures.
     */
    data: XOR<PaymentFailureUpdateManyMutationInput, PaymentFailureUncheckedUpdateManyInput>
    /**
     * Filter which PaymentFailures to update
     */
    where?: PaymentFailureWhereInput
    /**
     * Limit how many PaymentFailures to update.
     */
    limit?: number
  }

  /**
   * PaymentFailure updateManyAndReturn
   */
  export type PaymentFailureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * The data used to update PaymentFailures.
     */
    data: XOR<PaymentFailureUpdateManyMutationInput, PaymentFailureUncheckedUpdateManyInput>
    /**
     * Filter which PaymentFailures to update
     */
    where?: PaymentFailureWhereInput
    /**
     * Limit how many PaymentFailures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentFailure upsert
   */
  export type PaymentFailureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentFailure to update in case it exists.
     */
    where: PaymentFailureWhereUniqueInput
    /**
     * In case the PaymentFailure found by the `where` argument doesn't exist, create a new PaymentFailure with this data.
     */
    create: XOR<PaymentFailureCreateInput, PaymentFailureUncheckedCreateInput>
    /**
     * In case the PaymentFailure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentFailureUpdateInput, PaymentFailureUncheckedUpdateInput>
  }

  /**
   * PaymentFailure delete
   */
  export type PaymentFailureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
    /**
     * Filter which PaymentFailure to delete.
     */
    where: PaymentFailureWhereUniqueInput
  }

  /**
   * PaymentFailure deleteMany
   */
  export type PaymentFailureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentFailures to delete
     */
    where?: PaymentFailureWhereInput
    /**
     * Limit how many PaymentFailures to delete.
     */
    limit?: number
  }

  /**
   * PaymentFailure without action
   */
  export type PaymentFailureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentFailure
     */
    select?: PaymentFailureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentFailure
     */
    omit?: PaymentFailureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentFailureInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BlogArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    content: 'content',
    excerpt: 'excerpt',
    authorId: 'authorId',
    authorName: 'authorName',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    ogImage: 'ogImage',
    category: 'category',
    status: 'status',
    featured: 'featured',
    publishedAt: 'publishedAt',
    viewCount: 'viewCount',
    readTime: 'readTime',
    searchKeywords: 'searchKeywords',
    lastIndexed: 'lastIndexed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogArticleScalarFieldEnum = (typeof BlogArticleScalarFieldEnum)[keyof typeof BlogArticleScalarFieldEnum]


  export const BlogTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type BlogTagScalarFieldEnum = (typeof BlogTagScalarFieldEnum)[keyof typeof BlogTagScalarFieldEnum]


  export const CustomerInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    businessName: 'businessName',
    businessEmail: 'businessEmail',
    businessAddress: 'businessAddress',
    businessCity: 'businessCity',
    businessState: 'businessState',
    businessZip: 'businessZip',
    businessPhone: 'businessPhone',
    businessLogo: 'businessLogo',
    clientName: 'clientName',
    clientEmail: 'clientEmail',
    clientAddress: 'clientAddress',
    clientCity: 'clientCity',
    clientState: 'clientState',
    clientZip: 'clientZip',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    notes: 'notes',
    terms: 'terms',
    emailCaptured: 'emailCaptured',
    downloadCount: 'downloadCount',
    isProVersion: 'isProVersion',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerInvoiceScalarFieldEnum = (typeof CustomerInvoiceScalarFieldEnum)[keyof typeof CustomerInvoiceScalarFieldEnum]


  export const CustomerInvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    createdAt: 'createdAt'
  };

  export type CustomerInvoiceItemScalarFieldEnum = (typeof CustomerInvoiceItemScalarFieldEnum)[keyof typeof CustomerInvoiceItemScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    filename: 'filename',
    url: 'url',
    type: 'type',
    mimeType: 'mimeType',
    size: 'size',
    propertyId: 'propertyId',
    leaseId: 'leaseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileSizeBytes: 'fileSizeBytes'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    maintenanceId: 'maintenanceId',
    amount: 'amount',
    category: 'category',
    description: 'description',
    date: 'date',
    receiptUrl: 'receiptUrl',
    vendorName: 'vendorName',
    vendorContact: 'vendorContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const InspectionScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    unitId: 'unitId',
    inspectorId: 'inspectorId',
    type: 'type',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    status: 'status',
    notes: 'notes',
    reportUrl: 'reportUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InspectionScalarFieldEnum = (typeof InspectionScalarFieldEnum)[keyof typeof InspectionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    stripeInvoiceId: 'stripeInvoiceId',
    amountPaid: 'amountPaid',
    amountDue: 'amountDue',
    currency: 'currency',
    status: 'status',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    invoiceUrl: 'invoiceUrl',
    invoicePdf: 'invoicePdf',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLeadCaptureScalarFieldEnum: {
    id: 'id',
    email: 'email',
    invoiceId: 'invoiceId',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    source: 'source',
    medium: 'medium',
    campaign: 'campaign',
    emailSent: 'emailSent',
    emailOpened: 'emailOpened',
    linkClicked: 'linkClicked',
    converted: 'converted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceLeadCaptureScalarFieldEnum = (typeof InvoiceLeadCaptureScalarFieldEnum)[keyof typeof InvoiceLeadCaptureScalarFieldEnum]


  export const LeaseScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    tenantId: 'tenantId',
    startDate: 'startDate',
    endDate: 'endDate',
    rentAmount: 'rentAmount',
    securityDeposit: 'securityDeposit',
    terms: 'terms',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaseScalarFieldEnum = (typeof LeaseScalarFieldEnum)[keyof typeof LeaseScalarFieldEnum]


  export const LeaseGeneratorUsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    usageCount: 'usageCount',
    paymentStatus: 'paymentStatus',
    stripeSessionId: 'stripeSessionId',
    stripeCustomerId: 'stripeCustomerId',
    amountPaid: 'amountPaid',
    currency: 'currency',
    paymentDate: 'paymentDate',
    accessExpiresAt: 'accessExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaseGeneratorUsageScalarFieldEnum = (typeof LeaseGeneratorUsageScalarFieldEnum)[keyof typeof LeaseGeneratorUsageScalarFieldEnum]


  export const MaintenanceRequestScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    status: 'status',
    preferredDate: 'preferredDate',
    allowEntry: 'allowEntry',
    contactPhone: 'contactPhone',
    requestedBy: 'requestedBy',
    notes: 'notes',
    photos: 'photos',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    assignedTo: 'assignedTo',
    estimatedCost: 'estimatedCost',
    actualCost: 'actualCost'
  };

  export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    readAt: 'readAt',
    attachmentUrl: 'attachmentUrl',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    description: 'description',
    imageUrl: 'imageUrl',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    propertyType: 'propertyType'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    planId: 'planId',
    planType: 'planType',
    billingPeriod: 'billingPeriod',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    canceledAt: 'canceledAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    emergencyContact: 'emergencyContact',
    avatarUrl: 'avatarUrl',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    unitNumber: 'unitNumber',
    propertyId: 'propertyId',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    squareFeet: 'squareFeet',
    rent: 'rent',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastInspectionDate: 'lastInspectionDate'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    supabaseId: 'supabaseId',
    stripeCustomerId: 'stripeCustomerId',
    email: 'email',
    name: 'name',
    phone: 'phone',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshTokenId: 'refreshTokenId',
    expiresAt: 'expiresAt',
    lastActivity: 'lastActivity',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    isActive: 'isActive',
    invalidatedAt: 'invalidatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const SecurityAuditLogScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    severity: 'severity',
    userId: 'userId',
    email: 'email',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    resource: 'resource',
    action: 'action',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type SecurityAuditLogScalarFieldEnum = (typeof SecurityAuditLogScalarFieldEnum)[keyof typeof SecurityAuditLogScalarFieldEnum]


  export const Wrappers_fdw_statsScalarFieldEnum: {
    fdw_name: 'fdw_name',
    create_times: 'create_times',
    rows_in: 'rows_in',
    rows_out: 'rows_out',
    bytes_in: 'bytes_in',
    bytes_out: 'bytes_out',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Wrappers_fdw_statsScalarFieldEnum = (typeof Wrappers_fdw_statsScalarFieldEnum)[keyof typeof Wrappers_fdw_statsScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    entityName: 'entityName',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    stripeEventId: 'stripeEventId',
    eventType: 'eventType',
    processed: 'processed',
    processingTime: 'processingTime',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const ReminderLogScalarFieldEnum: {
    id: 'id',
    leaseId: 'leaseId',
    userId: 'userId',
    type: 'type',
    status: 'status',
    recipientEmail: 'recipientEmail',
    recipientName: 'recipientName',
    subject: 'subject',
    content: 'content',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    openedAt: 'openedAt',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReminderLogScalarFieldEnum = (typeof ReminderLogScalarFieldEnum)[keyof typeof ReminderLogScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    enableReminders: 'enableReminders',
    daysBeforeDue: 'daysBeforeDue',
    enableOverdueReminders: 'enableOverdueReminders',
    overdueGracePeriod: 'overdueGracePeriod',
    autoSendReminders: 'autoSendReminders',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    pushNotifications: 'pushNotifications',
    defaultDashboardView: 'defaultDashboardView',
    showWelcomeMessage: 'showWelcomeMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const UserFeatureAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    canExportData: 'canExportData',
    canAccessAdvancedAnalytics: 'canAccessAdvancedAnalytics',
    canUseBulkOperations: 'canUseBulkOperations',
    canAccessAPI: 'canAccessAPI',
    canInviteTeamMembers: 'canInviteTeamMembers',
    maxProperties: 'maxProperties',
    maxUnitsPerProperty: 'maxUnitsPerProperty',
    maxStorageGB: 'maxStorageGB',
    hasPrioritySupport: 'hasPrioritySupport',
    canUsePremiumIntegrations: 'canUsePremiumIntegrations',
    lastUpdated: 'lastUpdated',
    updateReason: 'updateReason',
    createdAt: 'createdAt'
  };

  export type UserFeatureAccessScalarFieldEnum = (typeof UserFeatureAccessScalarFieldEnum)[keyof typeof UserFeatureAccessScalarFieldEnum]


  export const UserAccessLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionStatus: 'subscriptionStatus',
    planType: 'planType',
    reason: 'reason',
    accessGranted: 'accessGranted',
    timestamp: 'timestamp'
  };

  export type UserAccessLogScalarFieldEnum = (typeof UserAccessLogScalarFieldEnum)[keyof typeof UserAccessLogScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    subscriptionId: 'subscriptionId',
    metadata: 'metadata',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const FailedWebhookEventScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    eventType: 'eventType',
    payload: 'payload',
    signature: 'signature',
    failureReason: 'failureReason',
    failureCount: 'failureCount',
    firstFailedAt: 'firstFailedAt',
    lastRetryAt: 'lastRetryAt',
    nextRetryAt: 'nextRetryAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FailedWebhookEventScalarFieldEnum = (typeof FailedWebhookEventScalarFieldEnum)[keyof typeof FailedWebhookEventScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    uploadedById: 'uploadedById',
    propertyId: 'propertyId',
    maintenanceRequestId: 'maintenanceRequestId',
    createdAt: 'createdAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const PaymentFailureScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    stripeInvoiceId: 'stripeInvoiceId',
    amount: 'amount',
    currency: 'currency',
    attemptCount: 'attemptCount',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    nextRetryAt: 'nextRetryAt',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    finalAttempt: 'finalAttempt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentFailureScalarFieldEnum = (typeof PaymentFailureScalarFieldEnum)[keyof typeof PaymentFailureScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BlogCategory'
   */
  export type EnumBlogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogCategory'>
    


  /**
   * Reference to a field of type 'BlogCategory[]'
   */
  export type ListEnumBlogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogCategory[]'>
    


  /**
   * Reference to a field of type 'BlogStatus'
   */
  export type EnumBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogStatus'>
    


  /**
   * Reference to a field of type 'BlogStatus[]'
   */
  export type ListEnumBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CustomerInvoiceStatus'
   */
  export type EnumCustomerInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerInvoiceStatus'>
    


  /**
   * Reference to a field of type 'CustomerInvoiceStatus[]'
   */
  export type ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerInvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LeaseStatus'
   */
  export type EnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus'>
    


  /**
   * Reference to a field of type 'LeaseStatus[]'
   */
  export type ListEnumLeaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaseStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'SubStatus'
   */
  export type EnumSubStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubStatus'>
    


  /**
   * Reference to a field of type 'SubStatus[]'
   */
  export type ListEnumSubStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubStatus[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'UnitStatus'
   */
  export type EnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus'>
    


  /**
   * Reference to a field of type 'UnitStatus[]'
   */
  export type ListEnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ActivityEntityType'
   */
  export type EnumActivityEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityEntityType'>
    


  /**
   * Reference to a field of type 'ActivityEntityType[]'
   */
  export type ListEnumActivityEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityEntityType[]'>
    


  /**
   * Reference to a field of type 'ReminderType'
   */
  export type EnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType'>
    


  /**
   * Reference to a field of type 'ReminderType[]'
   */
  export type ListEnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType[]'>
    


  /**
   * Reference to a field of type 'ReminderStatus'
   */
  export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus'>
    


  /**
   * Reference to a field of type 'ReminderStatus[]'
   */
  export type ListEnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BlogArticleWhereInput = {
    AND?: BlogArticleWhereInput | BlogArticleWhereInput[]
    OR?: BlogArticleWhereInput[]
    NOT?: BlogArticleWhereInput | BlogArticleWhereInput[]
    id?: StringFilter<"BlogArticle"> | string
    title?: StringFilter<"BlogArticle"> | string
    slug?: StringFilter<"BlogArticle"> | string
    description?: StringFilter<"BlogArticle"> | string
    content?: StringFilter<"BlogArticle"> | string
    excerpt?: StringNullableFilter<"BlogArticle"> | string | null
    authorId?: StringNullableFilter<"BlogArticle"> | string | null
    authorName?: StringFilter<"BlogArticle"> | string
    metaTitle?: StringNullableFilter<"BlogArticle"> | string | null
    metaDescription?: StringNullableFilter<"BlogArticle"> | string | null
    ogImage?: StringNullableFilter<"BlogArticle"> | string | null
    category?: EnumBlogCategoryFilter<"BlogArticle"> | $Enums.BlogCategory
    status?: EnumBlogStatusFilter<"BlogArticle"> | $Enums.BlogStatus
    featured?: BoolFilter<"BlogArticle"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    viewCount?: IntFilter<"BlogArticle"> | number
    readTime?: IntNullableFilter<"BlogArticle"> | number | null
    searchKeywords?: StringNullableListFilter<"BlogArticle">
    lastIndexed?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogArticle"> | Date | string
    updatedAt?: DateTimeFilter<"BlogArticle"> | Date | string
    tags?: BlogTagListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BlogArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    readTime?: SortOrderInput | SortOrder
    searchKeywords?: SortOrder
    lastIndexed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tags?: BlogTagOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
  }

  export type BlogArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogArticleWhereInput | BlogArticleWhereInput[]
    OR?: BlogArticleWhereInput[]
    NOT?: BlogArticleWhereInput | BlogArticleWhereInput[]
    title?: StringFilter<"BlogArticle"> | string
    description?: StringFilter<"BlogArticle"> | string
    content?: StringFilter<"BlogArticle"> | string
    excerpt?: StringNullableFilter<"BlogArticle"> | string | null
    authorId?: StringNullableFilter<"BlogArticle"> | string | null
    authorName?: StringFilter<"BlogArticle"> | string
    metaTitle?: StringNullableFilter<"BlogArticle"> | string | null
    metaDescription?: StringNullableFilter<"BlogArticle"> | string | null
    ogImage?: StringNullableFilter<"BlogArticle"> | string | null
    category?: EnumBlogCategoryFilter<"BlogArticle"> | $Enums.BlogCategory
    status?: EnumBlogStatusFilter<"BlogArticle"> | $Enums.BlogStatus
    featured?: BoolFilter<"BlogArticle"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    viewCount?: IntFilter<"BlogArticle"> | number
    readTime?: IntNullableFilter<"BlogArticle"> | number | null
    searchKeywords?: StringNullableListFilter<"BlogArticle">
    lastIndexed?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogArticle"> | Date | string
    updatedAt?: DateTimeFilter<"BlogArticle"> | Date | string
    tags?: BlogTagListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type BlogArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    readTime?: SortOrderInput | SortOrder
    searchKeywords?: SortOrder
    lastIndexed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogArticleCountOrderByAggregateInput
    _avg?: BlogArticleAvgOrderByAggregateInput
    _max?: BlogArticleMaxOrderByAggregateInput
    _min?: BlogArticleMinOrderByAggregateInput
    _sum?: BlogArticleSumOrderByAggregateInput
  }

  export type BlogArticleScalarWhereWithAggregatesInput = {
    AND?: BlogArticleScalarWhereWithAggregatesInput | BlogArticleScalarWhereWithAggregatesInput[]
    OR?: BlogArticleScalarWhereWithAggregatesInput[]
    NOT?: BlogArticleScalarWhereWithAggregatesInput | BlogArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogArticle"> | string
    title?: StringWithAggregatesFilter<"BlogArticle"> | string
    slug?: StringWithAggregatesFilter<"BlogArticle"> | string
    description?: StringWithAggregatesFilter<"BlogArticle"> | string
    content?: StringWithAggregatesFilter<"BlogArticle"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogArticle"> | string | null
    authorId?: StringNullableWithAggregatesFilter<"BlogArticle"> | string | null
    authorName?: StringWithAggregatesFilter<"BlogArticle"> | string
    metaTitle?: StringNullableWithAggregatesFilter<"BlogArticle"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"BlogArticle"> | string | null
    ogImage?: StringNullableWithAggregatesFilter<"BlogArticle"> | string | null
    category?: EnumBlogCategoryWithAggregatesFilter<"BlogArticle"> | $Enums.BlogCategory
    status?: EnumBlogStatusWithAggregatesFilter<"BlogArticle"> | $Enums.BlogStatus
    featured?: BoolWithAggregatesFilter<"BlogArticle"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogArticle"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"BlogArticle"> | number
    readTime?: IntNullableWithAggregatesFilter<"BlogArticle"> | number | null
    searchKeywords?: StringNullableListFilter<"BlogArticle">
    lastIndexed?: DateTimeNullableWithAggregatesFilter<"BlogArticle"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogArticle"> | Date | string
  }

  export type BlogTagWhereInput = {
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    name?: StringFilter<"BlogTag"> | string
    slug?: StringFilter<"BlogTag"> | string
    color?: StringNullableFilter<"BlogTag"> | string | null
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    articles?: BlogArticleListRelationFilter
  }

  export type BlogTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    articles?: BlogArticleOrderByRelationAggregateInput
  }

  export type BlogTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    color?: StringNullableFilter<"BlogTag"> | string | null
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    articles?: BlogArticleListRelationFilter
  }, "id" | "name" | "slug">

  export type BlogTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlogTagCountOrderByAggregateInput
    _max?: BlogTagMaxOrderByAggregateInput
    _min?: BlogTagMinOrderByAggregateInput
  }

  export type BlogTagScalarWhereWithAggregatesInput = {
    AND?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    OR?: BlogTagScalarWhereWithAggregatesInput[]
    NOT?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogTag"> | string
    name?: StringWithAggregatesFilter<"BlogTag"> | string
    slug?: StringWithAggregatesFilter<"BlogTag"> | string
    color?: StringNullableWithAggregatesFilter<"BlogTag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogTag"> | Date | string
  }

  export type CustomerInvoiceWhereInput = {
    AND?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    OR?: CustomerInvoiceWhereInput[]
    NOT?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    id?: StringFilter<"CustomerInvoice"> | string
    invoiceNumber?: StringFilter<"CustomerInvoice"> | string
    status?: EnumCustomerInvoiceStatusFilter<"CustomerInvoice"> | $Enums.CustomerInvoiceStatus
    businessName?: StringFilter<"CustomerInvoice"> | string
    businessEmail?: StringFilter<"CustomerInvoice"> | string
    businessAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessCity?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessState?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessZip?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessPhone?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessLogo?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientName?: StringFilter<"CustomerInvoice"> | string
    clientEmail?: StringFilter<"CustomerInvoice"> | string
    clientAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientCity?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientState?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientZip?: StringNullableFilter<"CustomerInvoice"> | string | null
    issueDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    subtotal?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"CustomerInvoice"> | string | null
    terms?: StringNullableFilter<"CustomerInvoice"> | string | null
    emailCaptured?: StringNullableFilter<"CustomerInvoice"> | string | null
    downloadCount?: IntFilter<"CustomerInvoice"> | number
    isProVersion?: BoolFilter<"CustomerInvoice"> | boolean
    userAgent?: StringNullableFilter<"CustomerInvoice"> | string | null
    ipAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    createdAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    items?: CustomerInvoiceItemListRelationFilter
  }

  export type CustomerInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    businessName?: SortOrder
    businessEmail?: SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessCity?: SortOrderInput | SortOrder
    businessState?: SortOrderInput | SortOrder
    businessZip?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    businessLogo?: SortOrderInput | SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientAddress?: SortOrderInput | SortOrder
    clientCity?: SortOrderInput | SortOrder
    clientState?: SortOrderInput | SortOrder
    clientZip?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    emailCaptured?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    isProVersion?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: CustomerInvoiceItemOrderByRelationAggregateInput
  }

  export type CustomerInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    OR?: CustomerInvoiceWhereInput[]
    NOT?: CustomerInvoiceWhereInput | CustomerInvoiceWhereInput[]
    status?: EnumCustomerInvoiceStatusFilter<"CustomerInvoice"> | $Enums.CustomerInvoiceStatus
    businessName?: StringFilter<"CustomerInvoice"> | string
    businessEmail?: StringFilter<"CustomerInvoice"> | string
    businessAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessCity?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessState?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessZip?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessPhone?: StringNullableFilter<"CustomerInvoice"> | string | null
    businessLogo?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientName?: StringFilter<"CustomerInvoice"> | string
    clientEmail?: StringFilter<"CustomerInvoice"> | string
    clientAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientCity?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientState?: StringNullableFilter<"CustomerInvoice"> | string | null
    clientZip?: StringNullableFilter<"CustomerInvoice"> | string | null
    issueDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeFilter<"CustomerInvoice"> | Date | string
    subtotal?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"CustomerInvoice"> | string | null
    terms?: StringNullableFilter<"CustomerInvoice"> | string | null
    emailCaptured?: StringNullableFilter<"CustomerInvoice"> | string | null
    downloadCount?: IntFilter<"CustomerInvoice"> | number
    isProVersion?: BoolFilter<"CustomerInvoice"> | boolean
    userAgent?: StringNullableFilter<"CustomerInvoice"> | string | null
    ipAddress?: StringNullableFilter<"CustomerInvoice"> | string | null
    createdAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerInvoice"> | Date | string
    items?: CustomerInvoiceItemListRelationFilter
  }, "id" | "invoiceNumber">

  export type CustomerInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    businessName?: SortOrder
    businessEmail?: SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessCity?: SortOrderInput | SortOrder
    businessState?: SortOrderInput | SortOrder
    businessZip?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    businessLogo?: SortOrderInput | SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientAddress?: SortOrderInput | SortOrder
    clientCity?: SortOrderInput | SortOrder
    clientState?: SortOrderInput | SortOrder
    clientZip?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    emailCaptured?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    isProVersion?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerInvoiceCountOrderByAggregateInput
    _avg?: CustomerInvoiceAvgOrderByAggregateInput
    _max?: CustomerInvoiceMaxOrderByAggregateInput
    _min?: CustomerInvoiceMinOrderByAggregateInput
    _sum?: CustomerInvoiceSumOrderByAggregateInput
  }

  export type CustomerInvoiceScalarWhereWithAggregatesInput = {
    AND?: CustomerInvoiceScalarWhereWithAggregatesInput | CustomerInvoiceScalarWhereWithAggregatesInput[]
    OR?: CustomerInvoiceScalarWhereWithAggregatesInput[]
    NOT?: CustomerInvoiceScalarWhereWithAggregatesInput | CustomerInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    status?: EnumCustomerInvoiceStatusWithAggregatesFilter<"CustomerInvoice"> | $Enums.CustomerInvoiceStatus
    businessName?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    businessEmail?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    businessAddress?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    businessCity?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    businessState?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    businessZip?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    businessPhone?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    businessLogo?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    clientName?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    clientEmail?: StringWithAggregatesFilter<"CustomerInvoice"> | string
    clientAddress?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    clientCity?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    clientState?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    clientZip?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    issueDate?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
    subtotal?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"CustomerInvoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    terms?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    emailCaptured?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    downloadCount?: IntWithAggregatesFilter<"CustomerInvoice"> | number
    isProVersion?: BoolWithAggregatesFilter<"CustomerInvoice"> | boolean
    userAgent?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"CustomerInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerInvoice"> | Date | string
  }

  export type CustomerInvoiceItemWhereInput = {
    AND?: CustomerInvoiceItemWhereInput | CustomerInvoiceItemWhereInput[]
    OR?: CustomerInvoiceItemWhereInput[]
    NOT?: CustomerInvoiceItemWhereInput | CustomerInvoiceItemWhereInput[]
    id?: StringFilter<"CustomerInvoiceItem"> | string
    invoiceId?: StringFilter<"CustomerInvoiceItem"> | string
    description?: StringFilter<"CustomerInvoiceItem"> | string
    quantity?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CustomerInvoiceItem"> | Date | string
    invoice?: XOR<CustomerInvoiceScalarRelationFilter, CustomerInvoiceWhereInput>
  }

  export type CustomerInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    invoice?: CustomerInvoiceOrderByWithRelationInput
  }

  export type CustomerInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerInvoiceItemWhereInput | CustomerInvoiceItemWhereInput[]
    OR?: CustomerInvoiceItemWhereInput[]
    NOT?: CustomerInvoiceItemWhereInput | CustomerInvoiceItemWhereInput[]
    invoiceId?: StringFilter<"CustomerInvoiceItem"> | string
    description?: StringFilter<"CustomerInvoiceItem"> | string
    quantity?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CustomerInvoiceItem"> | Date | string
    invoice?: XOR<CustomerInvoiceScalarRelationFilter, CustomerInvoiceWhereInput>
  }, "id">

  export type CustomerInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerInvoiceItemCountOrderByAggregateInput
    _avg?: CustomerInvoiceItemAvgOrderByAggregateInput
    _max?: CustomerInvoiceItemMaxOrderByAggregateInput
    _min?: CustomerInvoiceItemMinOrderByAggregateInput
    _sum?: CustomerInvoiceItemSumOrderByAggregateInput
  }

  export type CustomerInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: CustomerInvoiceItemScalarWhereWithAggregatesInput | CustomerInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: CustomerInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: CustomerInvoiceItemScalarWhereWithAggregatesInput | CustomerInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerInvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"CustomerInvoiceItem"> | string
    description?: StringWithAggregatesFilter<"CustomerInvoiceItem"> | string
    quantity?: DecimalWithAggregatesFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerInvoiceItem"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    filename?: StringNullableFilter<"Document"> | string | null
    url?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: BigIntNullableFilter<"Document"> | bigint | number | null
    propertyId?: StringNullableFilter<"Document"> | string | null
    leaseId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileSizeBytes?: BigIntFilter<"Document"> | bigint | number
    Lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    Property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    filename?: SortOrderInput | SortOrder
    url?: SortOrder
    type?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    leaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrder
    Lease?: LeaseOrderByWithRelationInput
    Property?: PropertyOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    filename?: StringNullableFilter<"Document"> | string | null
    url?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: BigIntNullableFilter<"Document"> | bigint | number | null
    propertyId?: StringNullableFilter<"Document"> | string | null
    leaseId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileSizeBytes?: BigIntFilter<"Document"> | bigint | number
    Lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
    Property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    filename?: SortOrderInput | SortOrder
    url?: SortOrder
    type?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    leaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    filename?: StringNullableWithAggregatesFilter<"Document"> | string | null
    url?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    size?: BigIntNullableWithAggregatesFilter<"Document"> | bigint | number | null
    propertyId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    leaseId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    fileSizeBytes?: BigIntWithAggregatesFilter<"Document"> | bigint | number
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    propertyId?: StringFilter<"Expense"> | string
    maintenanceId?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    category?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    vendorName?: StringNullableFilter<"Expense"> | string | null
    vendorContact?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    MaintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    maintenanceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MaintenanceRequest?: MaintenanceRequestOrderByWithRelationInput
    Property?: PropertyOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    propertyId?: StringFilter<"Expense"> | string
    maintenanceId?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    category?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    vendorName?: StringNullableFilter<"Expense"> | string | null
    vendorContact?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    MaintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    maintenanceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    vendorContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    propertyId?: StringWithAggregatesFilter<"Expense"> | string
    maintenanceId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    category?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    vendorName?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    vendorContact?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type InspectionWhereInput = {
    AND?: InspectionWhereInput | InspectionWhereInput[]
    OR?: InspectionWhereInput[]
    NOT?: InspectionWhereInput | InspectionWhereInput[]
    id?: StringFilter<"Inspection"> | string
    propertyId?: StringFilter<"Inspection"> | string
    unitId?: StringNullableFilter<"Inspection"> | string | null
    inspectorId?: StringFilter<"Inspection"> | string
    type?: StringFilter<"Inspection"> | string
    scheduledDate?: DateTimeFilter<"Inspection"> | Date | string
    completedDate?: DateTimeNullableFilter<"Inspection"> | Date | string | null
    status?: StringFilter<"Inspection"> | string
    notes?: StringNullableFilter<"Inspection"> | string | null
    reportUrl?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    Unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type InspectionOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    inspectorId?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    reportUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Property?: PropertyOrderByWithRelationInput
    Unit?: UnitOrderByWithRelationInput
  }

  export type InspectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InspectionWhereInput | InspectionWhereInput[]
    OR?: InspectionWhereInput[]
    NOT?: InspectionWhereInput | InspectionWhereInput[]
    propertyId?: StringFilter<"Inspection"> | string
    unitId?: StringNullableFilter<"Inspection"> | string | null
    inspectorId?: StringFilter<"Inspection"> | string
    type?: StringFilter<"Inspection"> | string
    scheduledDate?: DateTimeFilter<"Inspection"> | Date | string
    completedDate?: DateTimeNullableFilter<"Inspection"> | Date | string | null
    status?: StringFilter<"Inspection"> | string
    notes?: StringNullableFilter<"Inspection"> | string | null
    reportUrl?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    Unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type InspectionOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    inspectorId?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    reportUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InspectionCountOrderByAggregateInput
    _max?: InspectionMaxOrderByAggregateInput
    _min?: InspectionMinOrderByAggregateInput
  }

  export type InspectionScalarWhereWithAggregatesInput = {
    AND?: InspectionScalarWhereWithAggregatesInput | InspectionScalarWhereWithAggregatesInput[]
    OR?: InspectionScalarWhereWithAggregatesInput[]
    NOT?: InspectionScalarWhereWithAggregatesInput | InspectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inspection"> | string
    propertyId?: StringWithAggregatesFilter<"Inspection"> | string
    unitId?: StringNullableWithAggregatesFilter<"Inspection"> | string | null
    inspectorId?: StringWithAggregatesFilter<"Inspection"> | string
    type?: StringWithAggregatesFilter<"Inspection"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"Inspection"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"Inspection"> | Date | string | null
    status?: StringWithAggregatesFilter<"Inspection"> | string
    notes?: StringNullableWithAggregatesFilter<"Inspection"> | string | null
    reportUrl?: StringNullableWithAggregatesFilter<"Inspection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inspection"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringFilter<"Invoice"> | string
    amountPaid?: IntFilter<"Invoice"> | number
    amountDue?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"Invoice"> | string | null
    invoicePdf?: StringNullableFilter<"Invoice"> | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    Subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrder
    amountPaid?: SortOrder
    amountDue?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    invoicePdf?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Subscription?: SubscriptionOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    amountPaid?: IntFilter<"Invoice"> | number
    amountDue?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"Invoice"> | string | null
    invoicePdf?: StringNullableFilter<"Invoice"> | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    Subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "stripeInvoiceId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrder
    amountPaid?: SortOrder
    amountDue?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    invoicePdf?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringWithAggregatesFilter<"Invoice"> | string
    amountPaid?: IntWithAggregatesFilter<"Invoice"> | number
    amountDue?: IntWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoicePdf?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLeadCaptureWhereInput = {
    AND?: InvoiceLeadCaptureWhereInput | InvoiceLeadCaptureWhereInput[]
    OR?: InvoiceLeadCaptureWhereInput[]
    NOT?: InvoiceLeadCaptureWhereInput | InvoiceLeadCaptureWhereInput[]
    id?: StringFilter<"InvoiceLeadCapture"> | string
    email?: StringFilter<"InvoiceLeadCapture"> | string
    invoiceId?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    firstName?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    lastName?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    company?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    source?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    medium?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    campaign?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    emailSent?: BoolFilter<"InvoiceLeadCapture"> | boolean
    emailOpened?: BoolFilter<"InvoiceLeadCapture"> | boolean
    linkClicked?: BoolFilter<"InvoiceLeadCapture"> | boolean
    converted?: BoolFilter<"InvoiceLeadCapture"> | boolean
    createdAt?: DateTimeFilter<"InvoiceLeadCapture"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLeadCapture"> | Date | string
  }

  export type InvoiceLeadCaptureOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailOpened?: SortOrder
    linkClicked?: SortOrder
    converted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLeadCaptureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLeadCaptureWhereInput | InvoiceLeadCaptureWhereInput[]
    OR?: InvoiceLeadCaptureWhereInput[]
    NOT?: InvoiceLeadCaptureWhereInput | InvoiceLeadCaptureWhereInput[]
    email?: StringFilter<"InvoiceLeadCapture"> | string
    invoiceId?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    firstName?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    lastName?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    company?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    source?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    medium?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    campaign?: StringNullableFilter<"InvoiceLeadCapture"> | string | null
    emailSent?: BoolFilter<"InvoiceLeadCapture"> | boolean
    emailOpened?: BoolFilter<"InvoiceLeadCapture"> | boolean
    linkClicked?: BoolFilter<"InvoiceLeadCapture"> | boolean
    converted?: BoolFilter<"InvoiceLeadCapture"> | boolean
    createdAt?: DateTimeFilter<"InvoiceLeadCapture"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceLeadCapture"> | Date | string
  }, "id">

  export type InvoiceLeadCaptureOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailOpened?: SortOrder
    linkClicked?: SortOrder
    converted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceLeadCaptureCountOrderByAggregateInput
    _max?: InvoiceLeadCaptureMaxOrderByAggregateInput
    _min?: InvoiceLeadCaptureMinOrderByAggregateInput
  }

  export type InvoiceLeadCaptureScalarWhereWithAggregatesInput = {
    AND?: InvoiceLeadCaptureScalarWhereWithAggregatesInput | InvoiceLeadCaptureScalarWhereWithAggregatesInput[]
    OR?: InvoiceLeadCaptureScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLeadCaptureScalarWhereWithAggregatesInput | InvoiceLeadCaptureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLeadCapture"> | string
    email?: StringWithAggregatesFilter<"InvoiceLeadCapture"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    company?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    source?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    medium?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"InvoiceLeadCapture"> | string | null
    emailSent?: BoolWithAggregatesFilter<"InvoiceLeadCapture"> | boolean
    emailOpened?: BoolWithAggregatesFilter<"InvoiceLeadCapture"> | boolean
    linkClicked?: BoolWithAggregatesFilter<"InvoiceLeadCapture"> | boolean
    converted?: BoolWithAggregatesFilter<"InvoiceLeadCapture"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceLeadCapture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceLeadCapture"> | Date | string
  }

  export type LeaseWhereInput = {
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    id?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rentAmount?: FloatFilter<"Lease"> | number
    securityDeposit?: FloatFilter<"Lease"> | number
    terms?: StringNullableFilter<"Lease"> | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    Document?: DocumentListRelationFilter
    Tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    Unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    reminders?: ReminderLogListRelationFilter
  }

  export type LeaseOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Document?: DocumentOrderByRelationAggregateInput
    Tenant?: TenantOrderByWithRelationInput
    Unit?: UnitOrderByWithRelationInput
    reminders?: ReminderLogOrderByRelationAggregateInput
  }

  export type LeaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaseWhereInput | LeaseWhereInput[]
    OR?: LeaseWhereInput[]
    NOT?: LeaseWhereInput | LeaseWhereInput[]
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rentAmount?: FloatFilter<"Lease"> | number
    securityDeposit?: FloatFilter<"Lease"> | number
    terms?: StringNullableFilter<"Lease"> | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
    Document?: DocumentListRelationFilter
    Tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    Unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    reminders?: ReminderLogListRelationFilter
  }, "id">

  export type LeaseOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaseCountOrderByAggregateInput
    _avg?: LeaseAvgOrderByAggregateInput
    _max?: LeaseMaxOrderByAggregateInput
    _min?: LeaseMinOrderByAggregateInput
    _sum?: LeaseSumOrderByAggregateInput
  }

  export type LeaseScalarWhereWithAggregatesInput = {
    AND?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    OR?: LeaseScalarWhereWithAggregatesInput[]
    NOT?: LeaseScalarWhereWithAggregatesInput | LeaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lease"> | string
    unitId?: StringWithAggregatesFilter<"Lease"> | string
    tenantId?: StringWithAggregatesFilter<"Lease"> | string
    startDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    rentAmount?: FloatWithAggregatesFilter<"Lease"> | number
    securityDeposit?: FloatWithAggregatesFilter<"Lease"> | number
    terms?: StringNullableWithAggregatesFilter<"Lease"> | string | null
    status?: EnumLeaseStatusWithAggregatesFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lease"> | Date | string
  }

  export type LeaseGeneratorUsageWhereInput = {
    AND?: LeaseGeneratorUsageWhereInput | LeaseGeneratorUsageWhereInput[]
    OR?: LeaseGeneratorUsageWhereInput[]
    NOT?: LeaseGeneratorUsageWhereInput | LeaseGeneratorUsageWhereInput[]
    id?: StringFilter<"LeaseGeneratorUsage"> | string
    userId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    email?: StringFilter<"LeaseGeneratorUsage"> | string
    ipAddress?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    userAgent?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    usageCount?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    paymentStatus?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeSessionId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeCustomerId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    amountPaid?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    currency?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    paymentDate?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    accessExpiresAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LeaseGeneratorUsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    stripeSessionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    accessExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type LeaseGeneratorUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaseGeneratorUsageWhereInput | LeaseGeneratorUsageWhereInput[]
    OR?: LeaseGeneratorUsageWhereInput[]
    NOT?: LeaseGeneratorUsageWhereInput | LeaseGeneratorUsageWhereInput[]
    userId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    email?: StringFilter<"LeaseGeneratorUsage"> | string
    ipAddress?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    userAgent?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    usageCount?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    paymentStatus?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeSessionId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeCustomerId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    amountPaid?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    currency?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    paymentDate?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    accessExpiresAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaseGeneratorUsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    usageCount?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    stripeSessionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    paymentDate?: SortOrderInput | SortOrder
    accessExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: LeaseGeneratorUsageCountOrderByAggregateInput
    _avg?: LeaseGeneratorUsageAvgOrderByAggregateInput
    _max?: LeaseGeneratorUsageMaxOrderByAggregateInput
    _min?: LeaseGeneratorUsageMinOrderByAggregateInput
    _sum?: LeaseGeneratorUsageSumOrderByAggregateInput
  }

  export type LeaseGeneratorUsageScalarWhereWithAggregatesInput = {
    AND?: LeaseGeneratorUsageScalarWhereWithAggregatesInput | LeaseGeneratorUsageScalarWhereWithAggregatesInput[]
    OR?: LeaseGeneratorUsageScalarWhereWithAggregatesInput[]
    NOT?: LeaseGeneratorUsageScalarWhereWithAggregatesInput | LeaseGeneratorUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaseGeneratorUsage"> | string
    userId?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    email?: StringWithAggregatesFilter<"LeaseGeneratorUsage"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    usageCount?: IntNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | number | null
    paymentStatus?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    stripeSessionId?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    amountPaid?: IntNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | number | null
    currency?: StringNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | string | null
    paymentDate?: DateTimeNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | Date | string | null
    accessExpiresAt?: DateTimeNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"LeaseGeneratorUsage"> | Date | string | null
  }

  export type MaintenanceRequestWhereInput = {
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    unitId?: StringFilter<"MaintenanceRequest"> | string
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    category?: StringNullableFilter<"MaintenanceRequest"> | string | null
    priority?: EnumPriorityFilter<"MaintenanceRequest"> | $Enums.Priority
    status?: EnumRequestStatusFilter<"MaintenanceRequest"> | $Enums.RequestStatus
    preferredDate?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    allowEntry?: BoolFilter<"MaintenanceRequest"> | boolean
    contactPhone?: StringNullableFilter<"MaintenanceRequest"> | string | null
    requestedBy?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    photos?: StringNullableListFilter<"MaintenanceRequest">
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    estimatedCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    actualCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    Expense?: ExpenseListRelationFilter
    Unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    files?: FileListRelationFilter
  }

  export type MaintenanceRequestOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrderInput | SortOrder
    allowEntry?: SortOrder
    contactPhone?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    photos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    Expense?: ExpenseOrderByRelationAggregateInput
    Unit?: UnitOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type MaintenanceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    unitId?: StringFilter<"MaintenanceRequest"> | string
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    category?: StringNullableFilter<"MaintenanceRequest"> | string | null
    priority?: EnumPriorityFilter<"MaintenanceRequest"> | $Enums.Priority
    status?: EnumRequestStatusFilter<"MaintenanceRequest"> | $Enums.RequestStatus
    preferredDate?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    allowEntry?: BoolFilter<"MaintenanceRequest"> | boolean
    contactPhone?: StringNullableFilter<"MaintenanceRequest"> | string | null
    requestedBy?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    photos?: StringNullableListFilter<"MaintenanceRequest">
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    estimatedCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    actualCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    Expense?: ExpenseListRelationFilter
    Unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    files?: FileListRelationFilter
  }, "id">

  export type MaintenanceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrderInput | SortOrder
    allowEntry?: SortOrder
    contactPhone?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    photos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    _count?: MaintenanceRequestCountOrderByAggregateInput
    _avg?: MaintenanceRequestAvgOrderByAggregateInput
    _max?: MaintenanceRequestMaxOrderByAggregateInput
    _min?: MaintenanceRequestMinOrderByAggregateInput
    _sum?: MaintenanceRequestSumOrderByAggregateInput
  }

  export type MaintenanceRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    unitId?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    title?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    description?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    category?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"MaintenanceRequest"> | $Enums.Priority
    status?: EnumRequestStatusWithAggregatesFilter<"MaintenanceRequest"> | $Enums.RequestStatus
    preferredDate?: DateTimeNullableWithAggregatesFilter<"MaintenanceRequest"> | Date | string | null
    allowEntry?: BoolWithAggregatesFilter<"MaintenanceRequest"> | boolean
    contactPhone?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    requestedBy?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    photos?: StringNullableListFilter<"MaintenanceRequest">
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceRequest"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    estimatedCost?: FloatNullableWithAggregatesFilter<"MaintenanceRequest"> | number | null
    actualCost?: FloatNullableWithAggregatesFilter<"MaintenanceRequest"> | number | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    User_Message_receiverIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Message_senderIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    readAt?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User_Message_receiverIdToUser?: UserOrderByWithRelationInput
    User_Message_senderIdToUser?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    User_Message_receiverIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Message_senderIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    readAt?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    threadId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zipCode?: StringFilter<"Property"> | string
    description?: StringNullableFilter<"Property"> | string | null
    imageUrl?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    Document?: DocumentListRelationFilter
    Expense?: ExpenseListRelationFilter
    Inspection?: InspectionListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Unit?: UnitListRelationFilter
    files?: FileListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyType?: SortOrder
    Document?: DocumentOrderByRelationAggregateInput
    Expense?: ExpenseOrderByRelationAggregateInput
    Inspection?: InspectionOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    Unit?: UnitOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zipCode?: StringFilter<"Property"> | string
    description?: StringNullableFilter<"Property"> | string | null
    imageUrl?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    Document?: DocumentListRelationFilter
    Expense?: ExpenseListRelationFilter
    Inspection?: InspectionListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Unit?: UnitListRelationFilter
    files?: FileListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyType?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    address?: StringWithAggregatesFilter<"Property"> | string
    city?: StringWithAggregatesFilter<"Property"> | string
    state?: StringWithAggregatesFilter<"Property"> | string
    zipCode?: StringWithAggregatesFilter<"Property"> | string
    description?: StringNullableWithAggregatesFilter<"Property"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerId?: StringWithAggregatesFilter<"Property"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    propertyType?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    status?: EnumSubStatusFilter<"Subscription"> | $Enums.SubStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    planId?: StringNullableFilter<"Subscription"> | string | null
    planType?: EnumPlanTypeNullableFilter<"Subscription"> | $Enums.PlanType | null
    billingPeriod?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolNullableFilter<"Subscription"> | boolean | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    Invoice?: InvoiceListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentFailures?: PaymentFailureListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    planType?: SortOrderInput | SortOrder
    billingPeriod?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    Invoice?: InvoiceOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    paymentFailures?: PaymentFailureOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    status?: EnumSubStatusFilter<"Subscription"> | $Enums.SubStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    planId?: StringNullableFilter<"Subscription"> | string | null
    planType?: EnumPlanTypeNullableFilter<"Subscription"> | $Enums.PlanType | null
    billingPeriod?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolNullableFilter<"Subscription"> | boolean | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    Invoice?: InvoiceListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    paymentFailures?: PaymentFailureListRelationFilter
  }, "id" | "userId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    planType?: SortOrderInput | SortOrder
    billingPeriod?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubStatusWithAggregatesFilter<"Subscription"> | $Enums.SubStatus
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    planId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    planType?: EnumPlanTypeNullableWithAggregatesFilter<"Subscription"> | $Enums.PlanType | null
    billingPeriod?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolNullableWithAggregatesFilter<"Subscription"> | boolean | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    email?: StringFilter<"Tenant"> | string
    phone?: StringNullableFilter<"Tenant"> | string | null
    emergencyContact?: StringNullableFilter<"Tenant"> | string | null
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    userId?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    Lease?: LeaseListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lease?: LeaseOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    phone?: StringNullableFilter<"Tenant"> | string | null
    emergencyContact?: StringNullableFilter<"Tenant"> | string | null
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    userId?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    Lease?: LeaseListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "email">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    email?: StringWithAggregatesFilter<"Tenant"> | string
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    unitNumber?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    squareFeet?: IntNullableFilter<"Unit"> | number | null
    rent?: FloatFilter<"Unit"> | number
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    lastInspectionDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
    Inspection?: InspectionListRelationFilter
    Lease?: LeaseListRelationFilter
    MaintenanceRequest?: MaintenanceRequestListRelationFilter
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    propertyId?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrderInput | SortOrder
    rent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInspectionDate?: SortOrderInput | SortOrder
    Inspection?: InspectionOrderByRelationAggregateInput
    Lease?: LeaseOrderByRelationAggregateInput
    MaintenanceRequest?: MaintenanceRequestOrderByRelationAggregateInput
    Property?: PropertyOrderByWithRelationInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitNumber_propertyId?: UnitUnitNumberPropertyIdCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    unitNumber?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    squareFeet?: IntNullableFilter<"Unit"> | number | null
    rent?: FloatFilter<"Unit"> | number
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    lastInspectionDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
    Inspection?: InspectionListRelationFilter
    Lease?: LeaseListRelationFilter
    MaintenanceRequest?: MaintenanceRequestListRelationFilter
    Property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "unitNumber_propertyId">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    propertyId?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrderInput | SortOrder
    rent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInspectionDate?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    unitNumber?: StringWithAggregatesFilter<"Unit"> | string
    propertyId?: StringWithAggregatesFilter<"Unit"> | string
    bedrooms?: IntWithAggregatesFilter<"Unit"> | number
    bathrooms?: FloatWithAggregatesFilter<"Unit"> | number
    squareFeet?: IntNullableWithAggregatesFilter<"Unit"> | number | null
    rent?: FloatWithAggregatesFilter<"Unit"> | number
    status?: EnumUnitStatusWithAggregatesFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    lastInspectionDate?: DateTimeNullableWithAggregatesFilter<"Unit"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    supabaseId?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    BlogArticle?: BlogArticleListRelationFilter
    Inspection?: InspectionListRelationFilter
    Invoice?: InvoiceListRelationFilter
    LeaseGeneratorUsage?: LeaseGeneratorUsageListRelationFilter
    Message_Message_receiverIdToUser?: MessageListRelationFilter
    Message_Message_senderIdToUser?: MessageListRelationFilter
    Property?: PropertyListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    Tenant?: TenantListRelationFilter
    activities?: ActivityListRelationFilter
    reminders?: ReminderLogListRelationFilter
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    sessions?: UserSessionListRelationFilter
    featureAccess?: XOR<UserFeatureAccessNullableScalarRelationFilter, UserFeatureAccessWhereInput> | null
    accessLogs?: UserAccessLogListRelationFilter
    notificationLogs?: NotificationLogListRelationFilter
    uploadedFiles?: FileListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    BlogArticle?: BlogArticleOrderByRelationAggregateInput
    Inspection?: InspectionOrderByRelationAggregateInput
    Invoice?: InvoiceOrderByRelationAggregateInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageOrderByRelationAggregateInput
    Message_Message_receiverIdToUser?: MessageOrderByRelationAggregateInput
    Message_Message_senderIdToUser?: MessageOrderByRelationAggregateInput
    Property?: PropertyOrderByRelationAggregateInput
    Subscription?: SubscriptionOrderByRelationAggregateInput
    Tenant?: TenantOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    reminders?: ReminderLogOrderByRelationAggregateInput
    preferences?: UserPreferencesOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    featureAccess?: UserFeatureAccessOrderByWithRelationInput
    accessLogs?: UserAccessLogOrderByRelationAggregateInput
    notificationLogs?: NotificationLogOrderByRelationAggregateInput
    uploadedFiles?: FileOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    supabaseId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    BlogArticle?: BlogArticleListRelationFilter
    Inspection?: InspectionListRelationFilter
    Invoice?: InvoiceListRelationFilter
    LeaseGeneratorUsage?: LeaseGeneratorUsageListRelationFilter
    Message_Message_receiverIdToUser?: MessageListRelationFilter
    Message_Message_senderIdToUser?: MessageListRelationFilter
    Property?: PropertyListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    Tenant?: TenantListRelationFilter
    activities?: ActivityListRelationFilter
    reminders?: ReminderLogListRelationFilter
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    sessions?: UserSessionListRelationFilter
    featureAccess?: XOR<UserFeatureAccessNullableScalarRelationFilter, UserFeatureAccessWhereInput> | null
    accessLogs?: UserAccessLogListRelationFilter
    notificationLogs?: NotificationLogListRelationFilter
    uploadedFiles?: FileListRelationFilter
  }, "id" | "supabaseId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    supabaseId?: StringWithAggregatesFilter<"User"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    refreshTokenId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    invalidatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    invalidatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    refreshTokenId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    invalidatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    invalidatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    refreshTokenId?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    invalidatedAt?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type SecurityAuditLogWhereInput = {
    AND?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    OR?: SecurityAuditLogWhereInput[]
    NOT?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    id?: StringFilter<"SecurityAuditLog"> | string
    eventType?: StringFilter<"SecurityAuditLog"> | string
    severity?: StringFilter<"SecurityAuditLog"> | string
    userId?: StringNullableFilter<"SecurityAuditLog"> | string | null
    email?: StringNullableFilter<"SecurityAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SecurityAuditLog"> | string | null
    resource?: StringNullableFilter<"SecurityAuditLog"> | string | null
    action?: StringNullableFilter<"SecurityAuditLog"> | string | null
    details?: JsonFilter<"SecurityAuditLog">
    timestamp?: DateTimeFilter<"SecurityAuditLog"> | Date | string
  }

  export type SecurityAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    resource?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type SecurityAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    OR?: SecurityAuditLogWhereInput[]
    NOT?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    eventType?: StringFilter<"SecurityAuditLog"> | string
    severity?: StringFilter<"SecurityAuditLog"> | string
    userId?: StringNullableFilter<"SecurityAuditLog"> | string | null
    email?: StringNullableFilter<"SecurityAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SecurityAuditLog"> | string | null
    resource?: StringNullableFilter<"SecurityAuditLog"> | string | null
    action?: StringNullableFilter<"SecurityAuditLog"> | string | null
    details?: JsonFilter<"SecurityAuditLog">
    timestamp?: DateTimeFilter<"SecurityAuditLog"> | Date | string
  }, "id">

  export type SecurityAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    resource?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    _count?: SecurityAuditLogCountOrderByAggregateInput
    _max?: SecurityAuditLogMaxOrderByAggregateInput
    _min?: SecurityAuditLogMinOrderByAggregateInput
  }

  export type SecurityAuditLogScalarWhereWithAggregatesInput = {
    AND?: SecurityAuditLogScalarWhereWithAggregatesInput | SecurityAuditLogScalarWhereWithAggregatesInput[]
    OR?: SecurityAuditLogScalarWhereWithAggregatesInput[]
    NOT?: SecurityAuditLogScalarWhereWithAggregatesInput | SecurityAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityAuditLog"> | string
    eventType?: StringWithAggregatesFilter<"SecurityAuditLog"> | string
    severity?: StringWithAggregatesFilter<"SecurityAuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    email?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    resource?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    action?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    details?: JsonWithAggregatesFilter<"SecurityAuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"SecurityAuditLog"> | Date | string
  }

  export type wrappers_fdw_statsWhereInput = {
    AND?: wrappers_fdw_statsWhereInput | wrappers_fdw_statsWhereInput[]
    OR?: wrappers_fdw_statsWhereInput[]
    NOT?: wrappers_fdw_statsWhereInput | wrappers_fdw_statsWhereInput[]
    fdw_name?: StringFilter<"wrappers_fdw_stats"> | string
    create_times?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_in?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_out?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_in?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_out?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    metadata?: JsonNullableFilter<"wrappers_fdw_stats">
    created_at?: DateTimeFilter<"wrappers_fdw_stats"> | Date | string
    updated_at?: DateTimeFilter<"wrappers_fdw_stats"> | Date | string
  }

  export type wrappers_fdw_statsOrderByWithRelationInput = {
    fdw_name?: SortOrder
    create_times?: SortOrderInput | SortOrder
    rows_in?: SortOrderInput | SortOrder
    rows_out?: SortOrderInput | SortOrder
    bytes_in?: SortOrderInput | SortOrder
    bytes_out?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type wrappers_fdw_statsWhereUniqueInput = Prisma.AtLeast<{
    fdw_name?: string
    AND?: wrappers_fdw_statsWhereInput | wrappers_fdw_statsWhereInput[]
    OR?: wrappers_fdw_statsWhereInput[]
    NOT?: wrappers_fdw_statsWhereInput | wrappers_fdw_statsWhereInput[]
    create_times?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_in?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_out?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_in?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_out?: BigIntNullableFilter<"wrappers_fdw_stats"> | bigint | number | null
    metadata?: JsonNullableFilter<"wrappers_fdw_stats">
    created_at?: DateTimeFilter<"wrappers_fdw_stats"> | Date | string
    updated_at?: DateTimeFilter<"wrappers_fdw_stats"> | Date | string
  }, "fdw_name">

  export type wrappers_fdw_statsOrderByWithAggregationInput = {
    fdw_name?: SortOrder
    create_times?: SortOrderInput | SortOrder
    rows_in?: SortOrderInput | SortOrder
    rows_out?: SortOrderInput | SortOrder
    bytes_in?: SortOrderInput | SortOrder
    bytes_out?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: wrappers_fdw_statsCountOrderByAggregateInput
    _avg?: wrappers_fdw_statsAvgOrderByAggregateInput
    _max?: wrappers_fdw_statsMaxOrderByAggregateInput
    _min?: wrappers_fdw_statsMinOrderByAggregateInput
    _sum?: wrappers_fdw_statsSumOrderByAggregateInput
  }

  export type wrappers_fdw_statsScalarWhereWithAggregatesInput = {
    AND?: wrappers_fdw_statsScalarWhereWithAggregatesInput | wrappers_fdw_statsScalarWhereWithAggregatesInput[]
    OR?: wrappers_fdw_statsScalarWhereWithAggregatesInput[]
    NOT?: wrappers_fdw_statsScalarWhereWithAggregatesInput | wrappers_fdw_statsScalarWhereWithAggregatesInput[]
    fdw_name?: StringWithAggregatesFilter<"wrappers_fdw_stats"> | string
    create_times?: BigIntNullableWithAggregatesFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_in?: BigIntNullableWithAggregatesFilter<"wrappers_fdw_stats"> | bigint | number | null
    rows_out?: BigIntNullableWithAggregatesFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_in?: BigIntNullableWithAggregatesFilter<"wrappers_fdw_stats"> | bigint | number | null
    bytes_out?: BigIntNullableWithAggregatesFilter<"wrappers_fdw_stats"> | bigint | number | null
    metadata?: JsonNullableWithAggregatesFilter<"wrappers_fdw_stats">
    created_at?: DateTimeWithAggregatesFilter<"wrappers_fdw_stats"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"wrappers_fdw_stats"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: EnumActivityEntityTypeFilter<"Activity"> | $Enums.ActivityEntityType
    entityId?: StringFilter<"Activity"> | string
    entityName?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: EnumActivityEntityTypeFilter<"Activity"> | $Enums.ActivityEntityType
    entityId?: StringFilter<"Activity"> | string
    entityName?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    action?: StringWithAggregatesFilter<"Activity"> | string
    entityType?: EnumActivityEntityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityEntityType
    entityId?: StringWithAggregatesFilter<"Activity"> | string
    entityName?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    stripeEventId?: StringFilter<"WebhookEvent"> | string
    eventType?: StringFilter<"WebhookEvent"> | string
    processed?: BoolFilter<"WebhookEvent"> | boolean
    processingTime?: IntNullableFilter<"WebhookEvent"> | number | null
    errorMessage?: StringNullableFilter<"WebhookEvent"> | string | null
    retryCount?: IntFilter<"WebhookEvent"> | number
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    stripeEventId?: SortOrder
    eventType?: SortOrder
    processed?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeEventId?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    eventType?: StringFilter<"WebhookEvent"> | string
    processed?: BoolFilter<"WebhookEvent"> | boolean
    processingTime?: IntNullableFilter<"WebhookEvent"> | number | null
    errorMessage?: StringNullableFilter<"WebhookEvent"> | string | null
    retryCount?: IntFilter<"WebhookEvent"> | number
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }, "id" | "stripeEventId">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    stripeEventId?: SortOrder
    eventType?: SortOrder
    processed?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _avg?: WebhookEventAvgOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
    _sum?: WebhookEventSumOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    stripeEventId?: StringWithAggregatesFilter<"WebhookEvent"> | string
    eventType?: StringWithAggregatesFilter<"WebhookEvent"> | string
    processed?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    processingTime?: IntNullableWithAggregatesFilter<"WebhookEvent"> | number | null
    errorMessage?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    retryCount?: IntWithAggregatesFilter<"WebhookEvent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
  }

  export type ReminderLogWhereInput = {
    AND?: ReminderLogWhereInput | ReminderLogWhereInput[]
    OR?: ReminderLogWhereInput[]
    NOT?: ReminderLogWhereInput | ReminderLogWhereInput[]
    id?: StringFilter<"ReminderLog"> | string
    leaseId?: StringNullableFilter<"ReminderLog"> | string | null
    userId?: StringFilter<"ReminderLog"> | string
    type?: EnumReminderTypeFilter<"ReminderLog"> | $Enums.ReminderType
    status?: EnumReminderStatusFilter<"ReminderLog"> | $Enums.ReminderStatus
    recipientEmail?: StringFilter<"ReminderLog"> | string
    recipientName?: StringNullableFilter<"ReminderLog"> | string | null
    subject?: StringNullableFilter<"ReminderLog"> | string | null
    content?: StringNullableFilter<"ReminderLog"> | string | null
    sentAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ReminderLog"> | string | null
    retryCount?: IntFilter<"ReminderLog"> | number
    createdAt?: DateTimeFilter<"ReminderLog"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
  }

  export type ReminderLogOrderByWithRelationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Lease?: LeaseOrderByWithRelationInput
  }

  export type ReminderLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReminderLogWhereInput | ReminderLogWhereInput[]
    OR?: ReminderLogWhereInput[]
    NOT?: ReminderLogWhereInput | ReminderLogWhereInput[]
    leaseId?: StringNullableFilter<"ReminderLog"> | string | null
    userId?: StringFilter<"ReminderLog"> | string
    type?: EnumReminderTypeFilter<"ReminderLog"> | $Enums.ReminderType
    status?: EnumReminderStatusFilter<"ReminderLog"> | $Enums.ReminderStatus
    recipientEmail?: StringFilter<"ReminderLog"> | string
    recipientName?: StringNullableFilter<"ReminderLog"> | string | null
    subject?: StringNullableFilter<"ReminderLog"> | string | null
    content?: StringNullableFilter<"ReminderLog"> | string | null
    sentAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ReminderLog"> | string | null
    retryCount?: IntFilter<"ReminderLog"> | number
    createdAt?: DateTimeFilter<"ReminderLog"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lease?: XOR<LeaseNullableScalarRelationFilter, LeaseWhereInput> | null
  }, "id">

  export type ReminderLogOrderByWithAggregationInput = {
    id?: SortOrder
    leaseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    openedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReminderLogCountOrderByAggregateInput
    _avg?: ReminderLogAvgOrderByAggregateInput
    _max?: ReminderLogMaxOrderByAggregateInput
    _min?: ReminderLogMinOrderByAggregateInput
    _sum?: ReminderLogSumOrderByAggregateInput
  }

  export type ReminderLogScalarWhereWithAggregatesInput = {
    AND?: ReminderLogScalarWhereWithAggregatesInput | ReminderLogScalarWhereWithAggregatesInput[]
    OR?: ReminderLogScalarWhereWithAggregatesInput[]
    NOT?: ReminderLogScalarWhereWithAggregatesInput | ReminderLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReminderLog"> | string
    leaseId?: StringNullableWithAggregatesFilter<"ReminderLog"> | string | null
    userId?: StringWithAggregatesFilter<"ReminderLog"> | string
    type?: EnumReminderTypeWithAggregatesFilter<"ReminderLog"> | $Enums.ReminderType
    status?: EnumReminderStatusWithAggregatesFilter<"ReminderLog"> | $Enums.ReminderStatus
    recipientEmail?: StringWithAggregatesFilter<"ReminderLog"> | string
    recipientName?: StringNullableWithAggregatesFilter<"ReminderLog"> | string | null
    subject?: StringNullableWithAggregatesFilter<"ReminderLog"> | string | null
    content?: StringNullableWithAggregatesFilter<"ReminderLog"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"ReminderLog"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"ReminderLog"> | Date | string | null
    openedAt?: DateTimeNullableWithAggregatesFilter<"ReminderLog"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ReminderLog"> | string | null
    retryCount?: IntWithAggregatesFilter<"ReminderLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReminderLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReminderLog"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    enableReminders?: BoolFilter<"UserPreferences"> | boolean
    daysBeforeDue?: IntFilter<"UserPreferences"> | number
    enableOverdueReminders?: BoolFilter<"UserPreferences"> | boolean
    overdueGracePeriod?: IntFilter<"UserPreferences"> | number
    autoSendReminders?: BoolFilter<"UserPreferences"> | boolean
    emailNotifications?: BoolFilter<"UserPreferences"> | boolean
    smsNotifications?: BoolFilter<"UserPreferences"> | boolean
    pushNotifications?: BoolFilter<"UserPreferences"> | boolean
    defaultDashboardView?: StringFilter<"UserPreferences"> | string
    showWelcomeMessage?: BoolFilter<"UserPreferences"> | boolean
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    enableReminders?: SortOrder
    daysBeforeDue?: SortOrder
    enableOverdueReminders?: SortOrder
    overdueGracePeriod?: SortOrder
    autoSendReminders?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    defaultDashboardView?: SortOrder
    showWelcomeMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    enableReminders?: BoolFilter<"UserPreferences"> | boolean
    daysBeforeDue?: IntFilter<"UserPreferences"> | number
    enableOverdueReminders?: BoolFilter<"UserPreferences"> | boolean
    overdueGracePeriod?: IntFilter<"UserPreferences"> | number
    autoSendReminders?: BoolFilter<"UserPreferences"> | boolean
    emailNotifications?: BoolFilter<"UserPreferences"> | boolean
    smsNotifications?: BoolFilter<"UserPreferences"> | boolean
    pushNotifications?: BoolFilter<"UserPreferences"> | boolean
    defaultDashboardView?: StringFilter<"UserPreferences"> | string
    showWelcomeMessage?: BoolFilter<"UserPreferences"> | boolean
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    enableReminders?: SortOrder
    daysBeforeDue?: SortOrder
    enableOverdueReminders?: SortOrder
    overdueGracePeriod?: SortOrder
    autoSendReminders?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    defaultDashboardView?: SortOrder
    showWelcomeMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    enableReminders?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    daysBeforeDue?: IntWithAggregatesFilter<"UserPreferences"> | number
    enableOverdueReminders?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    overdueGracePeriod?: IntWithAggregatesFilter<"UserPreferences"> | number
    autoSendReminders?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    emailNotifications?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    pushNotifications?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    defaultDashboardView?: StringWithAggregatesFilter<"UserPreferences"> | string
    showWelcomeMessage?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type UserFeatureAccessWhereInput = {
    AND?: UserFeatureAccessWhereInput | UserFeatureAccessWhereInput[]
    OR?: UserFeatureAccessWhereInput[]
    NOT?: UserFeatureAccessWhereInput | UserFeatureAccessWhereInput[]
    id?: StringFilter<"UserFeatureAccess"> | string
    userId?: StringFilter<"UserFeatureAccess"> | string
    canExportData?: BoolFilter<"UserFeatureAccess"> | boolean
    canAccessAdvancedAnalytics?: BoolFilter<"UserFeatureAccess"> | boolean
    canUseBulkOperations?: BoolFilter<"UserFeatureAccess"> | boolean
    canAccessAPI?: BoolFilter<"UserFeatureAccess"> | boolean
    canInviteTeamMembers?: BoolFilter<"UserFeatureAccess"> | boolean
    maxProperties?: IntFilter<"UserFeatureAccess"> | number
    maxUnitsPerProperty?: IntFilter<"UserFeatureAccess"> | number
    maxStorageGB?: FloatFilter<"UserFeatureAccess"> | number
    hasPrioritySupport?: BoolFilter<"UserFeatureAccess"> | boolean
    canUsePremiumIntegrations?: BoolFilter<"UserFeatureAccess"> | boolean
    lastUpdated?: DateTimeFilter<"UserFeatureAccess"> | Date | string
    updateReason?: StringNullableFilter<"UserFeatureAccess"> | string | null
    createdAt?: DateTimeFilter<"UserFeatureAccess"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFeatureAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    canExportData?: SortOrder
    canAccessAdvancedAnalytics?: SortOrder
    canUseBulkOperations?: SortOrder
    canAccessAPI?: SortOrder
    canInviteTeamMembers?: SortOrder
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
    hasPrioritySupport?: SortOrder
    canUsePremiumIntegrations?: SortOrder
    lastUpdated?: SortOrder
    updateReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type UserFeatureAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserFeatureAccessWhereInput | UserFeatureAccessWhereInput[]
    OR?: UserFeatureAccessWhereInput[]
    NOT?: UserFeatureAccessWhereInput | UserFeatureAccessWhereInput[]
    canExportData?: BoolFilter<"UserFeatureAccess"> | boolean
    canAccessAdvancedAnalytics?: BoolFilter<"UserFeatureAccess"> | boolean
    canUseBulkOperations?: BoolFilter<"UserFeatureAccess"> | boolean
    canAccessAPI?: BoolFilter<"UserFeatureAccess"> | boolean
    canInviteTeamMembers?: BoolFilter<"UserFeatureAccess"> | boolean
    maxProperties?: IntFilter<"UserFeatureAccess"> | number
    maxUnitsPerProperty?: IntFilter<"UserFeatureAccess"> | number
    maxStorageGB?: FloatFilter<"UserFeatureAccess"> | number
    hasPrioritySupport?: BoolFilter<"UserFeatureAccess"> | boolean
    canUsePremiumIntegrations?: BoolFilter<"UserFeatureAccess"> | boolean
    lastUpdated?: DateTimeFilter<"UserFeatureAccess"> | Date | string
    updateReason?: StringNullableFilter<"UserFeatureAccess"> | string | null
    createdAt?: DateTimeFilter<"UserFeatureAccess"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserFeatureAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    canExportData?: SortOrder
    canAccessAdvancedAnalytics?: SortOrder
    canUseBulkOperations?: SortOrder
    canAccessAPI?: SortOrder
    canInviteTeamMembers?: SortOrder
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
    hasPrioritySupport?: SortOrder
    canUsePremiumIntegrations?: SortOrder
    lastUpdated?: SortOrder
    updateReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserFeatureAccessCountOrderByAggregateInput
    _avg?: UserFeatureAccessAvgOrderByAggregateInput
    _max?: UserFeatureAccessMaxOrderByAggregateInput
    _min?: UserFeatureAccessMinOrderByAggregateInput
    _sum?: UserFeatureAccessSumOrderByAggregateInput
  }

  export type UserFeatureAccessScalarWhereWithAggregatesInput = {
    AND?: UserFeatureAccessScalarWhereWithAggregatesInput | UserFeatureAccessScalarWhereWithAggregatesInput[]
    OR?: UserFeatureAccessScalarWhereWithAggregatesInput[]
    NOT?: UserFeatureAccessScalarWhereWithAggregatesInput | UserFeatureAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFeatureAccess"> | string
    userId?: StringWithAggregatesFilter<"UserFeatureAccess"> | string
    canExportData?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    canAccessAdvancedAnalytics?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    canUseBulkOperations?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    canAccessAPI?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    canInviteTeamMembers?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    maxProperties?: IntWithAggregatesFilter<"UserFeatureAccess"> | number
    maxUnitsPerProperty?: IntWithAggregatesFilter<"UserFeatureAccess"> | number
    maxStorageGB?: FloatWithAggregatesFilter<"UserFeatureAccess"> | number
    hasPrioritySupport?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    canUsePremiumIntegrations?: BoolWithAggregatesFilter<"UserFeatureAccess"> | boolean
    lastUpdated?: DateTimeWithAggregatesFilter<"UserFeatureAccess"> | Date | string
    updateReason?: StringNullableWithAggregatesFilter<"UserFeatureAccess"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserFeatureAccess"> | Date | string
  }

  export type UserAccessLogWhereInput = {
    AND?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    OR?: UserAccessLogWhereInput[]
    NOT?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    id?: StringFilter<"UserAccessLog"> | string
    userId?: StringFilter<"UserAccessLog"> | string
    subscriptionStatus?: StringFilter<"UserAccessLog"> | string
    planType?: StringFilter<"UserAccessLog"> | string
    reason?: StringFilter<"UserAccessLog"> | string
    accessGranted?: JsonFilter<"UserAccessLog">
    timestamp?: DateTimeFilter<"UserAccessLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionStatus?: SortOrder
    planType?: SortOrder
    reason?: SortOrder
    accessGranted?: SortOrder
    timestamp?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type UserAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    OR?: UserAccessLogWhereInput[]
    NOT?: UserAccessLogWhereInput | UserAccessLogWhereInput[]
    userId?: StringFilter<"UserAccessLog"> | string
    subscriptionStatus?: StringFilter<"UserAccessLog"> | string
    planType?: StringFilter<"UserAccessLog"> | string
    reason?: StringFilter<"UserAccessLog"> | string
    accessGranted?: JsonFilter<"UserAccessLog">
    timestamp?: DateTimeFilter<"UserAccessLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionStatus?: SortOrder
    planType?: SortOrder
    reason?: SortOrder
    accessGranted?: SortOrder
    timestamp?: SortOrder
    _count?: UserAccessLogCountOrderByAggregateInput
    _max?: UserAccessLogMaxOrderByAggregateInput
    _min?: UserAccessLogMinOrderByAggregateInput
  }

  export type UserAccessLogScalarWhereWithAggregatesInput = {
    AND?: UserAccessLogScalarWhereWithAggregatesInput | UserAccessLogScalarWhereWithAggregatesInput[]
    OR?: UserAccessLogScalarWhereWithAggregatesInput[]
    NOT?: UserAccessLogScalarWhereWithAggregatesInput | UserAccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAccessLog"> | string
    userId?: StringWithAggregatesFilter<"UserAccessLog"> | string
    subscriptionStatus?: StringWithAggregatesFilter<"UserAccessLog"> | string
    planType?: StringWithAggregatesFilter<"UserAccessLog"> | string
    reason?: StringWithAggregatesFilter<"UserAccessLog"> | string
    accessGranted?: JsonWithAggregatesFilter<"UserAccessLog">
    timestamp?: DateTimeWithAggregatesFilter<"UserAccessLog"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonFilter<"NotificationLog">
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonFilter<"NotificationLog">
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    type?: StringWithAggregatesFilter<"NotificationLog"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    metadata?: JsonWithAggregatesFilter<"NotificationLog">
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type FailedWebhookEventWhereInput = {
    AND?: FailedWebhookEventWhereInput | FailedWebhookEventWhereInput[]
    OR?: FailedWebhookEventWhereInput[]
    NOT?: FailedWebhookEventWhereInput | FailedWebhookEventWhereInput[]
    id?: StringFilter<"FailedWebhookEvent"> | string
    eventId?: StringFilter<"FailedWebhookEvent"> | string
    eventType?: StringFilter<"FailedWebhookEvent"> | string
    payload?: StringFilter<"FailedWebhookEvent"> | string
    signature?: StringFilter<"FailedWebhookEvent"> | string
    failureReason?: StringFilter<"FailedWebhookEvent"> | string
    failureCount?: IntFilter<"FailedWebhookEvent"> | number
    firstFailedAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
    lastRetryAt?: DateTimeNullableFilter<"FailedWebhookEvent"> | Date | string | null
    nextRetryAt?: DateTimeNullableFilter<"FailedWebhookEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
    updatedAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
  }

  export type FailedWebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    failureReason?: SortOrder
    failureCount?: SortOrder
    firstFailedAt?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FailedWebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: FailedWebhookEventWhereInput | FailedWebhookEventWhereInput[]
    OR?: FailedWebhookEventWhereInput[]
    NOT?: FailedWebhookEventWhereInput | FailedWebhookEventWhereInput[]
    eventType?: StringFilter<"FailedWebhookEvent"> | string
    payload?: StringFilter<"FailedWebhookEvent"> | string
    signature?: StringFilter<"FailedWebhookEvent"> | string
    failureReason?: StringFilter<"FailedWebhookEvent"> | string
    failureCount?: IntFilter<"FailedWebhookEvent"> | number
    firstFailedAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
    lastRetryAt?: DateTimeNullableFilter<"FailedWebhookEvent"> | Date | string | null
    nextRetryAt?: DateTimeNullableFilter<"FailedWebhookEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
    updatedAt?: DateTimeFilter<"FailedWebhookEvent"> | Date | string
  }, "id" | "eventId">

  export type FailedWebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    failureReason?: SortOrder
    failureCount?: SortOrder
    firstFailedAt?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FailedWebhookEventCountOrderByAggregateInput
    _avg?: FailedWebhookEventAvgOrderByAggregateInput
    _max?: FailedWebhookEventMaxOrderByAggregateInput
    _min?: FailedWebhookEventMinOrderByAggregateInput
    _sum?: FailedWebhookEventSumOrderByAggregateInput
  }

  export type FailedWebhookEventScalarWhereWithAggregatesInput = {
    AND?: FailedWebhookEventScalarWhereWithAggregatesInput | FailedWebhookEventScalarWhereWithAggregatesInput[]
    OR?: FailedWebhookEventScalarWhereWithAggregatesInput[]
    NOT?: FailedWebhookEventScalarWhereWithAggregatesInput | FailedWebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    eventId?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    eventType?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    payload?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    signature?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    failureReason?: StringWithAggregatesFilter<"FailedWebhookEvent"> | string
    failureCount?: IntWithAggregatesFilter<"FailedWebhookEvent"> | number
    firstFailedAt?: DateTimeWithAggregatesFilter<"FailedWebhookEvent"> | Date | string
    lastRetryAt?: DateTimeNullableWithAggregatesFilter<"FailedWebhookEvent"> | Date | string | null
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"FailedWebhookEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FailedWebhookEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FailedWebhookEvent"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntNullableFilter<"File"> | number | null
    url?: StringFilter<"File"> | string
    uploadedById?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    UploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    MaintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrderInput | SortOrder
    url?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    maintenanceRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    UploadedBy?: UserOrderByWithRelationInput
    Property?: PropertyOrderByWithRelationInput
    MaintenanceRequest?: MaintenanceRequestOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntNullableFilter<"File"> | number | null
    url?: StringFilter<"File"> | string
    uploadedById?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    UploadedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    MaintenanceRequest?: XOR<MaintenanceRequestNullableScalarRelationFilter, MaintenanceRequestWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrderInput | SortOrder
    url?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    maintenanceRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    originalName?: StringWithAggregatesFilter<"File"> | string
    mimeType?: StringWithAggregatesFilter<"File"> | string
    size?: IntNullableWithAggregatesFilter<"File"> | number | null
    url?: StringWithAggregatesFilter<"File"> | string
    uploadedById?: StringNullableWithAggregatesFilter<"File"> | string | null
    propertyId?: StringNullableWithAggregatesFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableWithAggregatesFilter<"File"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type PaymentFailureWhereInput = {
    AND?: PaymentFailureWhereInput | PaymentFailureWhereInput[]
    OR?: PaymentFailureWhereInput[]
    NOT?: PaymentFailureWhereInput | PaymentFailureWhereInput[]
    id?: StringFilter<"PaymentFailure"> | string
    subscriptionId?: StringFilter<"PaymentFailure"> | string
    stripeInvoiceId?: StringFilter<"PaymentFailure"> | string
    amount?: IntFilter<"PaymentFailure"> | number
    currency?: StringFilter<"PaymentFailure"> | string
    attemptCount?: IntFilter<"PaymentFailure"> | number
    errorCode?: StringNullableFilter<"PaymentFailure"> | string | null
    errorMessage?: StringNullableFilter<"PaymentFailure"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    resolved?: BoolFilter<"PaymentFailure"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    finalAttempt?: BoolFilter<"PaymentFailure"> | boolean
    createdAt?: DateTimeFilter<"PaymentFailure"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentFailure"> | Date | string
    Subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PaymentFailureOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    attemptCount?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    finalAttempt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PaymentFailureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    AND?: PaymentFailureWhereInput | PaymentFailureWhereInput[]
    OR?: PaymentFailureWhereInput[]
    NOT?: PaymentFailureWhereInput | PaymentFailureWhereInput[]
    subscriptionId?: StringFilter<"PaymentFailure"> | string
    amount?: IntFilter<"PaymentFailure"> | number
    currency?: StringFilter<"PaymentFailure"> | string
    attemptCount?: IntFilter<"PaymentFailure"> | number
    errorCode?: StringNullableFilter<"PaymentFailure"> | string | null
    errorMessage?: StringNullableFilter<"PaymentFailure"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    resolved?: BoolFilter<"PaymentFailure"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    finalAttempt?: BoolFilter<"PaymentFailure"> | boolean
    createdAt?: DateTimeFilter<"PaymentFailure"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentFailure"> | Date | string
    Subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id" | "stripeInvoiceId">

  export type PaymentFailureOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    attemptCount?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    finalAttempt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentFailureCountOrderByAggregateInput
    _avg?: PaymentFailureAvgOrderByAggregateInput
    _max?: PaymentFailureMaxOrderByAggregateInput
    _min?: PaymentFailureMinOrderByAggregateInput
    _sum?: PaymentFailureSumOrderByAggregateInput
  }

  export type PaymentFailureScalarWhereWithAggregatesInput = {
    AND?: PaymentFailureScalarWhereWithAggregatesInput | PaymentFailureScalarWhereWithAggregatesInput[]
    OR?: PaymentFailureScalarWhereWithAggregatesInput[]
    NOT?: PaymentFailureScalarWhereWithAggregatesInput | PaymentFailureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentFailure"> | string
    subscriptionId?: StringWithAggregatesFilter<"PaymentFailure"> | string
    stripeInvoiceId?: StringWithAggregatesFilter<"PaymentFailure"> | string
    amount?: IntWithAggregatesFilter<"PaymentFailure"> | number
    currency?: StringWithAggregatesFilter<"PaymentFailure"> | string
    attemptCount?: IntWithAggregatesFilter<"PaymentFailure"> | number
    errorCode?: StringNullableWithAggregatesFilter<"PaymentFailure"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"PaymentFailure"> | string | null
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"PaymentFailure"> | Date | string | null
    resolved?: BoolWithAggregatesFilter<"PaymentFailure"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"PaymentFailure"> | Date | string | null
    finalAttempt?: BoolWithAggregatesFilter<"PaymentFailure"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentFailure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentFailure"> | Date | string
  }

  export type BlogArticleCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagCreateNestedManyWithoutArticlesInput
    author?: UserCreateNestedOneWithoutBlogArticleInput
  }

  export type BlogArticleUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorId?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutArticlesInput
  }

  export type BlogArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUpdateManyWithoutArticlesNestedInput
    author?: UserUpdateOneWithoutBlogArticleNestedInput
  }

  export type BlogArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutArticlesNestedInput
  }

  export type BlogArticleCreateManyInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorId?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagCreateInput = {
    id?: string
    name: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    articles?: BlogArticleCreateNestedManyWithoutTagsInput
  }

  export type BlogTagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    color?: string | null
    createdAt?: Date | string
    articles?: BlogArticleUncheckedCreateNestedManyWithoutTagsInput
  }

  export type BlogTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: BlogArticleUpdateManyWithoutTagsNestedInput
  }

  export type BlogTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: BlogArticleUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type BlogTagCreateManyInput = {
    id?: string
    name: string
    slug: string
    color?: string | null
    createdAt?: Date | string
  }

  export type BlogTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress?: string | null
    businessCity?: string | null
    businessState?: string | null
    businessZip?: string | null
    businessPhone?: string | null
    businessLogo?: string | null
    clientName: string
    clientEmail: string
    clientAddress?: string | null
    clientCity?: string | null
    clientState?: string | null
    clientZip?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    emailCaptured?: string | null
    downloadCount?: number
    isProVersion?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CustomerInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress?: string | null
    businessCity?: string | null
    businessState?: string | null
    businessZip?: string | null
    businessPhone?: string | null
    businessLogo?: string | null
    clientName: string
    clientEmail: string
    clientAddress?: string | null
    clientCity?: string | null
    clientState?: string | null
    clientZip?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    emailCaptured?: string | null
    downloadCount?: number
    isProVersion?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CustomerInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CustomerInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CustomerInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress?: string | null
    businessCity?: string | null
    businessState?: string | null
    businessZip?: string | null
    businessPhone?: string | null
    businessLogo?: string | null
    clientName: string
    clientEmail: string
    clientAddress?: string | null
    clientCity?: string | null
    clientState?: string | null
    clientZip?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    emailCaptured?: string | null
    downloadCount?: number
    isProVersion?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemCreateInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    invoice: CustomerInvoiceCreateNestedOneWithoutItemsInput
  }

  export type CustomerInvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: CustomerInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CustomerInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
    Lease?: LeaseCreateNestedOneWithoutDocumentInput
    Property?: PropertyCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    propertyId?: string | null
    leaseId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    Lease?: LeaseUpdateOneWithoutDocumentNestedInput
    Property?: PropertyUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    propertyId?: string | null
    leaseId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ExpenseCreateInput = {
    id?: string
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    MaintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutExpenseInput
    Property: PropertyCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    propertyId: string
    maintenanceId?: string | null
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MaintenanceRequest?: MaintenanceRequestUpdateOneWithoutExpenseNestedInput
    Property?: PropertyUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    propertyId: string
    maintenanceId?: string | null
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionCreateInput = {
    id?: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutInspectionInput
    Property: PropertyCreateNestedOneWithoutInspectionInput
    Unit?: UnitCreateNestedOneWithoutInspectionInput
  }

  export type InspectionUncheckedCreateInput = {
    id?: string
    propertyId: string
    unitId?: string | null
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInspectionNestedInput
    Property?: PropertyUpdateOneRequiredWithoutInspectionNestedInput
    Unit?: UnitUpdateOneWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionCreateManyInput = {
    id?: string
    propertyId: string
    unitId?: string | null
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Subscription?: SubscriptionCreateNestedOneWithoutInvoiceInput
    User: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subscription?: SubscriptionUpdateOneWithoutInvoiceNestedInput
    User?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLeadCaptureCreateInput = {
    id?: string
    email: string
    invoiceId?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    source?: string | null
    medium?: string | null
    campaign?: string | null
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLeadCaptureUncheckedCreateInput = {
    id?: string
    email: string
    invoiceId?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    source?: string | null
    medium?: string | null
    campaign?: string | null
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLeadCaptureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailOpened?: BoolFieldUpdateOperationsInput | boolean
    linkClicked?: BoolFieldUpdateOperationsInput | boolean
    converted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLeadCaptureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailOpened?: BoolFieldUpdateOperationsInput | boolean
    linkClicked?: BoolFieldUpdateOperationsInput | boolean
    converted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLeadCaptureCreateManyInput = {
    id?: string
    email: string
    invoiceId?: string | null
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    source?: string | null
    medium?: string | null
    campaign?: string | null
    emailSent?: boolean
    emailOpened?: boolean
    linkClicked?: boolean
    converted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLeadCaptureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailOpened?: BoolFieldUpdateOperationsInput | boolean
    linkClicked?: BoolFieldUpdateOperationsInput | boolean
    converted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLeadCaptureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailOpened?: BoolFieldUpdateOperationsInput | boolean
    linkClicked?: BoolFieldUpdateOperationsInput | boolean
    converted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentCreateNestedManyWithoutLeaseInput
    Tenant: TenantCreateNestedOneWithoutLeaseInput
    Unit: UnitCreateNestedOneWithoutLeaseInput
    reminders?: ReminderLogCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutLeaseInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUpdateManyWithoutLeaseNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    Unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    reminders?: ReminderLogUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutLeaseNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseCreateManyInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseGeneratorUsageCreateInput = {
    id?: string
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    User?: UserCreateNestedOneWithoutLeaseGeneratorUsageInput
  }

  export type LeaseGeneratorUsageUncheckedCreateInput = {
    id?: string
    userId?: string | null
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LeaseGeneratorUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneWithoutLeaseGeneratorUsageNestedInput
  }

  export type LeaseGeneratorUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseGeneratorUsageCreateManyInput = {
    id?: string
    userId?: string | null
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LeaseGeneratorUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseGeneratorUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceRequestCreateInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseCreateNestedManyWithoutMaintenanceRequestInput
    Unit: UnitCreateNestedOneWithoutMaintenanceRequestInput
    files?: FileCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateInput = {
    id?: string
    unitId: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseUncheckedCreateNestedManyWithoutMaintenanceRequestInput
    files?: FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUpdateManyWithoutMaintenanceRequestNestedInput
    Unit?: UnitUpdateOneRequiredWithoutMaintenanceRequestNestedInput
    files?: FileUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
    files?: FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestCreateManyInput = {
    id?: string
    unitId: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
  }

  export type MaintenanceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MaintenanceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MessageCreateInput = {
    id?: string
    threadId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
    User_Message_receiverIdToUser: UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput
    User_Message_senderIdToUser: UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    threadId: string
    senderId: string
    receiverId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_receiverIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput
    User_Message_senderIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    threadId: string
    senderId: string
    receiverId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceCreateNestedManyWithoutSubscriptionInput
    User: UserCreateNestedOneWithoutSubscriptionInput
    paymentFailures?: PaymentFailureCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    paymentFailures?: PaymentFailureUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    User?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    paymentFailures?: PaymentFailureUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    paymentFailures?: PaymentFailureUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
    User?: UserCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
    User?: UserUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionCreateNestedManyWithoutUnitInput
    Lease?: LeaseCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutUnitInput
    Property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    unitNumber: string
    propertyId: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUnitInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateManyWithoutUnitNestedInput
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUncheckedUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    unitNumber: string
    propertyId: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogCreateInput = {
    id?: string
    eventType: string
    severity: string
    userId?: string | null
    email?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    resource?: string | null
    action?: string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SecurityAuditLogUncheckedCreateInput = {
    id?: string
    eventType: string
    severity: string
    userId?: string | null
    email?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    resource?: string | null
    action?: string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SecurityAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogCreateManyInput = {
    id?: string
    eventType: string
    severity: string
    userId?: string | null
    email?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    resource?: string | null
    action?: string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type SecurityAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    details?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wrappers_fdw_statsCreateInput = {
    fdw_name: string
    create_times?: bigint | number | null
    rows_in?: bigint | number | null
    rows_out?: bigint | number | null
    bytes_in?: bigint | number | null
    bytes_out?: bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type wrappers_fdw_statsUncheckedCreateInput = {
    fdw_name: string
    create_times?: bigint | number | null
    rows_in?: bigint | number | null
    rows_out?: bigint | number | null
    bytes_in?: bigint | number | null
    bytes_out?: bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type wrappers_fdw_statsUpdateInput = {
    fdw_name?: StringFieldUpdateOperationsInput | string
    create_times?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wrappers_fdw_statsUncheckedUpdateInput = {
    fdw_name?: StringFieldUpdateOperationsInput | string
    create_times?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wrappers_fdw_statsCreateManyInput = {
    fdw_name: string
    create_times?: bigint | number | null
    rows_in?: bigint | number | null
    rows_out?: bigint | number | null
    bytes_in?: bigint | number | null
    bytes_out?: bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type wrappers_fdw_statsUpdateManyMutationInput = {
    fdw_name?: StringFieldUpdateOperationsInput | string
    create_times?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wrappers_fdw_statsUncheckedUpdateManyInput = {
    fdw_name?: StringFieldUpdateOperationsInput | string
    create_times?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rows_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_in?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bytes_out?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    stripeEventId: string
    eventType: string
    processed?: boolean
    processingTime?: number | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    stripeEventId: string
    eventType: string
    processed?: boolean
    processingTime?: number | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    stripeEventId: string
    eventType: string
    processed?: boolean
    processingTime?: number | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeEventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogCreateInput = {
    id?: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutRemindersInput
    Lease?: LeaseCreateNestedOneWithoutRemindersInput
  }

  export type ReminderLogUncheckedCreateInput = {
    id?: string
    leaseId?: string | null
    userId: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutRemindersNestedInput
    Lease?: LeaseUpdateOneWithoutRemindersNestedInput
  }

  export type ReminderLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogCreateManyInput = {
    id?: string
    leaseId?: string | null
    userId: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    enableReminders?: boolean
    daysBeforeDue?: number
    enableOverdueReminders?: boolean
    overdueGracePeriod?: number
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: string
    showWelcomeMessage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    enableReminders?: boolean
    daysBeforeDue?: number
    enableOverdueReminders?: boolean
    overdueGracePeriod?: number
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: string
    showWelcomeMessage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    enableReminders?: boolean
    daysBeforeDue?: number
    enableOverdueReminders?: boolean
    overdueGracePeriod?: number
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: string
    showWelcomeMessage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureAccessCreateInput = {
    id?: string
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: number
    maxUnitsPerProperty?: number
    maxStorageGB?: number
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: Date | string
    updateReason?: string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutFeatureAccessInput
  }

  export type UserFeatureAccessUncheckedCreateInput = {
    id?: string
    userId: string
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: number
    maxUnitsPerProperty?: number
    maxStorageGB?: number
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: Date | string
    updateReason?: string | null
    createdAt?: Date | string
  }

  export type UserFeatureAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutFeatureAccessNestedInput
  }

  export type UserFeatureAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureAccessCreateManyInput = {
    id?: string
    userId: string
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: number
    maxUnitsPerProperty?: number
    maxStorageGB?: number
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: Date | string
    updateReason?: string | null
    createdAt?: Date | string
  }

  export type UserFeatureAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogCreateInput = {
    id?: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    User: UserCreateNestedOneWithoutAccessLogsInput
  }

  export type UserAccessLogUncheckedCreateInput = {
    id?: string
    userId: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type UserAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogCreateManyInput = {
    id?: string
    userId: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationLogsInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationLogsNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedWebhookEventCreateInput = {
    id?: string
    eventId: string
    eventType: string
    payload: string
    signature: string
    failureReason: string
    failureCount?: number
    firstFailedAt?: Date | string
    lastRetryAt?: Date | string | null
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FailedWebhookEventUncheckedCreateInput = {
    id?: string
    eventId: string
    eventType: string
    payload: string
    signature: string
    failureReason: string
    failureCount?: number
    firstFailedAt?: Date | string
    lastRetryAt?: Date | string | null
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FailedWebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    failureReason?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    firstFailedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedWebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    failureReason?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    firstFailedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedWebhookEventCreateManyInput = {
    id?: string
    eventId: string
    eventType: string
    payload: string
    signature: string
    failureReason: string
    failureCount?: number
    firstFailedAt?: Date | string
    lastRetryAt?: Date | string | null
    nextRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FailedWebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    failureReason?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    firstFailedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedWebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    failureReason?: StringFieldUpdateOperationsInput | string
    failureCount?: IntFieldUpdateOperationsInput | number
    firstFailedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    createdAt?: Date | string
    UploadedBy?: UserCreateNestedOneWithoutUploadedFilesInput
    Property?: PropertyCreateNestedOneWithoutFilesInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    propertyId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UploadedBy?: UserUpdateOneWithoutUploadedFilesNestedInput
    Property?: PropertyUpdateOneWithoutFilesNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    propertyId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureCreateInput = {
    id?: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Subscription: SubscriptionCreateNestedOneWithoutPaymentFailuresInput
  }

  export type PaymentFailureUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentFailureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subscription?: SubscriptionUpdateOneRequiredWithoutPaymentFailuresNestedInput
  }

  export type PaymentFailureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureCreateManyInput = {
    id?: string
    subscriptionId: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentFailureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumBlogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogCategory | EnumBlogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogCategoryFilter<$PrismaModel> | $Enums.BlogCategory
  }

  export type EnumBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusFilter<$PrismaModel> | $Enums.BlogStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlogTagListRelationFilter = {
    every?: BlogTagWhereInput
    some?: BlogTagWhereInput
    none?: BlogTagWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlogTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    readTime?: SortOrder
    searchKeywords?: SortOrder
    lastIndexed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogArticleAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    readTime?: SortOrder
  }

  export type BlogArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    readTime?: SortOrder
    lastIndexed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    readTime?: SortOrder
    lastIndexed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogArticleSumOrderByAggregateInput = {
    viewCount?: SortOrder
    readTime?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumBlogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogCategory | EnumBlogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BlogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogCategoryFilter<$PrismaModel>
    _max?: NestedEnumBlogCategoryFilter<$PrismaModel>
  }

  export type EnumBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumBlogStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BlogArticleListRelationFilter = {
    every?: BlogArticleWhereInput
    some?: BlogArticleWhereInput
    none?: BlogArticleWhereInput
  }

  export type BlogArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCustomerInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerInvoiceStatus | EnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel> | $Enums.CustomerInvoiceStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceItemListRelationFilter = {
    every?: CustomerInvoiceItemWhereInput
    some?: CustomerInvoiceItemWhereInput
    none?: CustomerInvoiceItemWhereInput
  }

  export type CustomerInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    businessName?: SortOrder
    businessEmail?: SortOrder
    businessAddress?: SortOrder
    businessCity?: SortOrder
    businessState?: SortOrder
    businessZip?: SortOrder
    businessPhone?: SortOrder
    businessLogo?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientAddress?: SortOrder
    clientCity?: SortOrder
    clientState?: SortOrder
    clientZip?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    emailCaptured?: SortOrder
    downloadCount?: SortOrder
    isProVersion?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerInvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    downloadCount?: SortOrder
  }

  export type CustomerInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    businessName?: SortOrder
    businessEmail?: SortOrder
    businessAddress?: SortOrder
    businessCity?: SortOrder
    businessState?: SortOrder
    businessZip?: SortOrder
    businessPhone?: SortOrder
    businessLogo?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientAddress?: SortOrder
    clientCity?: SortOrder
    clientState?: SortOrder
    clientZip?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    emailCaptured?: SortOrder
    downloadCount?: SortOrder
    isProVersion?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    businessName?: SortOrder
    businessEmail?: SortOrder
    businessAddress?: SortOrder
    businessCity?: SortOrder
    businessState?: SortOrder
    businessZip?: SortOrder
    businessPhone?: SortOrder
    businessLogo?: SortOrder
    clientName?: SortOrder
    clientEmail?: SortOrder
    clientAddress?: SortOrder
    clientCity?: SortOrder
    clientState?: SortOrder
    clientZip?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    emailCaptured?: SortOrder
    downloadCount?: SortOrder
    isProVersion?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerInvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    downloadCount?: SortOrder
  }

  export type EnumCustomerInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerInvoiceStatus | EnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomerInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CustomerInvoiceScalarRelationFilter = {
    is?: CustomerInvoiceWhereInput
    isNot?: CustomerInvoiceWhereInput
  }

  export type CustomerInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type CustomerInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type LeaseNullableScalarRelationFilter = {
    is?: LeaseWhereInput | null
    isNot?: LeaseWhereInput | null
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    propertyId?: SortOrder
    leaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MaintenanceRequestNullableScalarRelationFilter = {
    is?: MaintenanceRequestWhereInput | null
    isNot?: MaintenanceRequestWhereInput | null
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    maintenanceId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    receiptUrl?: SortOrder
    vendorName?: SortOrder
    vendorContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    maintenanceId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    receiptUrl?: SortOrder
    vendorName?: SortOrder
    vendorContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    maintenanceId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    receiptUrl?: SortOrder
    vendorName?: SortOrder
    vendorContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type InspectionCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    unitId?: SortOrder
    inspectorId?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    unitId?: SortOrder
    inspectorId?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    unitId?: SortOrder
    inspectorId?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    reportUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amountPaid?: SortOrder
    amountDue?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    invoicePdf?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
    amountDue?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amountPaid?: SortOrder
    amountDue?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    invoicePdf?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amountPaid?: SortOrder
    amountDue?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    invoiceUrl?: SortOrder
    invoicePdf?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amountPaid?: SortOrder
    amountDue?: SortOrder
  }

  export type InvoiceLeadCaptureCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    invoiceId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    emailSent?: SortOrder
    emailOpened?: SortOrder
    linkClicked?: SortOrder
    converted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLeadCaptureMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    invoiceId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    emailSent?: SortOrder
    emailOpened?: SortOrder
    linkClicked?: SortOrder
    converted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLeadCaptureMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    invoiceId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    emailSent?: SortOrder
    emailOpened?: SortOrder
    linkClicked?: SortOrder
    converted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type ReminderLogListRelationFilter = {
    every?: ReminderLogWhereInput
    some?: ReminderLogWhereInput
    none?: ReminderLogWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReminderLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaseCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseAvgOrderByAggregateInput = {
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
  }

  export type LeaseMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    tenantId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseSumOrderByAggregateInput = {
    rentAmount?: SortOrder
    securityDeposit?: SortOrder
  }

  export type EnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type LeaseGeneratorUsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usageCount?: SortOrder
    paymentStatus?: SortOrder
    stripeSessionId?: SortOrder
    stripeCustomerId?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    accessExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseGeneratorUsageAvgOrderByAggregateInput = {
    usageCount?: SortOrder
    amountPaid?: SortOrder
  }

  export type LeaseGeneratorUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usageCount?: SortOrder
    paymentStatus?: SortOrder
    stripeSessionId?: SortOrder
    stripeCustomerId?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    accessExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseGeneratorUsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    usageCount?: SortOrder
    paymentStatus?: SortOrder
    stripeSessionId?: SortOrder
    stripeCustomerId?: SortOrder
    amountPaid?: SortOrder
    currency?: SortOrder
    paymentDate?: SortOrder
    accessExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaseGeneratorUsageSumOrderByAggregateInput = {
    usageCount?: SortOrder
    amountPaid?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    allowEntry?: SortOrder
    contactPhone?: SortOrder
    requestedBy?: SortOrder
    notes?: SortOrder
    photos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
  }

  export type MaintenanceRequestAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
  }

  export type MaintenanceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    allowEntry?: SortOrder
    contactPhone?: SortOrder
    requestedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
  }

  export type MaintenanceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    preferredDate?: SortOrder
    allowEntry?: SortOrder
    contactPhone?: SortOrder
    requestedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    estimatedCost?: SortOrder
    actualCost?: SortOrder
  }

  export type MaintenanceRequestSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    actualCost?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    readAt?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    readAt?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    readAt?: SortOrder
    attachmentUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type InspectionListRelationFilter = {
    every?: InspectionWhereInput
    some?: InspectionWhereInput
    none?: InspectionWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type InspectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyType?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyType?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyType?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type EnumSubStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubStatus | EnumSubStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubStatusFilter<$PrismaModel> | $Enums.SubStatus
  }

  export type EnumPlanTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanTypeNullableFilter<$PrismaModel> | $Enums.PlanType | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentFailureListRelationFilter = {
    every?: PaymentFailureWhereInput
    some?: PaymentFailureWhereInput
    none?: PaymentFailureWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentFailureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    planId?: SortOrder
    planType?: SortOrder
    billingPeriod?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    planId?: SortOrder
    planType?: SortOrder
    billingPeriod?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    planId?: SortOrder
    planType?: SortOrder
    billingPeriod?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    canceledAt?: SortOrder
  }

  export type EnumSubStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubStatus | EnumSubStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubStatusFilter<$PrismaModel>
    _max?: NestedEnumSubStatusFilter<$PrismaModel>
  }

  export type EnumPlanTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlanType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type LeaseListRelationFilter = {
    every?: LeaseWhereInput
    some?: LeaseWhereInput
    none?: LeaseWhereInput
  }

  export type LeaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    avatarUrl?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    avatarUrl?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    avatarUrl?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type MaintenanceRequestListRelationFilter = {
    every?: MaintenanceRequestWhereInput
    some?: MaintenanceRequestWhereInput
    none?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitUnitNumberPropertyIdCompoundUniqueInput = {
    unitNumber: string
    propertyId: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    propertyId?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrder
    rent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInspectionDate?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrder
    rent?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    propertyId?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrder
    rent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInspectionDate?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    unitNumber?: SortOrder
    propertyId?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrder
    rent?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastInspectionDate?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    squareFeet?: SortOrder
    rent?: SortOrder
  }

  export type EnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type LeaseGeneratorUsageListRelationFilter = {
    every?: LeaseGeneratorUsageWhereInput
    some?: LeaseGeneratorUsageWhereInput
    none?: LeaseGeneratorUsageWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type UserFeatureAccessNullableScalarRelationFilter = {
    is?: UserFeatureAccessWhereInput | null
    isNot?: UserFeatureAccessWhereInput | null
  }

  export type UserAccessLogListRelationFilter = {
    every?: UserAccessLogWhereInput
    some?: UserAccessLogWhereInput
    none?: UserAccessLogWhereInput
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type LeaseGeneratorUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    stripeCustomerId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    stripeCustomerId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    supabaseId?: SortOrder
    stripeCustomerId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    invalidatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    invalidatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshTokenId?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    invalidatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SecurityAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type SecurityAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type SecurityAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type wrappers_fdw_statsCountOrderByAggregateInput = {
    fdw_name?: SortOrder
    create_times?: SortOrder
    rows_in?: SortOrder
    rows_out?: SortOrder
    bytes_in?: SortOrder
    bytes_out?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type wrappers_fdw_statsAvgOrderByAggregateInput = {
    create_times?: SortOrder
    rows_in?: SortOrder
    rows_out?: SortOrder
    bytes_in?: SortOrder
    bytes_out?: SortOrder
  }

  export type wrappers_fdw_statsMaxOrderByAggregateInput = {
    fdw_name?: SortOrder
    create_times?: SortOrder
    rows_in?: SortOrder
    rows_out?: SortOrder
    bytes_in?: SortOrder
    bytes_out?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type wrappers_fdw_statsMinOrderByAggregateInput = {
    fdw_name?: SortOrder
    create_times?: SortOrder
    rows_in?: SortOrder
    rows_out?: SortOrder
    bytes_in?: SortOrder
    bytes_out?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type wrappers_fdw_statsSumOrderByAggregateInput = {
    create_times?: SortOrder
    rows_in?: SortOrder
    rows_out?: SortOrder
    bytes_in?: SortOrder
    bytes_out?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumActivityEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeFilter<$PrismaModel> | $Enums.ActivityEntityType
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    stripeEventId?: SortOrder
    eventType?: SortOrder
    processed?: SortOrder
    processingTime?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEventAvgOrderByAggregateInput = {
    processingTime?: SortOrder
    retryCount?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeEventId?: SortOrder
    eventType?: SortOrder
    processed?: SortOrder
    processingTime?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    stripeEventId?: SortOrder
    eventType?: SortOrder
    processed?: SortOrder
    processingTime?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookEventSumOrderByAggregateInput = {
    processingTime?: SortOrder
    retryCount?: SortOrder
  }

  export type EnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type EnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type ReminderLogCountOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderLogAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type ReminderLogMaxOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderLogMinOrderByAggregateInput = {
    id?: SortOrder
    leaseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    openedAt?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderLogSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type EnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enableReminders?: SortOrder
    daysBeforeDue?: SortOrder
    enableOverdueReminders?: SortOrder
    overdueGracePeriod?: SortOrder
    autoSendReminders?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    defaultDashboardView?: SortOrder
    showWelcomeMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    daysBeforeDue?: SortOrder
    overdueGracePeriod?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enableReminders?: SortOrder
    daysBeforeDue?: SortOrder
    enableOverdueReminders?: SortOrder
    overdueGracePeriod?: SortOrder
    autoSendReminders?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    defaultDashboardView?: SortOrder
    showWelcomeMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    enableReminders?: SortOrder
    daysBeforeDue?: SortOrder
    enableOverdueReminders?: SortOrder
    overdueGracePeriod?: SortOrder
    autoSendReminders?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    defaultDashboardView?: SortOrder
    showWelcomeMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    daysBeforeDue?: SortOrder
    overdueGracePeriod?: SortOrder
  }

  export type UserFeatureAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canExportData?: SortOrder
    canAccessAdvancedAnalytics?: SortOrder
    canUseBulkOperations?: SortOrder
    canAccessAPI?: SortOrder
    canInviteTeamMembers?: SortOrder
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
    hasPrioritySupport?: SortOrder
    canUsePremiumIntegrations?: SortOrder
    lastUpdated?: SortOrder
    updateReason?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeatureAccessAvgOrderByAggregateInput = {
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
  }

  export type UserFeatureAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canExportData?: SortOrder
    canAccessAdvancedAnalytics?: SortOrder
    canUseBulkOperations?: SortOrder
    canAccessAPI?: SortOrder
    canInviteTeamMembers?: SortOrder
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
    hasPrioritySupport?: SortOrder
    canUsePremiumIntegrations?: SortOrder
    lastUpdated?: SortOrder
    updateReason?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeatureAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    canExportData?: SortOrder
    canAccessAdvancedAnalytics?: SortOrder
    canUseBulkOperations?: SortOrder
    canAccessAPI?: SortOrder
    canInviteTeamMembers?: SortOrder
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
    hasPrioritySupport?: SortOrder
    canUsePremiumIntegrations?: SortOrder
    lastUpdated?: SortOrder
    updateReason?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeatureAccessSumOrderByAggregateInput = {
    maxProperties?: SortOrder
    maxUnitsPerProperty?: SortOrder
    maxStorageGB?: SortOrder
  }

  export type UserAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionStatus?: SortOrder
    planType?: SortOrder
    reason?: SortOrder
    accessGranted?: SortOrder
    timestamp?: SortOrder
  }

  export type UserAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionStatus?: SortOrder
    planType?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type UserAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionStatus?: SortOrder
    planType?: SortOrder
    reason?: SortOrder
    timestamp?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subscriptionId?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FailedWebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    failureReason?: SortOrder
    failureCount?: SortOrder
    firstFailedAt?: SortOrder
    lastRetryAt?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FailedWebhookEventAvgOrderByAggregateInput = {
    failureCount?: SortOrder
  }

  export type FailedWebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    failureReason?: SortOrder
    failureCount?: SortOrder
    firstFailedAt?: SortOrder
    lastRetryAt?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FailedWebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    failureReason?: SortOrder
    failureCount?: SortOrder
    firstFailedAt?: SortOrder
    lastRetryAt?: SortOrder
    nextRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FailedWebhookEventSumOrderByAggregateInput = {
    failureCount?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    propertyId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    propertyId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    propertyId?: SortOrder
    maintenanceRequestId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type PaymentFailureCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    attemptCount?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    finalAttempt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentFailureAvgOrderByAggregateInput = {
    amount?: SortOrder
    attemptCount?: SortOrder
  }

  export type PaymentFailureMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    attemptCount?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    finalAttempt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentFailureMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    stripeInvoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    attemptCount?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    nextRetryAt?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    finalAttempt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentFailureSumOrderByAggregateInput = {
    amount?: SortOrder
    attemptCount?: SortOrder
  }

  export type BlogArticleCreatesearchKeywordsInput = {
    set: string[]
  }

  export type BlogTagCreateNestedManyWithoutArticlesInput = {
    create?: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput> | BlogTagCreateWithoutArticlesInput[] | BlogTagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutArticlesInput | BlogTagCreateOrConnectWithoutArticlesInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBlogArticleInput = {
    create?: XOR<UserCreateWithoutBlogArticleInput, UserUncheckedCreateWithoutBlogArticleInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogArticleInput
    connect?: UserWhereUniqueInput
  }

  export type BlogTagUncheckedCreateNestedManyWithoutArticlesInput = {
    create?: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput> | BlogTagCreateWithoutArticlesInput[] | BlogTagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutArticlesInput | BlogTagCreateOrConnectWithoutArticlesInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumBlogCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BlogCategory
  }

  export type EnumBlogStatusFieldUpdateOperationsInput = {
    set?: $Enums.BlogStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BlogArticleUpdatesearchKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BlogTagUpdateManyWithoutArticlesNestedInput = {
    create?: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput> | BlogTagCreateWithoutArticlesInput[] | BlogTagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutArticlesInput | BlogTagCreateOrConnectWithoutArticlesInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutArticlesInput | BlogTagUpsertWithWhereUniqueWithoutArticlesInput[]
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutArticlesInput | BlogTagUpdateWithWhereUniqueWithoutArticlesInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutArticlesInput | BlogTagUpdateManyWithWhereWithoutArticlesInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type UserUpdateOneWithoutBlogArticleNestedInput = {
    create?: XOR<UserCreateWithoutBlogArticleInput, UserUncheckedCreateWithoutBlogArticleInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogArticleInput
    upsert?: UserUpsertWithoutBlogArticleInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogArticleInput, UserUpdateWithoutBlogArticleInput>, UserUncheckedUpdateWithoutBlogArticleInput>
  }

  export type BlogTagUncheckedUpdateManyWithoutArticlesNestedInput = {
    create?: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput> | BlogTagCreateWithoutArticlesInput[] | BlogTagUncheckedCreateWithoutArticlesInput[]
    connectOrCreate?: BlogTagCreateOrConnectWithoutArticlesInput | BlogTagCreateOrConnectWithoutArticlesInput[]
    upsert?: BlogTagUpsertWithWhereUniqueWithoutArticlesInput | BlogTagUpsertWithWhereUniqueWithoutArticlesInput[]
    set?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    disconnect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    delete?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    connect?: BlogTagWhereUniqueInput | BlogTagWhereUniqueInput[]
    update?: BlogTagUpdateWithWhereUniqueWithoutArticlesInput | BlogTagUpdateWithWhereUniqueWithoutArticlesInput[]
    updateMany?: BlogTagUpdateManyWithWhereWithoutArticlesInput | BlogTagUpdateManyWithWhereWithoutArticlesInput[]
    deleteMany?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
  }

  export type BlogArticleCreateNestedManyWithoutTagsInput = {
    create?: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput> | BlogArticleCreateWithoutTagsInput[] | BlogArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutTagsInput | BlogArticleCreateOrConnectWithoutTagsInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
  }

  export type BlogArticleUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput> | BlogArticleCreateWithoutTagsInput[] | BlogArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutTagsInput | BlogArticleCreateOrConnectWithoutTagsInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
  }

  export type BlogArticleUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput> | BlogArticleCreateWithoutTagsInput[] | BlogArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutTagsInput | BlogArticleCreateOrConnectWithoutTagsInput[]
    upsert?: BlogArticleUpsertWithWhereUniqueWithoutTagsInput | BlogArticleUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    disconnect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    delete?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    update?: BlogArticleUpdateWithWhereUniqueWithoutTagsInput | BlogArticleUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BlogArticleUpdateManyWithWhereWithoutTagsInput | BlogArticleUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
  }

  export type BlogArticleUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput> | BlogArticleCreateWithoutTagsInput[] | BlogArticleUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutTagsInput | BlogArticleCreateOrConnectWithoutTagsInput[]
    upsert?: BlogArticleUpsertWithWhereUniqueWithoutTagsInput | BlogArticleUpsertWithWhereUniqueWithoutTagsInput[]
    set?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    disconnect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    delete?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    update?: BlogArticleUpdateWithWhereUniqueWithoutTagsInput | BlogArticleUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: BlogArticleUpdateManyWithWhereWithoutTagsInput | BlogArticleUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
  }

  export type CustomerInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceItemCreateWithoutInvoiceInput[] | CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput | CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
  }

  export type CustomerInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceItemCreateWithoutInvoiceInput[] | CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput | CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
  }

  export type EnumCustomerInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.CustomerInvoiceStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CustomerInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceItemCreateWithoutInvoiceInput[] | CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput | CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerInvoiceItemCreateManyInvoiceInputEnvelope
    set?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    disconnect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    delete?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    connect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    update?: CustomerInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | CustomerInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerInvoiceItemScalarWhereInput | CustomerInvoiceItemScalarWhereInput[]
  }

  export type CustomerInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput> | CustomerInvoiceItemCreateWithoutInvoiceInput[] | CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput | CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerInvoiceItemCreateManyInvoiceInputEnvelope
    set?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    disconnect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    delete?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    connect?: CustomerInvoiceItemWhereUniqueInput | CustomerInvoiceItemWhereUniqueInput[]
    update?: CustomerInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | CustomerInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | CustomerInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerInvoiceItemScalarWhereInput | CustomerInvoiceItemScalarWhereInput[]
  }

  export type CustomerInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<CustomerInvoiceCreateWithoutItemsInput, CustomerInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutItemsInput
    connect?: CustomerInvoiceWhereUniqueInput
  }

  export type CustomerInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CustomerInvoiceCreateWithoutItemsInput, CustomerInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CustomerInvoiceCreateOrConnectWithoutItemsInput
    upsert?: CustomerInvoiceUpsertWithoutItemsInput
    connect?: CustomerInvoiceWhereUniqueInput
    update?: XOR<XOR<CustomerInvoiceUpdateToOneWithWhereWithoutItemsInput, CustomerInvoiceUpdateWithoutItemsInput>, CustomerInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type LeaseCreateNestedOneWithoutDocumentInput = {
    create?: XOR<LeaseCreateWithoutDocumentInput, LeaseUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutDocumentInput
    connect?: LeaseWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutDocumentInput = {
    create?: XOR<PropertyCreateWithoutDocumentInput, PropertyUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDocumentInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type LeaseUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<LeaseCreateWithoutDocumentInput, LeaseUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutDocumentInput
    upsert?: LeaseUpsertWithoutDocumentInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutDocumentInput, LeaseUpdateWithoutDocumentInput>, LeaseUncheckedUpdateWithoutDocumentInput>
  }

  export type PropertyUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<PropertyCreateWithoutDocumentInput, PropertyUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDocumentInput
    upsert?: PropertyUpsertWithoutDocumentInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutDocumentInput, PropertyUpdateWithoutDocumentInput>, PropertyUncheckedUpdateWithoutDocumentInput>
  }

  export type MaintenanceRequestCreateNestedOneWithoutExpenseInput = {
    create?: XOR<MaintenanceRequestCreateWithoutExpenseInput, MaintenanceRequestUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutExpenseInput
    connect?: MaintenanceRequestWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutExpenseInput = {
    create?: XOR<PropertyCreateWithoutExpenseInput, PropertyUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutExpenseInput
    connect?: PropertyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MaintenanceRequestUpdateOneWithoutExpenseNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutExpenseInput, MaintenanceRequestUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutExpenseInput
    upsert?: MaintenanceRequestUpsertWithoutExpenseInput
    disconnect?: MaintenanceRequestWhereInput | boolean
    delete?: MaintenanceRequestWhereInput | boolean
    connect?: MaintenanceRequestWhereUniqueInput
    update?: XOR<XOR<MaintenanceRequestUpdateToOneWithWhereWithoutExpenseInput, MaintenanceRequestUpdateWithoutExpenseInput>, MaintenanceRequestUncheckedUpdateWithoutExpenseInput>
  }

  export type PropertyUpdateOneRequiredWithoutExpenseNestedInput = {
    create?: XOR<PropertyCreateWithoutExpenseInput, PropertyUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutExpenseInput
    upsert?: PropertyUpsertWithoutExpenseInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutExpenseInput, PropertyUpdateWithoutExpenseInput>, PropertyUncheckedUpdateWithoutExpenseInput>
  }

  export type UserCreateNestedOneWithoutInspectionInput = {
    create?: XOR<UserCreateWithoutInspectionInput, UserUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectionInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutInspectionInput = {
    create?: XOR<PropertyCreateWithoutInspectionInput, PropertyUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInspectionInput
    connect?: PropertyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutInspectionInput = {
    create?: XOR<UnitCreateWithoutInspectionInput, UnitUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: UnitCreateOrConnectWithoutInspectionInput
    connect?: UnitWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInspectionNestedInput = {
    create?: XOR<UserCreateWithoutInspectionInput, UserUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectionInput
    upsert?: UserUpsertWithoutInspectionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInspectionInput, UserUpdateWithoutInspectionInput>, UserUncheckedUpdateWithoutInspectionInput>
  }

  export type PropertyUpdateOneRequiredWithoutInspectionNestedInput = {
    create?: XOR<PropertyCreateWithoutInspectionInput, PropertyUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInspectionInput
    upsert?: PropertyUpsertWithoutInspectionInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutInspectionInput, PropertyUpdateWithoutInspectionInput>, PropertyUncheckedUpdateWithoutInspectionInput>
  }

  export type UnitUpdateOneWithoutInspectionNestedInput = {
    create?: XOR<UnitCreateWithoutInspectionInput, UnitUncheckedCreateWithoutInspectionInput>
    connectOrCreate?: UnitCreateOrConnectWithoutInspectionInput
    upsert?: UnitUpsertWithoutInspectionInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutInspectionInput, UnitUpdateWithoutInspectionInput>, UnitUncheckedUpdateWithoutInspectionInput>
  }

  export type SubscriptionCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<SubscriptionCreateWithoutInvoiceInput, SubscriptionUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoiceInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoiceInput, SubscriptionUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoiceInput
    upsert?: SubscriptionUpsertWithoutInvoiceInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoiceInput, SubscriptionUpdateWithoutInvoiceInput>, SubscriptionUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    upsert?: UserUpsertWithoutInvoiceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceInput, UserUpdateWithoutInvoiceInput>, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type DocumentCreateNestedManyWithoutLeaseInput = {
    create?: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput> | DocumentCreateWithoutLeaseInput[] | DocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLeaseInput | DocumentCreateOrConnectWithoutLeaseInput[]
    createMany?: DocumentCreateManyLeaseInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutLeaseInput = {
    create?: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeaseInput
    connect?: TenantWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutLeaseInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    connect?: UnitWhereUniqueInput
  }

  export type ReminderLogCreateNestedManyWithoutLeaseInput = {
    create?: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput> | ReminderLogCreateWithoutLeaseInput[] | ReminderLogUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutLeaseInput | ReminderLogCreateOrConnectWithoutLeaseInput[]
    createMany?: ReminderLogCreateManyLeaseInputEnvelope
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput> | DocumentCreateWithoutLeaseInput[] | DocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLeaseInput | DocumentCreateOrConnectWithoutLeaseInput[]
    createMany?: DocumentCreateManyLeaseInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ReminderLogUncheckedCreateNestedManyWithoutLeaseInput = {
    create?: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput> | ReminderLogCreateWithoutLeaseInput[] | ReminderLogUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutLeaseInput | ReminderLogCreateOrConnectWithoutLeaseInput[]
    createMany?: ReminderLogCreateManyLeaseInputEnvelope
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
  }

  export type EnumLeaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaseStatus
  }

  export type DocumentUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput> | DocumentCreateWithoutLeaseInput[] | DocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLeaseInput | DocumentCreateOrConnectWithoutLeaseInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLeaseInput | DocumentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: DocumentCreateManyLeaseInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLeaseInput | DocumentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLeaseInput | DocumentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutLeaseNestedInput = {
    create?: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeaseInput
    upsert?: TenantUpsertWithoutLeaseInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeaseInput, TenantUpdateWithoutLeaseInput>, TenantUncheckedUpdateWithoutLeaseInput>
  }

  export type UnitUpdateOneRequiredWithoutLeaseNestedInput = {
    create?: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
    upsert?: UnitUpsertWithoutLeaseInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutLeaseInput, UnitUpdateWithoutLeaseInput>, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type ReminderLogUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput> | ReminderLogCreateWithoutLeaseInput[] | ReminderLogUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutLeaseInput | ReminderLogCreateOrConnectWithoutLeaseInput[]
    upsert?: ReminderLogUpsertWithWhereUniqueWithoutLeaseInput | ReminderLogUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: ReminderLogCreateManyLeaseInputEnvelope
    set?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    disconnect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    delete?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    update?: ReminderLogUpdateWithWhereUniqueWithoutLeaseInput | ReminderLogUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: ReminderLogUpdateManyWithWhereWithoutLeaseInput | ReminderLogUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput> | DocumentCreateWithoutLeaseInput[] | DocumentUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutLeaseInput | DocumentCreateOrConnectWithoutLeaseInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutLeaseInput | DocumentUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: DocumentCreateManyLeaseInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutLeaseInput | DocumentUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutLeaseInput | DocumentUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ReminderLogUncheckedUpdateManyWithoutLeaseNestedInput = {
    create?: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput> | ReminderLogCreateWithoutLeaseInput[] | ReminderLogUncheckedCreateWithoutLeaseInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutLeaseInput | ReminderLogCreateOrConnectWithoutLeaseInput[]
    upsert?: ReminderLogUpsertWithWhereUniqueWithoutLeaseInput | ReminderLogUpsertWithWhereUniqueWithoutLeaseInput[]
    createMany?: ReminderLogCreateManyLeaseInputEnvelope
    set?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    disconnect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    delete?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    update?: ReminderLogUpdateWithWhereUniqueWithoutLeaseInput | ReminderLogUpdateWithWhereUniqueWithoutLeaseInput[]
    updateMany?: ReminderLogUpdateManyWithWhereWithoutLeaseInput | ReminderLogUpdateManyWithWhereWithoutLeaseInput[]
    deleteMany?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaseGeneratorUsageInput = {
    create?: XOR<UserCreateWithoutLeaseGeneratorUsageInput, UserUncheckedCreateWithoutLeaseGeneratorUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaseGeneratorUsageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLeaseGeneratorUsageNestedInput = {
    create?: XOR<UserCreateWithoutLeaseGeneratorUsageInput, UserUncheckedCreateWithoutLeaseGeneratorUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaseGeneratorUsageInput
    upsert?: UserUpsertWithoutLeaseGeneratorUsageInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaseGeneratorUsageInput, UserUpdateWithoutLeaseGeneratorUsageInput>, UserUncheckedUpdateWithoutLeaseGeneratorUsageInput>
  }

  export type MaintenanceRequestCreatephotosInput = {
    set: string[]
  }

  export type ExpenseCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput> | ExpenseCreateWithoutMaintenanceRequestInput[] | ExpenseUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaintenanceRequestInput | ExpenseCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: ExpenseCreateManyMaintenanceRequestInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type UnitCreateNestedOneWithoutMaintenanceRequestInput = {
    create?: XOR<UnitCreateWithoutMaintenanceRequestInput, UnitUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMaintenanceRequestInput
    connect?: UnitWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput> | ExpenseCreateWithoutMaintenanceRequestInput[] | ExpenseUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaintenanceRequestInput | ExpenseCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: ExpenseCreateManyMaintenanceRequestInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type MaintenanceRequestUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExpenseUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput> | ExpenseCreateWithoutMaintenanceRequestInput[] | ExpenseUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaintenanceRequestInput | ExpenseCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMaintenanceRequestInput | ExpenseUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: ExpenseCreateManyMaintenanceRequestInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMaintenanceRequestInput | ExpenseUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMaintenanceRequestInput | ExpenseUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type UnitUpdateOneRequiredWithoutMaintenanceRequestNestedInput = {
    create?: XOR<UnitCreateWithoutMaintenanceRequestInput, UnitUncheckedCreateWithoutMaintenanceRequestInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMaintenanceRequestInput
    upsert?: UnitUpsertWithoutMaintenanceRequestInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutMaintenanceRequestInput, UnitUpdateWithoutMaintenanceRequestInput>, UnitUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type FileUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput | FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput | FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMaintenanceRequestInput | FileUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput> | ExpenseCreateWithoutMaintenanceRequestInput[] | ExpenseUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaintenanceRequestInput | ExpenseCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMaintenanceRequestInput | ExpenseUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: ExpenseCreateManyMaintenanceRequestInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMaintenanceRequestInput | ExpenseUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMaintenanceRequestInput | ExpenseUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput = {
    create?: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput> | FileCreateWithoutMaintenanceRequestInput[] | FileUncheckedCreateWithoutMaintenanceRequestInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMaintenanceRequestInput | FileCreateOrConnectWithoutMaintenanceRequestInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput | FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput[]
    createMany?: FileCreateManyMaintenanceRequestInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput | FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMaintenanceRequestInput | FileUpdateManyWithWhereWithoutMaintenanceRequestInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput = {
    create?: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput = {
    create?: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput
    upsert?: UserUpsertWithoutMessage_Message_receiverIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_Message_receiverIdToUserInput, UserUpdateWithoutMessage_Message_receiverIdToUserInput>, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput
    upsert?: UserUpsertWithoutMessage_Message_senderIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_Message_senderIdToUserInput, UserUpdateWithoutMessage_Message_senderIdToUserInput>, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
  }

  export type DocumentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput> | InspectionCreateWithoutPropertyInput[] | InspectionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutPropertyInput | InspectionCreateOrConnectWithoutPropertyInput[]
    createMany?: InspectionCreateManyPropertyInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPropertyInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    connect?: UserWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput> | InspectionCreateWithoutPropertyInput[] | InspectionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutPropertyInput | InspectionCreateOrConnectWithoutPropertyInput[]
    createMany?: InspectionCreateManyPropertyInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type DocumentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPropertyInput | DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPropertyInput | DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPropertyInput | DocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPropertyInput | ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPropertyInput | ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPropertyInput | ExpenseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput> | InspectionCreateWithoutPropertyInput[] | InspectionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutPropertyInput | InspectionCreateOrConnectWithoutPropertyInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutPropertyInput | InspectionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InspectionCreateManyPropertyInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutPropertyInput | InspectionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutPropertyInput | InspectionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    upsert?: UserUpsertWithoutPropertyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyInput, UserUpdateWithoutPropertyInput>, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type FileUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPropertyInput | FileUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPropertyInput | FileUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPropertyInput | FileUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPropertyInput | DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPropertyInput | DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPropertyInput | DocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPropertyInput | ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPropertyInput | ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPropertyInput | ExpenseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput> | InspectionCreateWithoutPropertyInput[] | InspectionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutPropertyInput | InspectionCreateOrConnectWithoutPropertyInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutPropertyInput | InspectionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InspectionCreateManyPropertyInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutPropertyInput | InspectionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutPropertyInput | InspectionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput> | UnitCreateWithoutPropertyInput[] | UnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutPropertyInput | UnitCreateOrConnectWithoutPropertyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutPropertyInput | UnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: UnitCreateManyPropertyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutPropertyInput | UnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutPropertyInput | UnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput> | FileCreateWithoutPropertyInput[] | FileUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPropertyInput | FileCreateOrConnectWithoutPropertyInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPropertyInput | FileUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: FileCreateManyPropertyInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPropertyInput | FileUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPropertyInput | FileUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentFailureCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput> | PaymentFailureCreateWithoutSubscriptionInput[] | PaymentFailureUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentFailureCreateOrConnectWithoutSubscriptionInput | PaymentFailureCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentFailureCreateManySubscriptionInputEnvelope
    connect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentFailureUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput> | PaymentFailureCreateWithoutSubscriptionInput[] | PaymentFailureUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentFailureCreateOrConnectWithoutSubscriptionInput | PaymentFailureCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentFailureCreateManySubscriptionInputEnvelope
    connect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
  }

  export type EnumSubStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubStatus
  }

  export type NullableEnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentFailureUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput> | PaymentFailureCreateWithoutSubscriptionInput[] | PaymentFailureUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentFailureCreateOrConnectWithoutSubscriptionInput | PaymentFailureCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentFailureUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentFailureUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentFailureCreateManySubscriptionInputEnvelope
    set?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    disconnect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    delete?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    connect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    update?: PaymentFailureUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentFailureUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentFailureUpdateManyWithWhereWithoutSubscriptionInput | PaymentFailureUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentFailureScalarWhereInput | PaymentFailureScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentFailureUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput> | PaymentFailureCreateWithoutSubscriptionInput[] | PaymentFailureUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentFailureCreateOrConnectWithoutSubscriptionInput | PaymentFailureCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentFailureUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentFailureUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentFailureCreateManySubscriptionInputEnvelope
    set?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    disconnect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    delete?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    connect?: PaymentFailureWhereUniqueInput | PaymentFailureWhereUniqueInput[]
    update?: PaymentFailureUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentFailureUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentFailureUpdateManyWithWhereWithoutSubscriptionInput | PaymentFailureUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentFailureScalarWhereInput | PaymentFailureScalarWhereInput[]
  }

  export type LeaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput
    connect?: UserWhereUniqueInput
  }

  export type LeaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type LeaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type UserUpdateOneWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput
    upsert?: UserUpsertWithoutTenantInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantInput, UserUpdateWithoutTenantInput>, UserUncheckedUpdateWithoutTenantInput>
  }

  export type LeaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput> | LeaseCreateWithoutTenantInput[] | LeaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutTenantInput | LeaseCreateOrConnectWithoutTenantInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutTenantInput | LeaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeaseCreateManyTenantInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutTenantInput | LeaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutTenantInput | LeaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type InspectionCreateNestedManyWithoutUnitInput = {
    create?: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput> | InspectionCreateWithoutUnitInput[] | InspectionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUnitInput | InspectionCreateOrConnectWithoutUnitInput[]
    createMany?: InspectionCreateManyUnitInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type LeaseCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutUnitInput = {
    create?: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput> | MaintenanceRequestCreateWithoutUnitInput[] | MaintenanceRequestUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutUnitInput | MaintenanceRequestCreateOrConnectWithoutUnitInput[]
    createMany?: MaintenanceRequestCreateManyUnitInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type PropertyCreateNestedOneWithoutUnitInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    connect?: PropertyWhereUniqueInput
  }

  export type InspectionUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput> | InspectionCreateWithoutUnitInput[] | InspectionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUnitInput | InspectionCreateOrConnectWithoutUnitInput[]
    createMany?: InspectionCreateManyUnitInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type LeaseUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput> | MaintenanceRequestCreateWithoutUnitInput[] | MaintenanceRequestUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutUnitInput | MaintenanceRequestCreateOrConnectWithoutUnitInput[]
    createMany?: MaintenanceRequestCreateManyUnitInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type EnumUnitStatusFieldUpdateOperationsInput = {
    set?: $Enums.UnitStatus
  }

  export type InspectionUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput> | InspectionCreateWithoutUnitInput[] | InspectionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUnitInput | InspectionCreateOrConnectWithoutUnitInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutUnitInput | InspectionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InspectionCreateManyUnitInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutUnitInput | InspectionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutUnitInput | InspectionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type LeaseUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutUnitNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput> | MaintenanceRequestCreateWithoutUnitInput[] | MaintenanceRequestUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutUnitInput | MaintenanceRequestCreateOrConnectWithoutUnitInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutUnitInput | MaintenanceRequestUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: MaintenanceRequestCreateManyUnitInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutUnitInput | MaintenanceRequestUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutUnitInput | MaintenanceRequestUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type PropertyUpdateOneRequiredWithoutUnitNestedInput = {
    create?: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitInput
    upsert?: PropertyUpsertWithoutUnitInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutUnitInput, PropertyUpdateWithoutUnitInput>, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type InspectionUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput> | InspectionCreateWithoutUnitInput[] | InspectionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUnitInput | InspectionCreateOrConnectWithoutUnitInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutUnitInput | InspectionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InspectionCreateManyUnitInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutUnitInput | InspectionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutUnitInput | InspectionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type LeaseUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput> | LeaseCreateWithoutUnitInput[] | LeaseUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput | LeaseCreateOrConnectWithoutUnitInput[]
    upsert?: LeaseUpsertWithWhereUniqueWithoutUnitInput | LeaseUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: LeaseCreateManyUnitInputEnvelope
    set?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    disconnect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    delete?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    connect?: LeaseWhereUniqueInput | LeaseWhereUniqueInput[]
    update?: LeaseUpdateWithWhereUniqueWithoutUnitInput | LeaseUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: LeaseUpdateManyWithWhereWithoutUnitInput | LeaseUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput> | MaintenanceRequestCreateWithoutUnitInput[] | MaintenanceRequestUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutUnitInput | MaintenanceRequestCreateOrConnectWithoutUnitInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutUnitInput | MaintenanceRequestUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: MaintenanceRequestCreateManyUnitInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutUnitInput | MaintenanceRequestUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutUnitInput | MaintenanceRequestUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type BlogArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput> | BlogArticleCreateWithoutAuthorInput[] | BlogArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutAuthorInput | BlogArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogArticleCreateManyAuthorInputEnvelope
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutUserInput = {
    create?: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput> | InspectionCreateWithoutUserInput[] | InspectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUserInput | InspectionCreateOrConnectWithoutUserInput[]
    createMany?: InspectionCreateManyUserInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LeaseGeneratorUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput> | LeaseGeneratorUsageCreateWithoutUserInput[] | LeaseGeneratorUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaseGeneratorUsageCreateOrConnectWithoutUserInput | LeaseGeneratorUsageCreateOrConnectWithoutUserInput[]
    createMany?: LeaseGeneratorUsageCreateManyUserInputEnvelope
    connect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TenantCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReminderLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput> | ReminderLogCreateWithoutUserInput[] | ReminderLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutUserInput | ReminderLogCreateOrConnectWithoutUserInput[]
    createMany?: ReminderLogCreateManyUserInputEnvelope
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserFeatureAccessCreateNestedOneWithoutUserInput = {
    create?: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFeatureAccessCreateOrConnectWithoutUserInput
    connect?: UserFeatureAccessWhereUniqueInput
  }

  export type UserAccessLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput> | FileCreateWithoutUploadedByInput[] | FileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploadedByInput | FileCreateOrConnectWithoutUploadedByInput[]
    createMany?: FileCreateManyUploadedByInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type BlogArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput> | BlogArticleCreateWithoutAuthorInput[] | BlogArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutAuthorInput | BlogArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogArticleCreateManyAuthorInputEnvelope
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput> | InspectionCreateWithoutUserInput[] | InspectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUserInput | InspectionCreateOrConnectWithoutUserInput[]
    createMany?: InspectionCreateManyUserInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput> | LeaseGeneratorUsageCreateWithoutUserInput[] | LeaseGeneratorUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaseGeneratorUsageCreateOrConnectWithoutUserInput | LeaseGeneratorUsageCreateOrConnectWithoutUserInput[]
    createMany?: LeaseGeneratorUsageCreateManyUserInputEnvelope
    connect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReminderLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput> | ReminderLogCreateWithoutUserInput[] | ReminderLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutUserInput | ReminderLogCreateOrConnectWithoutUserInput[]
    createMany?: ReminderLogCreateManyUserInputEnvelope
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFeatureAccessCreateOrConnectWithoutUserInput
    connect?: UserFeatureAccessWhereUniqueInput
  }

  export type UserAccessLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput> | FileCreateWithoutUploadedByInput[] | FileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploadedByInput | FileCreateOrConnectWithoutUploadedByInput[]
    createMany?: FileCreateManyUploadedByInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BlogArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput> | BlogArticleCreateWithoutAuthorInput[] | BlogArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutAuthorInput | BlogArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogArticleUpsertWithWhereUniqueWithoutAuthorInput | BlogArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogArticleCreateManyAuthorInputEnvelope
    set?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    disconnect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    delete?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    update?: BlogArticleUpdateWithWhereUniqueWithoutAuthorInput | BlogArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogArticleUpdateManyWithWhereWithoutAuthorInput | BlogArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput> | InspectionCreateWithoutUserInput[] | InspectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUserInput | InspectionCreateOrConnectWithoutUserInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutUserInput | InspectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InspectionCreateManyUserInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutUserInput | InspectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutUserInput | InspectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LeaseGeneratorUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput> | LeaseGeneratorUsageCreateWithoutUserInput[] | LeaseGeneratorUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaseGeneratorUsageCreateOrConnectWithoutUserInput | LeaseGeneratorUsageCreateOrConnectWithoutUserInput[]
    upsert?: LeaseGeneratorUsageUpsertWithWhereUniqueWithoutUserInput | LeaseGeneratorUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaseGeneratorUsageCreateManyUserInputEnvelope
    set?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    disconnect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    delete?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    connect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    update?: LeaseGeneratorUsageUpdateWithWhereUniqueWithoutUserInput | LeaseGeneratorUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaseGeneratorUsageUpdateManyWithWhereWithoutUserInput | LeaseGeneratorUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaseGeneratorUsageScalarWhereInput | LeaseGeneratorUsageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TenantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutUserInput | TenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutUserInput | TenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutUserInput | TenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReminderLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput> | ReminderLogCreateWithoutUserInput[] | ReminderLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutUserInput | ReminderLogCreateOrConnectWithoutUserInput[]
    upsert?: ReminderLogUpsertWithWhereUniqueWithoutUserInput | ReminderLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReminderLogCreateManyUserInputEnvelope
    set?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    disconnect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    delete?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    update?: ReminderLogUpdateWithWhereUniqueWithoutUserInput | ReminderLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReminderLogUpdateManyWithWhereWithoutUserInput | ReminderLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserFeatureAccessUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFeatureAccessCreateOrConnectWithoutUserInput
    upsert?: UserFeatureAccessUpsertWithoutUserInput
    disconnect?: UserFeatureAccessWhereInput | boolean
    delete?: UserFeatureAccessWhereInput | boolean
    connect?: UserFeatureAccessWhereUniqueInput
    update?: XOR<XOR<UserFeatureAccessUpdateToOneWithWhereWithoutUserInput, UserFeatureAccessUpdateWithoutUserInput>, UserFeatureAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserAccessLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: UserAccessLogUpsertWithWhereUniqueWithoutUserInput | UserAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    set?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    disconnect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    delete?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    update?: UserAccessLogUpdateWithWhereUniqueWithoutUserInput | UserAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccessLogUpdateManyWithWhereWithoutUserInput | UserAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput> | FileCreateWithoutUploadedByInput[] | FileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploadedByInput | FileCreateOrConnectWithoutUploadedByInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploadedByInput | FileUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FileCreateManyUploadedByInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploadedByInput | FileUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploadedByInput | FileUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput> | BlogArticleCreateWithoutAuthorInput[] | BlogArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogArticleCreateOrConnectWithoutAuthorInput | BlogArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogArticleUpsertWithWhereUniqueWithoutAuthorInput | BlogArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogArticleCreateManyAuthorInputEnvelope
    set?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    disconnect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    delete?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    connect?: BlogArticleWhereUniqueInput | BlogArticleWhereUniqueInput[]
    update?: BlogArticleUpdateWithWhereUniqueWithoutAuthorInput | BlogArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogArticleUpdateManyWithWhereWithoutAuthorInput | BlogArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput> | InspectionCreateWithoutUserInput[] | InspectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutUserInput | InspectionCreateOrConnectWithoutUserInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutUserInput | InspectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InspectionCreateManyUserInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutUserInput | InspectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutUserInput | InspectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput> | LeaseGeneratorUsageCreateWithoutUserInput[] | LeaseGeneratorUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaseGeneratorUsageCreateOrConnectWithoutUserInput | LeaseGeneratorUsageCreateOrConnectWithoutUserInput[]
    upsert?: LeaseGeneratorUsageUpsertWithWhereUniqueWithoutUserInput | LeaseGeneratorUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaseGeneratorUsageCreateManyUserInputEnvelope
    set?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    disconnect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    delete?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    connect?: LeaseGeneratorUsageWhereUniqueInput | LeaseGeneratorUsageWhereUniqueInput[]
    update?: LeaseGeneratorUsageUpdateWithWhereUniqueWithoutUserInput | LeaseGeneratorUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaseGeneratorUsageUpdateManyWithWhereWithoutUserInput | LeaseGeneratorUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaseGeneratorUsageScalarWhereInput | LeaseGeneratorUsageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput> | TenantCreateWithoutUserInput[] | TenantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutUserInput | TenantCreateOrConnectWithoutUserInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutUserInput | TenantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantCreateManyUserInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutUserInput | TenantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutUserInput | TenantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReminderLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput> | ReminderLogCreateWithoutUserInput[] | ReminderLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderLogCreateOrConnectWithoutUserInput | ReminderLogCreateOrConnectWithoutUserInput[]
    upsert?: ReminderLogUpsertWithWhereUniqueWithoutUserInput | ReminderLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReminderLogCreateManyUserInputEnvelope
    set?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    disconnect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    delete?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    connect?: ReminderLogWhereUniqueInput | ReminderLogWhereUniqueInput[]
    update?: ReminderLogUpdateWithWhereUniqueWithoutUserInput | ReminderLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReminderLogUpdateManyWithWhereWithoutUserInput | ReminderLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserFeatureAccessCreateOrConnectWithoutUserInput
    upsert?: UserFeatureAccessUpsertWithoutUserInput
    disconnect?: UserFeatureAccessWhereInput | boolean
    delete?: UserFeatureAccessWhereInput | boolean
    connect?: UserFeatureAccessWhereUniqueInput
    update?: XOR<XOR<UserFeatureAccessUpdateToOneWithWhereWithoutUserInput, UserFeatureAccessUpdateWithoutUserInput>, UserFeatureAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserAccessLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput> | UserAccessLogCreateWithoutUserInput[] | UserAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAccessLogCreateOrConnectWithoutUserInput | UserAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: UserAccessLogUpsertWithWhereUniqueWithoutUserInput | UserAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAccessLogCreateManyUserInputEnvelope
    set?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    disconnect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    delete?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    connect?: UserAccessLogWhereUniqueInput | UserAccessLogWhereUniqueInput[]
    update?: UserAccessLogUpdateWithWhereUniqueWithoutUserInput | UserAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAccessLogUpdateManyWithWhereWithoutUserInput | UserAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput> | FileCreateWithoutUploadedByInput[] | FileUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploadedByInput | FileCreateOrConnectWithoutUploadedByInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploadedByInput | FileUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FileCreateManyUploadedByInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploadedByInput | FileUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploadedByInput | FileUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityEntityType
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutRemindersInput = {
    create?: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersInput
    connect?: UserWhereUniqueInput
  }

  export type LeaseCreateNestedOneWithoutRemindersInput = {
    create?: XOR<LeaseCreateWithoutRemindersInput, LeaseUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutRemindersInput
    connect?: LeaseWhereUniqueInput
  }

  export type EnumReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReminderType
  }

  export type EnumReminderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReminderStatus
  }

  export type UserUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersInput
    upsert?: UserUpsertWithoutRemindersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRemindersInput, UserUpdateWithoutRemindersInput>, UserUncheckedUpdateWithoutRemindersInput>
  }

  export type LeaseUpdateOneWithoutRemindersNestedInput = {
    create?: XOR<LeaseCreateWithoutRemindersInput, LeaseUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: LeaseCreateOrConnectWithoutRemindersInput
    upsert?: LeaseUpsertWithoutRemindersInput
    disconnect?: LeaseWhereInput | boolean
    delete?: LeaseWhereInput | boolean
    connect?: LeaseWhereUniqueInput
    update?: XOR<XOR<LeaseUpdateToOneWithWhereWithoutRemindersInput, LeaseUpdateWithoutRemindersInput>, LeaseUncheckedUpdateWithoutRemindersInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutFeatureAccessInput = {
    create?: XOR<UserCreateWithoutFeatureAccessInput, UserUncheckedCreateWithoutFeatureAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureAccessInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeatureAccessNestedInput = {
    create?: XOR<UserCreateWithoutFeatureAccessInput, UserUncheckedCreateWithoutFeatureAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeatureAccessInput
    upsert?: UserUpsertWithoutFeatureAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeatureAccessInput, UserUpdateWithoutFeatureAccessInput>, UserUncheckedUpdateWithoutFeatureAccessInput>
  }

  export type UserCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<UserCreateWithoutAccessLogsInput, UserUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccessLogsNestedInput = {
    create?: XOR<UserCreateWithoutAccessLogsInput, UserUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessLogsInput
    upsert?: UserUpsertWithoutAccessLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccessLogsInput, UserUpdateWithoutAccessLogsInput>, UserUncheckedUpdateWithoutAccessLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationLogsInput = {
    create?: XOR<UserCreateWithoutNotificationLogsInput, UserUncheckedCreateWithoutNotificationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationLogsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationLogsInput, UserUncheckedCreateWithoutNotificationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogsInput
    upsert?: UserUpsertWithoutNotificationLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationLogsInput, UserUpdateWithoutNotificationLogsInput>, UserUncheckedUpdateWithoutNotificationLogsInput>
  }

  export type UserCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutFilesInput = {
    create?: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFilesInput
    connect?: PropertyWhereUniqueInput
  }

  export type MaintenanceRequestCreateNestedOneWithoutFilesInput = {
    create?: XOR<MaintenanceRequestCreateWithoutFilesInput, MaintenanceRequestUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutFilesInput
    connect?: MaintenanceRequestWhereUniqueInput
  }

  export type UserUpdateOneWithoutUploadedFilesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    upsert?: UserUpsertWithoutUploadedFilesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedFilesInput, UserUpdateWithoutUploadedFilesInput>, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type PropertyUpdateOneWithoutFilesNestedInput = {
    create?: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutFilesInput
    upsert?: PropertyUpsertWithoutFilesInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutFilesInput, PropertyUpdateWithoutFilesInput>, PropertyUncheckedUpdateWithoutFilesInput>
  }

  export type MaintenanceRequestUpdateOneWithoutFilesNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutFilesInput, MaintenanceRequestUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutFilesInput
    upsert?: MaintenanceRequestUpsertWithoutFilesInput
    disconnect?: MaintenanceRequestWhereInput | boolean
    delete?: MaintenanceRequestWhereInput | boolean
    connect?: MaintenanceRequestWhereUniqueInput
    update?: XOR<XOR<MaintenanceRequestUpdateToOneWithWhereWithoutFilesInput, MaintenanceRequestUpdateWithoutFilesInput>, MaintenanceRequestUncheckedUpdateWithoutFilesInput>
  }

  export type SubscriptionCreateNestedOneWithoutPaymentFailuresInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentFailuresInput, SubscriptionUncheckedCreateWithoutPaymentFailuresInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentFailuresInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutPaymentFailuresNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentFailuresInput, SubscriptionUncheckedCreateWithoutPaymentFailuresInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentFailuresInput
    upsert?: SubscriptionUpsertWithoutPaymentFailuresInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentFailuresInput, SubscriptionUpdateWithoutPaymentFailuresInput>, SubscriptionUncheckedUpdateWithoutPaymentFailuresInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumBlogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogCategory | EnumBlogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogCategoryFilter<$PrismaModel> | $Enums.BlogCategory
  }

  export type NestedEnumBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusFilter<$PrismaModel> | $Enums.BlogStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumBlogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogCategory | EnumBlogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogCategory[] | ListEnumBlogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BlogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogCategoryFilter<$PrismaModel>
    _max?: NestedEnumBlogCategoryFilter<$PrismaModel>
  }

  export type NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumBlogStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerInvoiceStatus | EnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel> | $Enums.CustomerInvoiceStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCustomerInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerInvoiceStatus | EnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerInvoiceStatus[] | ListEnumCustomerInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomerInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomerInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumLeaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusFilter<$PrismaModel> | $Enums.LeaseStatus
  }

  export type NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaseStatus | EnumLeaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaseStatus[] | ListEnumLeaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubStatus | EnumSubStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubStatusFilter<$PrismaModel> | $Enums.SubStatus
  }

  export type NestedEnumPlanTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanTypeNullableFilter<$PrismaModel> | $Enums.PlanType | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumSubStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubStatus | EnumSubStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubStatus[] | ListEnumSubStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubStatusFilter<$PrismaModel>
    _max?: NestedEnumSubStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlanTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PlanType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumActivityEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeFilter<$PrismaModel> | $Enums.ActivityEntityType
  }

  export type NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type NestedEnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type BlogTagCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    color?: string | null
    createdAt?: Date | string
  }

  export type BlogTagUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    color?: string | null
    createdAt?: Date | string
  }

  export type BlogTagCreateOrConnectWithoutArticlesInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput>
  }

  export type UserCreateWithoutBlogArticleInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutBlogArticleInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutBlogArticleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogArticleInput, UserUncheckedCreateWithoutBlogArticleInput>
  }

  export type BlogTagUpsertWithWhereUniqueWithoutArticlesInput = {
    where: BlogTagWhereUniqueInput
    update: XOR<BlogTagUpdateWithoutArticlesInput, BlogTagUncheckedUpdateWithoutArticlesInput>
    create: XOR<BlogTagCreateWithoutArticlesInput, BlogTagUncheckedCreateWithoutArticlesInput>
  }

  export type BlogTagUpdateWithWhereUniqueWithoutArticlesInput = {
    where: BlogTagWhereUniqueInput
    data: XOR<BlogTagUpdateWithoutArticlesInput, BlogTagUncheckedUpdateWithoutArticlesInput>
  }

  export type BlogTagUpdateManyWithWhereWithoutArticlesInput = {
    where: BlogTagScalarWhereInput
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyWithoutArticlesInput>
  }

  export type BlogTagScalarWhereInput = {
    AND?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    OR?: BlogTagScalarWhereInput[]
    NOT?: BlogTagScalarWhereInput | BlogTagScalarWhereInput[]
    id?: StringFilter<"BlogTag"> | string
    name?: StringFilter<"BlogTag"> | string
    slug?: StringFilter<"BlogTag"> | string
    color?: StringNullableFilter<"BlogTag"> | string | null
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
  }

  export type UserUpsertWithoutBlogArticleInput = {
    update: XOR<UserUpdateWithoutBlogArticleInput, UserUncheckedUpdateWithoutBlogArticleInput>
    create: XOR<UserCreateWithoutBlogArticleInput, UserUncheckedCreateWithoutBlogArticleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogArticleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogArticleInput, UserUncheckedUpdateWithoutBlogArticleInput>
  }

  export type UserUpdateWithoutBlogArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type BlogArticleCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutBlogArticleInput
  }

  export type BlogArticleUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorId?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogArticleCreateOrConnectWithoutTagsInput = {
    where: BlogArticleWhereUniqueInput
    create: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput>
  }

  export type BlogArticleUpsertWithWhereUniqueWithoutTagsInput = {
    where: BlogArticleWhereUniqueInput
    update: XOR<BlogArticleUpdateWithoutTagsInput, BlogArticleUncheckedUpdateWithoutTagsInput>
    create: XOR<BlogArticleCreateWithoutTagsInput, BlogArticleUncheckedCreateWithoutTagsInput>
  }

  export type BlogArticleUpdateWithWhereUniqueWithoutTagsInput = {
    where: BlogArticleWhereUniqueInput
    data: XOR<BlogArticleUpdateWithoutTagsInput, BlogArticleUncheckedUpdateWithoutTagsInput>
  }

  export type BlogArticleUpdateManyWithWhereWithoutTagsInput = {
    where: BlogArticleScalarWhereInput
    data: XOR<BlogArticleUpdateManyMutationInput, BlogArticleUncheckedUpdateManyWithoutTagsInput>
  }

  export type BlogArticleScalarWhereInput = {
    AND?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
    OR?: BlogArticleScalarWhereInput[]
    NOT?: BlogArticleScalarWhereInput | BlogArticleScalarWhereInput[]
    id?: StringFilter<"BlogArticle"> | string
    title?: StringFilter<"BlogArticle"> | string
    slug?: StringFilter<"BlogArticle"> | string
    description?: StringFilter<"BlogArticle"> | string
    content?: StringFilter<"BlogArticle"> | string
    excerpt?: StringNullableFilter<"BlogArticle"> | string | null
    authorId?: StringNullableFilter<"BlogArticle"> | string | null
    authorName?: StringFilter<"BlogArticle"> | string
    metaTitle?: StringNullableFilter<"BlogArticle"> | string | null
    metaDescription?: StringNullableFilter<"BlogArticle"> | string | null
    ogImage?: StringNullableFilter<"BlogArticle"> | string | null
    category?: EnumBlogCategoryFilter<"BlogArticle"> | $Enums.BlogCategory
    status?: EnumBlogStatusFilter<"BlogArticle"> | $Enums.BlogStatus
    featured?: BoolFilter<"BlogArticle"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    viewCount?: IntFilter<"BlogArticle"> | number
    readTime?: IntNullableFilter<"BlogArticle"> | number | null
    searchKeywords?: StringNullableListFilter<"BlogArticle">
    lastIndexed?: DateTimeNullableFilter<"BlogArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogArticle"> | Date | string
    updatedAt?: DateTimeFilter<"BlogArticle"> | Date | string
  }

  export type CustomerInvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: CustomerInvoiceItemWhereUniqueInput
    create: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: CustomerInvoiceItemCreateManyInvoiceInput | CustomerInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerInvoiceItemWhereUniqueInput
    update: XOR<CustomerInvoiceItemUpdateWithoutInvoiceInput, CustomerInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<CustomerInvoiceItemCreateWithoutInvoiceInput, CustomerInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerInvoiceItemWhereUniqueInput
    data: XOR<CustomerInvoiceItemUpdateWithoutInvoiceInput, CustomerInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type CustomerInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: CustomerInvoiceItemScalarWhereInput
    data: XOR<CustomerInvoiceItemUpdateManyMutationInput, CustomerInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CustomerInvoiceItemScalarWhereInput = {
    AND?: CustomerInvoiceItemScalarWhereInput | CustomerInvoiceItemScalarWhereInput[]
    OR?: CustomerInvoiceItemScalarWhereInput[]
    NOT?: CustomerInvoiceItemScalarWhereInput | CustomerInvoiceItemScalarWhereInput[]
    id?: StringFilter<"CustomerInvoiceItem"> | string
    invoiceId?: StringFilter<"CustomerInvoiceItem"> | string
    description?: StringFilter<"CustomerInvoiceItem"> | string
    quantity?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CustomerInvoiceItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CustomerInvoiceItem"> | Date | string
  }

  export type CustomerInvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress?: string | null
    businessCity?: string | null
    businessState?: string | null
    businessZip?: string | null
    businessPhone?: string | null
    businessLogo?: string | null
    clientName: string
    clientEmail: string
    clientAddress?: string | null
    clientCity?: string | null
    clientState?: string | null
    clientZip?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    emailCaptured?: string | null
    downloadCount?: number
    isProVersion?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.CustomerInvoiceStatus
    businessName: string
    businessEmail: string
    businessAddress?: string | null
    businessCity?: string | null
    businessState?: string | null
    businessZip?: string | null
    businessPhone?: string | null
    businessLogo?: string | null
    clientName: string
    clientEmail: string
    clientAddress?: string | null
    clientCity?: string | null
    clientState?: string | null
    clientZip?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    emailCaptured?: string | null
    downloadCount?: number
    isProVersion?: boolean
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerInvoiceCreateOrConnectWithoutItemsInput = {
    where: CustomerInvoiceWhereUniqueInput
    create: XOR<CustomerInvoiceCreateWithoutItemsInput, CustomerInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type CustomerInvoiceUpsertWithoutItemsInput = {
    update: XOR<CustomerInvoiceUpdateWithoutItemsInput, CustomerInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<CustomerInvoiceCreateWithoutItemsInput, CustomerInvoiceUncheckedCreateWithoutItemsInput>
    where?: CustomerInvoiceWhereInput
  }

  export type CustomerInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: CustomerInvoiceWhereInput
    data: XOR<CustomerInvoiceUpdateWithoutItemsInput, CustomerInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CustomerInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumCustomerInvoiceStatusFieldUpdateOperationsInput | $Enums.CustomerInvoiceStatus
    businessName?: StringFieldUpdateOperationsInput | string
    businessEmail?: StringFieldUpdateOperationsInput | string
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessCity?: NullableStringFieldUpdateOperationsInput | string | null
    businessState?: NullableStringFieldUpdateOperationsInput | string | null
    businessZip?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessLogo?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientAddress?: NullableStringFieldUpdateOperationsInput | string | null
    clientCity?: NullableStringFieldUpdateOperationsInput | string | null
    clientState?: NullableStringFieldUpdateOperationsInput | string | null
    clientZip?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    emailCaptured?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    isProVersion?: BoolFieldUpdateOperationsInput | boolean
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateWithoutDocumentInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Tenant: TenantCreateNestedOneWithoutLeaseInput
    Unit: UnitCreateNestedOneWithoutLeaseInput
    reminders?: ReminderLogCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutDocumentInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutDocumentInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutDocumentInput, LeaseUncheckedCreateWithoutDocumentInput>
  }

  export type PropertyCreateWithoutDocumentInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutDocumentInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutDocumentInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutDocumentInput, PropertyUncheckedCreateWithoutDocumentInput>
  }

  export type LeaseUpsertWithoutDocumentInput = {
    update: XOR<LeaseUpdateWithoutDocumentInput, LeaseUncheckedUpdateWithoutDocumentInput>
    create: XOR<LeaseCreateWithoutDocumentInput, LeaseUncheckedCreateWithoutDocumentInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutDocumentInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutDocumentInput, LeaseUncheckedUpdateWithoutDocumentInput>
  }

  export type LeaseUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    Unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    reminders?: ReminderLogUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reminders?: ReminderLogUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type PropertyUpsertWithoutDocumentInput = {
    update: XOR<PropertyUpdateWithoutDocumentInput, PropertyUncheckedUpdateWithoutDocumentInput>
    create: XOR<PropertyCreateWithoutDocumentInput, PropertyUncheckedCreateWithoutDocumentInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutDocumentInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutDocumentInput, PropertyUncheckedUpdateWithoutDocumentInput>
  }

  export type PropertyUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type MaintenanceRequestCreateWithoutExpenseInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Unit: UnitCreateNestedOneWithoutMaintenanceRequestInput
    files?: FileCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutExpenseInput = {
    id?: string
    unitId: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    files?: FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutExpenseInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutExpenseInput, MaintenanceRequestUncheckedCreateWithoutExpenseInput>
  }

  export type PropertyCreateWithoutExpenseInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutExpenseInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutExpenseInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutExpenseInput, PropertyUncheckedCreateWithoutExpenseInput>
  }

  export type MaintenanceRequestUpsertWithoutExpenseInput = {
    update: XOR<MaintenanceRequestUpdateWithoutExpenseInput, MaintenanceRequestUncheckedUpdateWithoutExpenseInput>
    create: XOR<MaintenanceRequestCreateWithoutExpenseInput, MaintenanceRequestUncheckedCreateWithoutExpenseInput>
    where?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestUpdateToOneWithWhereWithoutExpenseInput = {
    where?: MaintenanceRequestWhereInput
    data: XOR<MaintenanceRequestUpdateWithoutExpenseInput, MaintenanceRequestUncheckedUpdateWithoutExpenseInput>
  }

  export type MaintenanceRequestUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit?: UnitUpdateOneRequiredWithoutMaintenanceRequestNestedInput
    files?: FileUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    files?: FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type PropertyUpsertWithoutExpenseInput = {
    update: XOR<PropertyUpdateWithoutExpenseInput, PropertyUncheckedUpdateWithoutExpenseInput>
    create: XOR<PropertyCreateWithoutExpenseInput, PropertyUncheckedCreateWithoutExpenseInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutExpenseInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutExpenseInput, PropertyUncheckedUpdateWithoutExpenseInput>
  }

  export type PropertyUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutInspectionInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutInspectionInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutInspectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectionInput, UserUncheckedCreateWithoutInspectionInput>
  }

  export type PropertyCreateWithoutInspectionInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutInspectionInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutInspectionInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutInspectionInput, PropertyUncheckedCreateWithoutInspectionInput>
  }

  export type UnitCreateWithoutInspectionInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Lease?: LeaseCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutUnitInput
    Property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutInspectionInput = {
    id?: string
    unitNumber: string
    propertyId: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutInspectionInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutInspectionInput, UnitUncheckedCreateWithoutInspectionInput>
  }

  export type UserUpsertWithoutInspectionInput = {
    update: XOR<UserUpdateWithoutInspectionInput, UserUncheckedUpdateWithoutInspectionInput>
    create: XOR<UserCreateWithoutInspectionInput, UserUncheckedCreateWithoutInspectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInspectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInspectionInput, UserUncheckedUpdateWithoutInspectionInput>
  }

  export type UserUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type PropertyUpsertWithoutInspectionInput = {
    update: XOR<PropertyUpdateWithoutInspectionInput, PropertyUncheckedUpdateWithoutInspectionInput>
    create: XOR<PropertyCreateWithoutInspectionInput, PropertyUncheckedCreateWithoutInspectionInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutInspectionInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutInspectionInput, PropertyUncheckedUpdateWithoutInspectionInput>
  }

  export type PropertyUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UnitUpsertWithoutInspectionInput = {
    update: XOR<UnitUpdateWithoutInspectionInput, UnitUncheckedUpdateWithoutInspectionInput>
    create: XOR<UnitCreateWithoutInspectionInput, UnitUncheckedCreateWithoutInspectionInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutInspectionInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutInspectionInput, UnitUncheckedUpdateWithoutInspectionInput>
  }

  export type UnitUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lease?: LeaseUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateManyWithoutUnitNestedInput
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SubscriptionCreateWithoutInvoiceInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    User: UserCreateNestedOneWithoutSubscriptionInput
    paymentFailures?: PaymentFailureCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    paymentFailures?: PaymentFailureUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutInvoiceInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoiceInput, SubscriptionUncheckedCreateWithoutInvoiceInput>
  }

  export type UserCreateWithoutInvoiceInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutInvoiceInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type SubscriptionUpsertWithoutInvoiceInput = {
    update: XOR<SubscriptionUpdateWithoutInvoiceInput, SubscriptionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SubscriptionCreateWithoutInvoiceInput, SubscriptionUncheckedCreateWithoutInvoiceInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoiceInput, SubscriptionUncheckedUpdateWithoutInvoiceInput>
  }

  export type SubscriptionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    paymentFailures?: PaymentFailureUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentFailures?: PaymentFailureUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserUpsertWithoutInvoiceInput = {
    update: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type DocumentCreateWithoutLeaseInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
    Property?: PropertyCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutLeaseInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    propertyId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type DocumentCreateOrConnectWithoutLeaseInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput>
  }

  export type DocumentCreateManyLeaseInputEnvelope = {
    data: DocumentCreateManyLeaseInput | DocumentCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutLeaseInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeaseInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCreateOrConnectWithoutLeaseInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
  }

  export type UnitCreateWithoutLeaseInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutUnitInput
    Property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutLeaseInput = {
    id?: string
    unitNumber: string
    propertyId: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutLeaseInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
  }

  export type ReminderLogCreateWithoutLeaseInput = {
    id?: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutRemindersInput
  }

  export type ReminderLogUncheckedCreateWithoutLeaseInput = {
    id?: string
    userId: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderLogCreateOrConnectWithoutLeaseInput = {
    where: ReminderLogWhereUniqueInput
    create: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput>
  }

  export type ReminderLogCreateManyLeaseInputEnvelope = {
    data: ReminderLogCreateManyLeaseInput | ReminderLogCreateManyLeaseInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutLeaseInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutLeaseInput, DocumentUncheckedUpdateWithoutLeaseInput>
    create: XOR<DocumentCreateWithoutLeaseInput, DocumentUncheckedCreateWithoutLeaseInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutLeaseInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutLeaseInput, DocumentUncheckedUpdateWithoutLeaseInput>
  }

  export type DocumentUpdateManyWithWhereWithoutLeaseInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutLeaseInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    filename?: StringNullableFilter<"Document"> | string | null
    url?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    mimeType?: StringNullableFilter<"Document"> | string | null
    size?: BigIntNullableFilter<"Document"> | bigint | number | null
    propertyId?: StringNullableFilter<"Document"> | string | null
    leaseId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileSizeBytes?: BigIntFilter<"Document"> | bigint | number
  }

  export type TenantUpsertWithoutLeaseInput = {
    update: XOR<TenantUpdateWithoutLeaseInput, TenantUncheckedUpdateWithoutLeaseInput>
    create: XOR<TenantCreateWithoutLeaseInput, TenantUncheckedCreateWithoutLeaseInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeaseInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeaseInput, TenantUncheckedUpdateWithoutLeaseInput>
  }

  export type TenantUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithoutLeaseInput = {
    update: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
    create: XOR<UnitCreateWithoutLeaseInput, UnitUncheckedCreateWithoutLeaseInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutLeaseInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutLeaseInput, UnitUncheckedUpdateWithoutLeaseInput>
  }

  export type UnitUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateManyWithoutUnitNestedInput
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUncheckedUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ReminderLogUpsertWithWhereUniqueWithoutLeaseInput = {
    where: ReminderLogWhereUniqueInput
    update: XOR<ReminderLogUpdateWithoutLeaseInput, ReminderLogUncheckedUpdateWithoutLeaseInput>
    create: XOR<ReminderLogCreateWithoutLeaseInput, ReminderLogUncheckedCreateWithoutLeaseInput>
  }

  export type ReminderLogUpdateWithWhereUniqueWithoutLeaseInput = {
    where: ReminderLogWhereUniqueInput
    data: XOR<ReminderLogUpdateWithoutLeaseInput, ReminderLogUncheckedUpdateWithoutLeaseInput>
  }

  export type ReminderLogUpdateManyWithWhereWithoutLeaseInput = {
    where: ReminderLogScalarWhereInput
    data: XOR<ReminderLogUpdateManyMutationInput, ReminderLogUncheckedUpdateManyWithoutLeaseInput>
  }

  export type ReminderLogScalarWhereInput = {
    AND?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
    OR?: ReminderLogScalarWhereInput[]
    NOT?: ReminderLogScalarWhereInput | ReminderLogScalarWhereInput[]
    id?: StringFilter<"ReminderLog"> | string
    leaseId?: StringNullableFilter<"ReminderLog"> | string | null
    userId?: StringFilter<"ReminderLog"> | string
    type?: EnumReminderTypeFilter<"ReminderLog"> | $Enums.ReminderType
    status?: EnumReminderStatusFilter<"ReminderLog"> | $Enums.ReminderStatus
    recipientEmail?: StringFilter<"ReminderLog"> | string
    recipientName?: StringNullableFilter<"ReminderLog"> | string | null
    subject?: StringNullableFilter<"ReminderLog"> | string | null
    content?: StringNullableFilter<"ReminderLog"> | string | null
    sentAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    openedAt?: DateTimeNullableFilter<"ReminderLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ReminderLog"> | string | null
    retryCount?: IntFilter<"ReminderLog"> | number
    createdAt?: DateTimeFilter<"ReminderLog"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderLog"> | Date | string
  }

  export type UserCreateWithoutLeaseGeneratorUsageInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutLeaseGeneratorUsageInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutLeaseGeneratorUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaseGeneratorUsageInput, UserUncheckedCreateWithoutLeaseGeneratorUsageInput>
  }

  export type UserUpsertWithoutLeaseGeneratorUsageInput = {
    update: XOR<UserUpdateWithoutLeaseGeneratorUsageInput, UserUncheckedUpdateWithoutLeaseGeneratorUsageInput>
    create: XOR<UserCreateWithoutLeaseGeneratorUsageInput, UserUncheckedCreateWithoutLeaseGeneratorUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaseGeneratorUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaseGeneratorUsageInput, UserUncheckedUpdateWithoutLeaseGeneratorUsageInput>
  }

  export type UserUpdateWithoutLeaseGeneratorUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaseGeneratorUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ExpenseCreateWithoutMaintenanceRequestInput = {
    id?: string
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    propertyId: string
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutMaintenanceRequestInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type ExpenseCreateManyMaintenanceRequestInputEnvelope = {
    data: ExpenseCreateManyMaintenanceRequestInput | ExpenseCreateManyMaintenanceRequestInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutMaintenanceRequestInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionCreateNestedManyWithoutUnitInput
    Lease?: LeaseCreateNestedManyWithoutUnitInput
    Property: PropertyCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    unitNumber: string
    propertyId: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUnitInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutMaintenanceRequestInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutMaintenanceRequestInput, UnitUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileCreateWithoutMaintenanceRequestInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    createdAt?: Date | string
    UploadedBy?: UserCreateNestedOneWithoutUploadedFilesInput
    Property?: PropertyCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutMaintenanceRequestInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    propertyId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileCreateManyMaintenanceRequestInputEnvelope = {
    data: FileCreateManyMaintenanceRequestInput | FileCreateManyMaintenanceRequestInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutMaintenanceRequestInput, ExpenseUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<ExpenseCreateWithoutMaintenanceRequestInput, ExpenseUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutMaintenanceRequestInput, ExpenseUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutMaintenanceRequestInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutMaintenanceRequestInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    propertyId?: StringFilter<"Expense"> | string
    maintenanceId?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    category?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    vendorName?: StringNullableFilter<"Expense"> | string | null
    vendorContact?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type UnitUpsertWithoutMaintenanceRequestInput = {
    update: XOR<UnitUpdateWithoutMaintenanceRequestInput, UnitUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<UnitCreateWithoutMaintenanceRequestInput, UnitUncheckedCreateWithoutMaintenanceRequestInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutMaintenanceRequestInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutMaintenanceRequestInput, UnitUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type UnitUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUpdateManyWithoutUnitNestedInput
    Property?: PropertyUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUncheckedUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutMaintenanceRequestInput, FileUncheckedUpdateWithoutMaintenanceRequestInput>
    create: XOR<FileCreateWithoutMaintenanceRequestInput, FileUncheckedCreateWithoutMaintenanceRequestInput>
  }

  export type FileUpdateWithWhereUniqueWithoutMaintenanceRequestInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutMaintenanceRequestInput, FileUncheckedUpdateWithoutMaintenanceRequestInput>
  }

  export type FileUpdateManyWithWhereWithoutMaintenanceRequestInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutMaintenanceRequestInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntNullableFilter<"File"> | number | null
    url?: StringFilter<"File"> | string
    uploadedById?: StringNullableFilter<"File"> | string | null
    propertyId?: StringNullableFilter<"File"> | string | null
    maintenanceRequestId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
  }

  export type UserCreateWithoutMessage_Message_receiverIdToUserInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserCreateWithoutMessage_Message_senderIdToUserInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
  }

  export type UserUpsertWithoutMessage_Message_receiverIdToUserInput = {
    update: XOR<UserUpdateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
    create: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_Message_receiverIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserUpdateWithoutMessage_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutMessage_Message_senderIdToUserInput = {
    update: XOR<UserUpdateWithoutMessage_Message_senderIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
    create: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_Message_senderIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_Message_senderIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
  }

  export type UserUpdateWithoutMessage_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type DocumentCreateWithoutPropertyInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
    Lease?: LeaseCreateNestedOneWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    leaseId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type DocumentCreateOrConnectWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput>
  }

  export type DocumentCreateManyPropertyInputEnvelope = {
    data: DocumentCreateManyPropertyInput | DocumentCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutPropertyInput = {
    id?: string
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    MaintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutPropertyInput = {
    id?: string
    maintenanceId?: string | null
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput>
  }

  export type ExpenseCreateManyPropertyInputEnvelope = {
    data: ExpenseCreateManyPropertyInput | ExpenseCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutPropertyInput = {
    id?: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutInspectionInput
    Unit?: UnitCreateNestedOneWithoutInspectionInput
  }

  export type InspectionUncheckedCreateWithoutPropertyInput = {
    id?: string
    unitId?: string | null
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateOrConnectWithoutPropertyInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput>
  }

  export type InspectionCreateManyPropertyInputEnvelope = {
    data: InspectionCreateManyPropertyInput | InspectionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPropertyInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutPropertyInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutPropertyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateWithoutPropertyInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionCreateNestedManyWithoutUnitInput
    Lease?: LeaseCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPropertyInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUnitInput
    Lease?: LeaseUncheckedCreateNestedManyWithoutUnitInput
    MaintenanceRequest?: MaintenanceRequestUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitCreateManyPropertyInputEnvelope = {
    data: UnitCreateManyPropertyInput | UnitCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutPropertyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    createdAt?: Date | string
    UploadedBy?: UserCreateNestedOneWithoutUploadedFilesInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutPropertyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutPropertyInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput>
  }

  export type FileCreateManyPropertyInputEnvelope = {
    data: FileCreateManyPropertyInput | FileCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPropertyInput, DocumentUncheckedUpdateWithoutPropertyInput>
    create: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPropertyInput, DocumentUncheckedUpdateWithoutPropertyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPropertyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutPropertyInput, ExpenseUncheckedUpdateWithoutPropertyInput>
    create: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutPropertyInput, ExpenseUncheckedUpdateWithoutPropertyInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutPropertyInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutPropertyInput>
  }

  export type InspectionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutPropertyInput, InspectionUncheckedUpdateWithoutPropertyInput>
    create: XOR<InspectionCreateWithoutPropertyInput, InspectionUncheckedCreateWithoutPropertyInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutPropertyInput, InspectionUncheckedUpdateWithoutPropertyInput>
  }

  export type InspectionUpdateManyWithWhereWithoutPropertyInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type InspectionScalarWhereInput = {
    AND?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
    OR?: InspectionScalarWhereInput[]
    NOT?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
    id?: StringFilter<"Inspection"> | string
    propertyId?: StringFilter<"Inspection"> | string
    unitId?: StringNullableFilter<"Inspection"> | string | null
    inspectorId?: StringFilter<"Inspection"> | string
    type?: StringFilter<"Inspection"> | string
    scheduledDate?: DateTimeFilter<"Inspection"> | Date | string
    completedDate?: DateTimeNullableFilter<"Inspection"> | Date | string | null
    status?: StringFilter<"Inspection"> | string
    notes?: StringNullableFilter<"Inspection"> | string | null
    reportUrl?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
  }

  export type UserUpsertWithoutPropertyInput = {
    update: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type UserUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
    create: XOR<UnitCreateWithoutPropertyInput, UnitUncheckedCreateWithoutPropertyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutPropertyInput, UnitUncheckedUpdateWithoutPropertyInput>
  }

  export type UnitUpdateManyWithWhereWithoutPropertyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    unitNumber?: StringFilter<"Unit"> | string
    propertyId?: StringFilter<"Unit"> | string
    bedrooms?: IntFilter<"Unit"> | number
    bathrooms?: FloatFilter<"Unit"> | number
    squareFeet?: IntNullableFilter<"Unit"> | number | null
    rent?: FloatFilter<"Unit"> | number
    status?: EnumUnitStatusFilter<"Unit"> | $Enums.UnitStatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    lastInspectionDate?: DateTimeNullableFilter<"Unit"> | Date | string | null
  }

  export type FileUpsertWithWhereUniqueWithoutPropertyInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutPropertyInput, FileUncheckedUpdateWithoutPropertyInput>
    create: XOR<FileCreateWithoutPropertyInput, FileUncheckedCreateWithoutPropertyInput>
  }

  export type FileUpdateWithWhereUniqueWithoutPropertyInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutPropertyInput, FileUncheckedUpdateWithoutPropertyInput>
  }

  export type FileUpdateManyWithWhereWithoutPropertyInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutPropertyInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSubscriptionInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentFailureCreateWithoutSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentFailureUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentFailureCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentFailureWhereUniqueInput
    create: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentFailureCreateManySubscriptionInputEnvelope = {
    data: PaymentFailureCreateManySubscriptionInput | PaymentFailureCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    subscriptionId?: StringNullableFilter<"Invoice"> | string | null
    stripeInvoiceId?: StringFilter<"Invoice"> | string
    amountPaid?: IntFilter<"Invoice"> | number
    amountDue?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    invoiceUrl?: StringNullableFilter<"Invoice"> | string | null
    invoicePdf?: StringNullableFilter<"Invoice"> | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type PaymentFailureUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentFailureWhereUniqueInput
    update: XOR<PaymentFailureUpdateWithoutSubscriptionInput, PaymentFailureUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentFailureCreateWithoutSubscriptionInput, PaymentFailureUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentFailureUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentFailureWhereUniqueInput
    data: XOR<PaymentFailureUpdateWithoutSubscriptionInput, PaymentFailureUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentFailureUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentFailureScalarWhereInput
    data: XOR<PaymentFailureUpdateManyMutationInput, PaymentFailureUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PaymentFailureScalarWhereInput = {
    AND?: PaymentFailureScalarWhereInput | PaymentFailureScalarWhereInput[]
    OR?: PaymentFailureScalarWhereInput[]
    NOT?: PaymentFailureScalarWhereInput | PaymentFailureScalarWhereInput[]
    id?: StringFilter<"PaymentFailure"> | string
    subscriptionId?: StringFilter<"PaymentFailure"> | string
    stripeInvoiceId?: StringFilter<"PaymentFailure"> | string
    amount?: IntFilter<"PaymentFailure"> | number
    currency?: StringFilter<"PaymentFailure"> | string
    attemptCount?: IntFilter<"PaymentFailure"> | number
    errorCode?: StringNullableFilter<"PaymentFailure"> | string | null
    errorMessage?: StringNullableFilter<"PaymentFailure"> | string | null
    nextRetryAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    resolved?: BoolFilter<"PaymentFailure"> | boolean
    resolvedAt?: DateTimeNullableFilter<"PaymentFailure"> | Date | string | null
    finalAttempt?: BoolFilter<"PaymentFailure"> | boolean
    createdAt?: DateTimeFilter<"PaymentFailure"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentFailure"> | Date | string
  }

  export type LeaseCreateWithoutTenantInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentCreateNestedManyWithoutLeaseInput
    Unit: UnitCreateNestedOneWithoutLeaseInput
    reminders?: ReminderLogCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutTenantInput = {
    id?: string
    unitId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutLeaseInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseCreateManyTenantInputEnvelope = {
    data: LeaseCreateManyTenantInput | LeaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type LeaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
    create: XOR<LeaseCreateWithoutTenantInput, LeaseUncheckedCreateWithoutTenantInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutTenantInput, LeaseUncheckedUpdateWithoutTenantInput>
  }

  export type LeaseUpdateManyWithWhereWithoutTenantInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeaseScalarWhereInput = {
    AND?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    OR?: LeaseScalarWhereInput[]
    NOT?: LeaseScalarWhereInput | LeaseScalarWhereInput[]
    id?: StringFilter<"Lease"> | string
    unitId?: StringFilter<"Lease"> | string
    tenantId?: StringFilter<"Lease"> | string
    startDate?: DateTimeFilter<"Lease"> | Date | string
    endDate?: DateTimeFilter<"Lease"> | Date | string
    rentAmount?: FloatFilter<"Lease"> | number
    securityDeposit?: FloatFilter<"Lease"> | number
    terms?: StringNullableFilter<"Lease"> | string | null
    status?: EnumLeaseStatusFilter<"Lease"> | $Enums.LeaseStatus
    createdAt?: DateTimeFilter<"Lease"> | Date | string
    updatedAt?: DateTimeFilter<"Lease"> | Date | string
  }

  export type UserUpsertWithoutTenantInput = {
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type InspectionCreateWithoutUnitInput = {
    id?: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutInspectionInput
    Property: PropertyCreateNestedOneWithoutInspectionInput
  }

  export type InspectionUncheckedCreateWithoutUnitInput = {
    id?: string
    propertyId: string
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateOrConnectWithoutUnitInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput>
  }

  export type InspectionCreateManyUnitInputEnvelope = {
    data: InspectionCreateManyUnitInput | InspectionCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type LeaseCreateWithoutUnitInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentCreateNestedManyWithoutLeaseInput
    Tenant: TenantCreateNestedOneWithoutLeaseInput
    reminders?: ReminderLogCreateNestedManyWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutUnitInput = {
    id?: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutLeaseInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseCreateManyUnitInputEnvelope = {
    data: LeaseCreateManyUnitInput | LeaseCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceRequestCreateWithoutUnitInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseCreateNestedManyWithoutMaintenanceRequestInput
    files?: FileCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutUnitInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseUncheckedCreateNestedManyWithoutMaintenanceRequestInput
    files?: FileUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutUnitInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput>
  }

  export type MaintenanceRequestCreateManyUnitInputEnvelope = {
    data: MaintenanceRequestCreateManyUnitInput | MaintenanceRequestCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutUnitInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUnitInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUnitInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
  }

  export type InspectionUpsertWithWhereUniqueWithoutUnitInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutUnitInput, InspectionUncheckedUpdateWithoutUnitInput>
    create: XOR<InspectionCreateWithoutUnitInput, InspectionUncheckedCreateWithoutUnitInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutUnitInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutUnitInput, InspectionUncheckedUpdateWithoutUnitInput>
  }

  export type InspectionUpdateManyWithWhereWithoutUnitInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutUnitInput>
  }

  export type LeaseUpsertWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    update: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
    create: XOR<LeaseCreateWithoutUnitInput, LeaseUncheckedCreateWithoutUnitInput>
  }

  export type LeaseUpdateWithWhereUniqueWithoutUnitInput = {
    where: LeaseWhereUniqueInput
    data: XOR<LeaseUpdateWithoutUnitInput, LeaseUncheckedUpdateWithoutUnitInput>
  }

  export type LeaseUpdateManyWithWhereWithoutUnitInput = {
    where: LeaseScalarWhereInput
    data: XOR<LeaseUpdateManyMutationInput, LeaseUncheckedUpdateManyWithoutUnitInput>
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutUnitInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutUnitInput, MaintenanceRequestUncheckedUpdateWithoutUnitInput>
    create: XOR<MaintenanceRequestCreateWithoutUnitInput, MaintenanceRequestUncheckedCreateWithoutUnitInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutUnitInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutUnitInput, MaintenanceRequestUncheckedUpdateWithoutUnitInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutUnitInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutUnitInput>
  }

  export type MaintenanceRequestScalarWhereInput = {
    AND?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    OR?: MaintenanceRequestScalarWhereInput[]
    NOT?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    unitId?: StringFilter<"MaintenanceRequest"> | string
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    category?: StringNullableFilter<"MaintenanceRequest"> | string | null
    priority?: EnumPriorityFilter<"MaintenanceRequest"> | $Enums.Priority
    status?: EnumRequestStatusFilter<"MaintenanceRequest"> | $Enums.RequestStatus
    preferredDate?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    allowEntry?: BoolFilter<"MaintenanceRequest"> | boolean
    contactPhone?: StringNullableFilter<"MaintenanceRequest"> | string | null
    requestedBy?: StringNullableFilter<"MaintenanceRequest"> | string | null
    notes?: StringNullableFilter<"MaintenanceRequest"> | string | null
    photos?: StringNullableListFilter<"MaintenanceRequest">
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    estimatedCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
    actualCost?: FloatNullableFilter<"MaintenanceRequest"> | number | null
  }

  export type PropertyUpsertWithoutUnitInput = {
    update: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
    create: XOR<PropertyCreateWithoutUnitInput, PropertyUncheckedCreateWithoutUnitInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutUnitInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutUnitInput, PropertyUncheckedUpdateWithoutUnitInput>
  }

  export type PropertyUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BlogArticleCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagCreateNestedManyWithoutArticlesInput
  }

  export type BlogArticleUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: BlogTagUncheckedCreateNestedManyWithoutArticlesInput
  }

  export type BlogArticleCreateOrConnectWithoutAuthorInput = {
    where: BlogArticleWhereUniqueInput
    create: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput>
  }

  export type BlogArticleCreateManyAuthorInputEnvelope = {
    data: BlogArticleCreateManyAuthorInput | BlogArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutUserInput = {
    id?: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Property: PropertyCreateNestedOneWithoutInspectionInput
    Unit?: UnitCreateNestedOneWithoutInspectionInput
  }

  export type InspectionUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    unitId?: string | null
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateOrConnectWithoutUserInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput>
  }

  export type InspectionCreateManyUserInputEnvelope = {
    data: InspectionCreateManyUserInput | InspectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Subscription?: SubscriptionCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionId?: string | null
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaseGeneratorUsageCreateWithoutUserInput = {
    id?: string
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LeaseGeneratorUsageUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type LeaseGeneratorUsageCreateOrConnectWithoutUserInput = {
    where: LeaseGeneratorUsageWhereUniqueInput
    create: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput>
  }

  export type LeaseGeneratorUsageCreateManyUserInputEnvelope = {
    data: LeaseGeneratorUsageCreateManyUserInput | LeaseGeneratorUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUser_Message_receiverIdToUserInput = {
    id?: string
    threadId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
    User_Message_senderIdToUser: UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput
  }

  export type MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput = {
    id?: string
    threadId: string
    senderId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageCreateManyUser_Message_receiverIdToUserInputEnvelope = {
    data: MessageCreateManyUser_Message_receiverIdToUserInput | MessageCreateManyUser_Message_receiverIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUser_Message_senderIdToUserInput = {
    id?: string
    threadId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
    User_Message_receiverIdToUser: UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput
  }

  export type MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput = {
    id?: string
    threadId: string
    receiverId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageCreateManyUser_Message_senderIdToUserInputEnvelope = {
    data: MessageCreateManyUser_Message_senderIdToUserInput | MessageCreateManyUser_Message_senderIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
    files?: FileCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
    files?: FileUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceCreateNestedManyWithoutSubscriptionInput
    paymentFailures?: PaymentFailureCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    paymentFailures?: PaymentFailureUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput>
  }

  export type TenantCreateManyUserInputEnvelope = {
    data: TenantCreateManyUserInput | TenantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReminderLogCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Lease?: LeaseCreateNestedOneWithoutRemindersInput
  }

  export type ReminderLogUncheckedCreateWithoutUserInput = {
    id?: string
    leaseId?: string | null
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderLogCreateOrConnectWithoutUserInput = {
    where: ReminderLogWhereUniqueInput
    create: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput>
  }

  export type ReminderLogCreateManyUserInputEnvelope = {
    data: ReminderLogCreateManyUserInput | ReminderLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    enableReminders?: boolean
    daysBeforeDue?: number
    enableOverdueReminders?: boolean
    overdueGracePeriod?: number
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: string
    showWelcomeMessage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    enableReminders?: boolean
    daysBeforeDue?: number
    enableOverdueReminders?: boolean
    overdueGracePeriod?: number
    autoSendReminders?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    defaultDashboardView?: string
    showWelcomeMessage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFeatureAccessCreateWithoutUserInput = {
    id?: string
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: number
    maxUnitsPerProperty?: number
    maxStorageGB?: number
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: Date | string
    updateReason?: string | null
    createdAt?: Date | string
  }

  export type UserFeatureAccessUncheckedCreateWithoutUserInput = {
    id?: string
    canExportData?: boolean
    canAccessAdvancedAnalytics?: boolean
    canUseBulkOperations?: boolean
    canAccessAPI?: boolean
    canInviteTeamMembers?: boolean
    maxProperties?: number
    maxUnitsPerProperty?: number
    maxStorageGB?: number
    hasPrioritySupport?: boolean
    canUsePremiumIntegrations?: boolean
    lastUpdated?: Date | string
    updateReason?: string | null
    createdAt?: Date | string
  }

  export type UserFeatureAccessCreateOrConnectWithoutUserInput = {
    where: UserFeatureAccessWhereUniqueInput
    create: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
  }

  export type UserAccessLogCreateWithoutUserInput = {
    id?: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserAccessLogUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type UserAccessLogCreateOrConnectWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    create: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput>
  }

  export type UserAccessLogCreateManyUserInputEnvelope = {
    data: UserAccessLogCreateManyUserInput | UserAccessLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutUserInput = {
    id?: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
  }

  export type NotificationLogCreateOrConnectWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateManyUserInputEnvelope = {
    data: NotificationLogCreateManyUserInput | NotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    createdAt?: Date | string
    Property?: PropertyCreateNestedOneWithoutFilesInput
    MaintenanceRequest?: MaintenanceRequestCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    propertyId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutUploadedByInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
  }

  export type FileCreateManyUploadedByInputEnvelope = {
    data: FileCreateManyUploadedByInput | FileCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type BlogArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogArticleWhereUniqueInput
    update: XOR<BlogArticleUpdateWithoutAuthorInput, BlogArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogArticleCreateWithoutAuthorInput, BlogArticleUncheckedCreateWithoutAuthorInput>
  }

  export type BlogArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogArticleWhereUniqueInput
    data: XOR<BlogArticleUpdateWithoutAuthorInput, BlogArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogArticleScalarWhereInput
    data: XOR<BlogArticleUpdateManyMutationInput, BlogArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type InspectionUpsertWithWhereUniqueWithoutUserInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutUserInput, InspectionUncheckedUpdateWithoutUserInput>
    create: XOR<InspectionCreateWithoutUserInput, InspectionUncheckedCreateWithoutUserInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutUserInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutUserInput, InspectionUncheckedUpdateWithoutUserInput>
  }

  export type InspectionUpdateManyWithWhereWithoutUserInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaseGeneratorUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaseGeneratorUsageWhereUniqueInput
    update: XOR<LeaseGeneratorUsageUpdateWithoutUserInput, LeaseGeneratorUsageUncheckedUpdateWithoutUserInput>
    create: XOR<LeaseGeneratorUsageCreateWithoutUserInput, LeaseGeneratorUsageUncheckedCreateWithoutUserInput>
  }

  export type LeaseGeneratorUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaseGeneratorUsageWhereUniqueInput
    data: XOR<LeaseGeneratorUsageUpdateWithoutUserInput, LeaseGeneratorUsageUncheckedUpdateWithoutUserInput>
  }

  export type LeaseGeneratorUsageUpdateManyWithWhereWithoutUserInput = {
    where: LeaseGeneratorUsageScalarWhereInput
    data: XOR<LeaseGeneratorUsageUpdateManyMutationInput, LeaseGeneratorUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaseGeneratorUsageScalarWhereInput = {
    AND?: LeaseGeneratorUsageScalarWhereInput | LeaseGeneratorUsageScalarWhereInput[]
    OR?: LeaseGeneratorUsageScalarWhereInput[]
    NOT?: LeaseGeneratorUsageScalarWhereInput | LeaseGeneratorUsageScalarWhereInput[]
    id?: StringFilter<"LeaseGeneratorUsage"> | string
    userId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    email?: StringFilter<"LeaseGeneratorUsage"> | string
    ipAddress?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    userAgent?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    usageCount?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    paymentStatus?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeSessionId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    stripeCustomerId?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    amountPaid?: IntNullableFilter<"LeaseGeneratorUsage"> | number | null
    currency?: StringNullableFilter<"LeaseGeneratorUsage"> | string | null
    paymentDate?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    accessExpiresAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LeaseGeneratorUsage"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput>
    create: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUser_Message_senderIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput>
    create: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUser_Message_senderIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserInput>
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zipCode?: StringFilter<"Property"> | string
    description?: StringNullableFilter<"Property"> | string | null
    imageUrl?: StringNullableFilter<"Property"> | string | null
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    propertyType?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    status?: EnumSubStatusFilter<"Subscription"> | $Enums.SubStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripePriceId?: StringNullableFilter<"Subscription"> | string | null
    planId?: StringNullableFilter<"Subscription"> | string | null
    planType?: EnumPlanTypeNullableFilter<"Subscription"> | $Enums.PlanType | null
    billingPeriod?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolNullableFilter<"Subscription"> | boolean | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
  }

  export type TenantUpsertWithWhereUniqueWithoutUserInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutUserInput, TenantUncheckedUpdateWithoutUserInput>
    create: XOR<TenantCreateWithoutUserInput, TenantUncheckedCreateWithoutUserInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutUserInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutUserInput, TenantUncheckedUpdateWithoutUserInput>
  }

  export type TenantUpdateManyWithWhereWithoutUserInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    email?: StringFilter<"Tenant"> | string
    phone?: StringNullableFilter<"Tenant"> | string | null
    emergencyContact?: StringNullableFilter<"Tenant"> | string | null
    avatarUrl?: StringNullableFilter<"Tenant"> | string | null
    userId?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    entityType?: EnumActivityEntityTypeFilter<"Activity"> | $Enums.ActivityEntityType
    entityId?: StringFilter<"Activity"> | string
    entityName?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ReminderLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ReminderLogWhereUniqueInput
    update: XOR<ReminderLogUpdateWithoutUserInput, ReminderLogUncheckedUpdateWithoutUserInput>
    create: XOR<ReminderLogCreateWithoutUserInput, ReminderLogUncheckedCreateWithoutUserInput>
  }

  export type ReminderLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ReminderLogWhereUniqueInput
    data: XOR<ReminderLogUpdateWithoutUserInput, ReminderLogUncheckedUpdateWithoutUserInput>
  }

  export type ReminderLogUpdateManyWithWhereWithoutUserInput = {
    where: ReminderLogScalarWhereInput
    data: XOR<ReminderLogUpdateManyMutationInput, ReminderLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    enableReminders?: BoolFieldUpdateOperationsInput | boolean
    daysBeforeDue?: IntFieldUpdateOperationsInput | number
    enableOverdueReminders?: BoolFieldUpdateOperationsInput | boolean
    overdueGracePeriod?: IntFieldUpdateOperationsInput | number
    autoSendReminders?: BoolFieldUpdateOperationsInput | boolean
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    defaultDashboardView?: StringFieldUpdateOperationsInput | string
    showWelcomeMessage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    refreshTokenId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivity?: DateTimeFilter<"UserSession"> | Date | string
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    invalidatedAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserFeatureAccessUpsertWithoutUserInput = {
    update: XOR<UserFeatureAccessUpdateWithoutUserInput, UserFeatureAccessUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeatureAccessCreateWithoutUserInput, UserFeatureAccessUncheckedCreateWithoutUserInput>
    where?: UserFeatureAccessWhereInput
  }

  export type UserFeatureAccessUpdateToOneWithWhereWithoutUserInput = {
    where?: UserFeatureAccessWhereInput
    data: XOR<UserFeatureAccessUpdateWithoutUserInput, UserFeatureAccessUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canExportData?: BoolFieldUpdateOperationsInput | boolean
    canAccessAdvancedAnalytics?: BoolFieldUpdateOperationsInput | boolean
    canUseBulkOperations?: BoolFieldUpdateOperationsInput | boolean
    canAccessAPI?: BoolFieldUpdateOperationsInput | boolean
    canInviteTeamMembers?: BoolFieldUpdateOperationsInput | boolean
    maxProperties?: IntFieldUpdateOperationsInput | number
    maxUnitsPerProperty?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    hasPrioritySupport?: BoolFieldUpdateOperationsInput | boolean
    canUsePremiumIntegrations?: BoolFieldUpdateOperationsInput | boolean
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    updateReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    update: XOR<UserAccessLogUpdateWithoutUserInput, UserAccessLogUncheckedUpdateWithoutUserInput>
    create: XOR<UserAccessLogCreateWithoutUserInput, UserAccessLogUncheckedCreateWithoutUserInput>
  }

  export type UserAccessLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAccessLogWhereUniqueInput
    data: XOR<UserAccessLogUpdateWithoutUserInput, UserAccessLogUncheckedUpdateWithoutUserInput>
  }

  export type UserAccessLogUpdateManyWithWhereWithoutUserInput = {
    where: UserAccessLogScalarWhereInput
    data: XOR<UserAccessLogUpdateManyMutationInput, UserAccessLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAccessLogScalarWhereInput = {
    AND?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
    OR?: UserAccessLogScalarWhereInput[]
    NOT?: UserAccessLogScalarWhereInput | UserAccessLogScalarWhereInput[]
    id?: StringFilter<"UserAccessLog"> | string
    userId?: StringFilter<"UserAccessLog"> | string
    subscriptionStatus?: StringFilter<"UserAccessLog"> | string
    planType?: StringFilter<"UserAccessLog"> | string
    reason?: StringFilter<"UserAccessLog"> | string
    accessGranted?: JsonFilter<"UserAccessLog">
    timestamp?: DateTimeFilter<"UserAccessLog"> | Date | string
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonFilter<"NotificationLog">
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type FileUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUploadedByInput, FileUncheckedUpdateWithoutUploadedByInput>
    create: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUploadedByInput, FileUncheckedUpdateWithoutUploadedByInput>
  }

  export type FileUpdateManyWithWhereWithoutUploadedByInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutRemindersInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutRemindersInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutRemindersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
  }

  export type LeaseCreateWithoutRemindersInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentCreateNestedManyWithoutLeaseInput
    Tenant: TenantCreateNestedOneWithoutLeaseInput
    Unit: UnitCreateNestedOneWithoutLeaseInput
  }

  export type LeaseUncheckedCreateWithoutRemindersInput = {
    id?: string
    unitId: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Document?: DocumentUncheckedCreateNestedManyWithoutLeaseInput
  }

  export type LeaseCreateOrConnectWithoutRemindersInput = {
    where: LeaseWhereUniqueInput
    create: XOR<LeaseCreateWithoutRemindersInput, LeaseUncheckedCreateWithoutRemindersInput>
  }

  export type UserUpsertWithoutRemindersInput = {
    update: XOR<UserUpdateWithoutRemindersInput, UserUncheckedUpdateWithoutRemindersInput>
    create: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRemindersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRemindersInput, UserUncheckedUpdateWithoutRemindersInput>
  }

  export type UserUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type LeaseUpsertWithoutRemindersInput = {
    update: XOR<LeaseUpdateWithoutRemindersInput, LeaseUncheckedUpdateWithoutRemindersInput>
    create: XOR<LeaseCreateWithoutRemindersInput, LeaseUncheckedCreateWithoutRemindersInput>
    where?: LeaseWhereInput
  }

  export type LeaseUpdateToOneWithWhereWithoutRemindersInput = {
    where?: LeaseWhereInput
    data: XOR<LeaseUpdateWithoutRemindersInput, LeaseUncheckedUpdateWithoutRemindersInput>
  }

  export type LeaseUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUpdateManyWithoutLeaseNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    Unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutFeatureAccessInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutFeatureAccessInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutFeatureAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeatureAccessInput, UserUncheckedCreateWithoutFeatureAccessInput>
  }

  export type UserUpsertWithoutFeatureAccessInput = {
    update: XOR<UserUpdateWithoutFeatureAccessInput, UserUncheckedUpdateWithoutFeatureAccessInput>
    create: XOR<UserCreateWithoutFeatureAccessInput, UserUncheckedCreateWithoutFeatureAccessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeatureAccessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeatureAccessInput, UserUncheckedUpdateWithoutFeatureAccessInput>
  }

  export type UserUpdateWithoutFeatureAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFeatureAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutAccessLogsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAccessLogsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAccessLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessLogsInput, UserUncheckedCreateWithoutAccessLogsInput>
  }

  export type UserUpsertWithoutAccessLogsInput = {
    update: XOR<UserUpdateWithoutAccessLogsInput, UserUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<UserCreateWithoutAccessLogsInput, UserUncheckedCreateWithoutAccessLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccessLogsInput, UserUncheckedUpdateWithoutAccessLogsInput>
  }

  export type UserUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutNotificationLogsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutNotificationLogsInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutNotificationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationLogsInput, UserUncheckedCreateWithoutNotificationLogsInput>
  }

  export type UserUpsertWithoutNotificationLogsInput = {
    update: XOR<UserUpdateWithoutNotificationLogsInput, UserUncheckedUpdateWithoutNotificationLogsInput>
    create: XOR<UserCreateWithoutNotificationLogsInput, UserUncheckedCreateWithoutNotificationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationLogsInput, UserUncheckedUpdateWithoutNotificationLogsInput>
  }

  export type UserUpdateWithoutNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutUploadedFilesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    Tenant?: TenantCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    reminders?: ReminderLogCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedFilesInput = {
    id: string
    supabaseId: string
    stripeCustomerId?: string | null
    email: string
    name?: string | null
    phone?: string | null
    bio?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    BlogArticle?: BlogArticleUncheckedCreateNestedManyWithoutAuthorInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    Tenant?: TenantUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    reminders?: ReminderLogUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    featureAccess?: UserFeatureAccessUncheckedCreateNestedOneWithoutUserInput
    accessLogs?: UserAccessLogUncheckedCreateNestedManyWithoutUserInput
    notificationLogs?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
  }

  export type PropertyCreateWithoutFilesInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionCreateNestedManyWithoutPropertyInput
    User: UserCreateNestedOneWithoutPropertyInput
    Unit?: UnitCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
    Document?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    Expense?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    Inspection?: InspectionUncheckedCreateNestedManyWithoutPropertyInput
    Unit?: UnitUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutFilesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
  }

  export type MaintenanceRequestCreateWithoutFilesInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseCreateNestedManyWithoutMaintenanceRequestInput
    Unit: UnitCreateNestedOneWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutFilesInput = {
    id?: string
    unitId: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
    Expense?: ExpenseUncheckedCreateNestedManyWithoutMaintenanceRequestInput
  }

  export type MaintenanceRequestCreateOrConnectWithoutFilesInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutFilesInput, MaintenanceRequestUncheckedCreateWithoutFilesInput>
  }

  export type UserUpsertWithoutUploadedFilesInput = {
    update: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type UserUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    Tenant?: TenantUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BlogArticle?: BlogArticleUncheckedUpdateManyWithoutAuthorNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    LeaseGeneratorUsage?: LeaseGeneratorUsageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Tenant?: TenantUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    featureAccess?: UserFeatureAccessUncheckedUpdateOneWithoutUserNestedInput
    accessLogs?: UserAccessLogUncheckedUpdateManyWithoutUserNestedInput
    notificationLogs?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PropertyUpsertWithoutFilesInput = {
    update: XOR<PropertyUpdateWithoutFilesInput, PropertyUncheckedUpdateWithoutFilesInput>
    create: XOR<PropertyCreateWithoutFilesInput, PropertyUncheckedCreateWithoutFilesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutFilesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutFilesInput, PropertyUncheckedUpdateWithoutFilesInput>
  }

  export type PropertyUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    User?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type MaintenanceRequestUpsertWithoutFilesInput = {
    update: XOR<MaintenanceRequestUpdateWithoutFilesInput, MaintenanceRequestUncheckedUpdateWithoutFilesInput>
    create: XOR<MaintenanceRequestCreateWithoutFilesInput, MaintenanceRequestUncheckedCreateWithoutFilesInput>
    where?: MaintenanceRequestWhereInput
  }

  export type MaintenanceRequestUpdateToOneWithWhereWithoutFilesInput = {
    where?: MaintenanceRequestWhereInput
    data: XOR<MaintenanceRequestUpdateWithoutFilesInput, MaintenanceRequestUncheckedUpdateWithoutFilesInput>
  }

  export type MaintenanceRequestUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUpdateManyWithoutMaintenanceRequestNestedInput
    Unit?: UnitUpdateOneRequiredWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type SubscriptionCreateWithoutPaymentFailuresInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceCreateNestedManyWithoutSubscriptionInput
    User: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentFailuresInput = {
    id?: string
    userId: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPaymentFailuresInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentFailuresInput, SubscriptionUncheckedCreateWithoutPaymentFailuresInput>
  }

  export type SubscriptionUpsertWithoutPaymentFailuresInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentFailuresInput, SubscriptionUncheckedUpdateWithoutPaymentFailuresInput>
    create: XOR<SubscriptionCreateWithoutPaymentFailuresInput, SubscriptionUncheckedCreateWithoutPaymentFailuresInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentFailuresInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentFailuresInput, SubscriptionUncheckedUpdateWithoutPaymentFailuresInput>
  }

  export type SubscriptionUpdateWithoutPaymentFailuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    User?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentFailuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type BlogTagUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateManyWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogArticleUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutBlogArticleNestedInput
  }

  export type BlogArticleUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogArticleUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CustomerInvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyLeaseInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    propertyId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type ReminderLogCreateManyLeaseInput = {
    id?: string
    userId: string
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    Property?: PropertyUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DocumentUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReminderLogUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type ReminderLogUncheckedUpdateWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogUncheckedUpdateManyWithoutLeaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyMaintenanceRequestInput = {
    id?: string
    propertyId: string
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateManyMaintenanceRequestInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    propertyId?: string | null
    createdAt?: Date | string
  }

  export type ExpenseUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UploadedBy?: UserUpdateOneWithoutUploadedFilesNestedInput
    Property?: PropertyUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutMaintenanceRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyPropertyInput = {
    id?: string
    name: string
    filename?: string | null
    url: string
    type: $Enums.DocumentType
    mimeType?: string | null
    size?: bigint | number | null
    leaseId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    fileSizeBytes?: bigint | number
  }

  export type ExpenseCreateManyPropertyInput = {
    id?: string
    maintenanceId?: string | null
    amount: number
    category: string
    description: string
    date: Date | string
    receiptUrl?: string | null
    vendorName?: string | null
    vendorContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyPropertyInput = {
    id?: string
    unitId?: string | null
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyPropertyInput = {
    id?: string
    unitNumber: string
    bedrooms?: number
    bathrooms?: number
    squareFeet?: number | null
    rent: number
    status?: $Enums.UnitStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastInspectionDate?: Date | string | null
  }

  export type FileCreateManyPropertyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    uploadedById?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    Lease?: LeaseUpdateOneWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DocumentUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileSizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ExpenseUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MaintenanceRequest?: MaintenanceRequestUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInspectionNestedInput
    Unit?: UnitUpdateOneWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inspection?: InspectionUncheckedUpdateManyWithoutUnitNestedInput
    Lease?: LeaseUncheckedUpdateManyWithoutUnitNestedInput
    MaintenanceRequest?: MaintenanceRequestUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitNumber?: StringFieldUpdateOperationsInput | string
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: FloatFieldUpdateOperationsInput | number
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rent?: FloatFieldUpdateOperationsInput | number
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastInspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UploadedBy?: UserUpdateOneWithoutUploadedFilesNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: string
    userId: string
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentFailureCreateManySubscriptionInput = {
    id?: string
    stripeInvoiceId: string
    amount: number
    currency: string
    attemptCount?: number
    errorCode?: string | null
    errorMessage?: string | null
    nextRetryAt?: Date | string | null
    resolved?: boolean
    resolvedAt?: Date | string | null
    finalAttempt?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentFailureUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAttempt?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseCreateManyTenantInput = {
    id?: string
    unitId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUpdateManyWithoutLeaseNestedInput
    Unit?: UnitUpdateOneRequiredWithoutLeaseNestedInput
    reminders?: ReminderLogUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutLeaseNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionCreateManyUnitInput = {
    id?: string
    propertyId: string
    inspectorId: string
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseCreateManyUnitInput = {
    id?: string
    tenantId: string
    startDate: Date | string
    endDate: Date | string
    rentAmount: number
    securityDeposit: number
    terms?: string | null
    status?: $Enums.LeaseStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateManyUnitInput = {
    id?: string
    title: string
    description: string
    category?: string | null
    priority?: $Enums.Priority
    status?: $Enums.RequestStatus
    preferredDate?: Date | string | null
    allowEntry?: boolean
    contactPhone?: string | null
    requestedBy?: string | null
    notes?: string | null
    photos?: MaintenanceRequestCreatephotosInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo?: string | null
    estimatedCost?: number | null
    actualCost?: number | null
  }

  export type InspectionUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInspectionNestedInput
    Property?: PropertyUpdateOneRequiredWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    inspectorId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUpdateManyWithoutLeaseNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutLeaseNestedInput
    reminders?: ReminderLogUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Document?: DocumentUncheckedUpdateManyWithoutLeaseNestedInput
    reminders?: ReminderLogUncheckedUpdateManyWithoutLeaseNestedInput
  }

  export type LeaseUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rentAmount?: FloatFieldUpdateOperationsInput | number
    securityDeposit?: FloatFieldUpdateOperationsInput | number
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaseStatusFieldUpdateOperationsInput | $Enums.LeaseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUpdateManyWithoutMaintenanceRequestNestedInput
    files?: FileUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    Expense?: ExpenseUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
    files?: FileUncheckedUpdateManyWithoutMaintenanceRequestNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    preferredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowEntry?: BoolFieldUpdateOperationsInput | boolean
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: MaintenanceRequestUpdatephotosInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BlogArticleCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    description: string
    content: string
    excerpt?: string | null
    authorName: string
    metaTitle?: string | null
    metaDescription?: string | null
    ogImage?: string | null
    category?: $Enums.BlogCategory
    status?: $Enums.BlogStatus
    featured?: boolean
    publishedAt?: Date | string | null
    viewCount?: number
    readTime?: number | null
    searchKeywords?: BlogArticleCreatesearchKeywordsInput | string[]
    lastIndexed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyUserInput = {
    id?: string
    propertyId: string
    unitId?: string | null
    type?: string
    scheduledDate: Date | string
    completedDate?: Date | string | null
    status?: string
    notes?: string | null
    reportUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    subscriptionId?: string | null
    stripeInvoiceId: string
    amountPaid: number
    amountDue: number
    currency?: string
    status: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    invoiceUrl?: string | null
    invoicePdf?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaseGeneratorUsageCreateManyUserInput = {
    id?: string
    email: string
    ipAddress?: string | null
    userAgent?: string | null
    usageCount?: number | null
    paymentStatus?: string | null
    stripeSessionId?: string | null
    stripeCustomerId?: string | null
    amountPaid?: number | null
    currency?: string | null
    paymentDate?: Date | string | null
    accessExpiresAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateManyUser_Message_receiverIdToUserInput = {
    id?: string
    threadId: string
    senderId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyUser_Message_senderIdToUserInput = {
    id?: string
    threadId: string
    receiverId: string
    content: string
    readAt?: Date | string | null
    attachmentUrl?: string | null
    createdAt?: Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyType?: $Enums.PropertyType
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    status: $Enums.SubStatus
    startDate?: Date | string
    endDate?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    planId?: string | null
    planType?: $Enums.PlanType | null
    billingPeriod?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean | null
    canceledAt?: Date | string | null
  }

  export type TenantCreateManyUserInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    emergencyContact?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    action: string
    entityType: $Enums.ActivityEntityType
    entityId: string
    entityName?: string | null
    createdAt?: Date | string
  }

  export type ReminderLogCreateManyUserInput = {
    id?: string
    leaseId?: string | null
    type: $Enums.ReminderType
    status?: $Enums.ReminderStatus
    recipientEmail: string
    recipientName?: string | null
    subject?: string | null
    content?: string | null
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    openedAt?: Date | string | null
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    refreshTokenId: string
    expiresAt: Date | string
    lastActivity?: Date | string
    userAgent?: string | null
    ipAddress?: string | null
    isActive?: boolean
    invalidatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccessLogCreateManyUserInput = {
    id?: string
    subscriptionStatus: string
    planType: string
    reason: string
    accessGranted: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type NotificationLogCreateManyUserInput = {
    id?: string
    type: string
    subscriptionId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string
    createdAt?: Date | string
  }

  export type FileCreateManyUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size?: number | null
    url: string
    propertyId?: string | null
    maintenanceRequestId?: string | null
    createdAt?: Date | string
  }

  export type BlogArticleUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUpdateManyWithoutArticlesNestedInput
  }

  export type BlogArticleUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: BlogTagUncheckedUpdateManyWithoutArticlesNestedInput
  }

  export type BlogArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumBlogCategoryFieldUpdateOperationsInput | $Enums.BlogCategory
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    searchKeywords?: BlogArticleUpdatesearchKeywordsInput | string[]
    lastIndexed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneRequiredWithoutInspectionNestedInput
    Unit?: UnitUpdateOneWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Subscription?: SubscriptionUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    amountPaid?: IntFieldUpdateOperationsInput | number
    amountDue?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePdf?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaseGeneratorUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseGeneratorUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaseGeneratorUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    usageCount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_senderIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput
  }

  export type MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_receiverIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput
  }

  export type MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUpdateManyWithoutPropertyNestedInput
    files?: FileUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    Document?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    Expense?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    Inspection?: InspectionUncheckedUpdateManyWithoutPropertyNestedInput
    Unit?: UnitUncheckedUpdateManyWithoutPropertyNestedInput
    files?: FileUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    paymentFailures?: PaymentFailureUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Invoice?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    paymentFailures?: PaymentFailureUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubStatusFieldUpdateOperationsInput | $Enums.SubStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: NullableEnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType | null
    billingPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: NullableBoolFieldUpdateOperationsInput | boolean | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TenantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    entityId?: StringFieldUpdateOperationsInput | string
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lease?: LeaseUpdateOneWithoutRemindersNestedInput
  }

  export type ReminderLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshTokenId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccessLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    accessGranted?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Property?: PropertyUpdateOneWithoutFilesNestedInput
    MaintenanceRequest?: MaintenanceRequestUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}